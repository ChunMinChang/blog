I"Ê/<p>Preventing overflow is essential
while calculating the average of a long series of data.
One simplest method to avoid the problem is <em>running average</em>
(or <em>moving average</em>, <em>rolling average</em>, <em>incremental mean</em>).</p>

<h2 id="problem">Problem</h2>
<p>Suppose we have data <script type="math/tex">x_1, x_2, \cdots, x_n</script>.
The <script type="math/tex">sum_{n+1}</script> will overflow when the new data <script type="math/tex">x_{n+1}</script> is counted,
where <script type="math/tex">sum_i = x_1 + x_2 + \cdots + x_i</script>.
At that time, <script type="math/tex">\mu_{n+1} = \frac{sum_{n+1}}{n+1}</script> will be wrong,
where <script type="math/tex">\mu_i</script> is the average of <script type="math/tex">x_1, x_2, \cdots, x_i</script>,
since <script type="math/tex">sum_{n+1}</script> is an overflowed value.</p>

<p>How could we solve the problem?</p>

<h2 id="naive-approach">Naive Approach</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">data</span> <span class="o">&lt;</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Overflow!</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="p">;</span>
  <span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">GetAverage</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above approach to prevent overflow
is extracted from <a href="https://searchfox.org/mozilla-central/rev/f5f1c3f294f89cfd242c3af9eb2c40d19d5e04e7/dom/media/mp3/MP3Demuxer.cpp#709-715,720,728,756-760" title="Wrong calculation for mp3 time length as we prevent overflow">Gecko MP3Demuxer</a>,
but itâ€™s <strong>wrong</strong> in most cases
(itâ€™s only correct when every incoming data is same).
For example, if we have <script type="math/tex">x_1 = 10, x_2 = 20</script>
and <script type="math/tex">x_3 = 90</script> will lead to overflow to the sum of <script type="math/tex">x_i</script>
so the average computed by above approach will be <script type="math/tex">\frac{(10+20)/2 + 90}{2/2 + 1} = 52.5</script>,
which is different from <script type="math/tex">\frac{10 + 20 + 90}{3} = 40</script>.
I cannot believe this incorrect code
lives in Firefox <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1093815">more than 3 years</a>.
Fortunately, the overflow happens once in a blue moon
so itâ€™s not too much trouble.</p>

<h3 id="proof">Proof</h3>
<p>We can formally prove the above approach is incorrect.
Let <script type="math/tex">sum_{k}</script> and <script type="math/tex">\mu_k</script> be the <strong>sum</strong> and <strong>arithmetic mean</strong>
of <script type="math/tex">x_1, x_2, \cdots, x_k</script> respectively, and <script type="math/tex">E_k</script> be the estimated average
from above approach.</p>

<p>Since the new incoming data <script type="math/tex">x_{n+1}</script> will cause overflow to <script type="math/tex">sum_{n+1}</script>, so</p>

<p><script type="math/tex">E_{n+1} = \frac{p + x_{n+1}}{q + 1}</script>
, where
<script type="math/tex">p = \frac{sum_{n}}{2} = \frac{x_1 + x_2 + \cdots + x_n}{2}</script>
and
<script type="math/tex">q = \frac{n}{2}</script></p>

<p>As a result,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
E_{n+1}
&= \frac{p + x_{n+1}}{q + 1} \\
&= \frac{\frac{x_1 + x_2 + \cdots + x_n}{2} + x_{n+1}}{\frac{n}{2} + 1} \\
&= \frac{\frac{x_1 + x_2 + \cdots + x_n + 2 \cdot x_{n+1}}{2}}{\frac{n + 2}{2}} \\
&= \frac{x_1 + x_2 + \cdots + x_n + 2 \cdot x_{n+1}}{n+2}
\end{align} %]]></script>

<p>We could compare <script type="math/tex">E_{n+1}</script> and <script type="math/tex">\mu_{n+1}</script> to see if they are equal:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\mu_{n+1}
&= \frac{x_1 + x_2 + \cdots + x_n + x_{n+1}}{n+1} \\
&= \frac{(n+2) \cdot (x_1 + x_2 + \cdots + x_n + x_{n+1})}{(n+1) \cdot (n+2)} \\
&= \frac{(n+1) \cdot (x_1 + x_2 + \cdots + x_n + x_{n+1}) + (x_1 + x_2 + \cdots + x_n + x_{n+1})}{(n+1) \cdot (n+2)}
\\
E_{n+1}
&= \frac{x_1 + x_2 + \cdots + x_n + 2 \cdot x_{n+1}}{n+2} \\
&= \frac{(x_1 + x_2 + \cdots + x_n + x_{n+1}) + x_{n+1}}{n+2} \\
&= \frac{(n+1) \cdot ((x_1 + x_2 + \cdots + x_n + x_{n+1}) + x_{n+1})}{(n+1) \cdot (n+2)} \\
&= \frac{(n+1) \cdot (x_1 + x_2 + \cdots + x_n + x_{n+1}) + (n+1) \cdot x_{n+1}}{(n+1) \cdot (n+2)} \\
&= \frac{(n+1) \cdot (x_1 + x_2 + \cdots + x_n + x_{n+1}) + (\overbrace{x_{n+1} + \cdots + x_{n+1}}^{n+1}))}{(n+1) \cdot (n+2)}
\\
\mu_{n+1} - E_{n+1}
&= \frac{ (x_1 + x_2 + \cdots + x_n + x_{n+1}) - (\overbrace{x_{n+1} + \cdots + x_{n+1}}^{n+1}))}{(n+1) \cdot (n+2)} \\
&= \frac{ (x_1 - x_{n+1}) + (x_2 - x_{n+1}) + \cdots +  (x_n - x_{n+1}) + (x_{n+1} - x_{n+1})}{(n+1) \cdot (n+2)} \\
&= \frac{ (x_1 - x_{n+1}) + (x_2 - x_{n+1}) + \cdots +  (x_n - x_{n+1}) }{(n+1) \cdot (n+2)}
\end{align} %]]></script>

<p>Thus, we can clearly see that
<script type="math/tex">\mu_{n+1}</script> will be equal to <script type="math/tex">E_{n+1}</script>
<strong>only</strong> when <script type="math/tex">x_1 = x_2 = \cdots = x_n = x_{n+1}</script>.</p>

<h2 id="running-average">Running Average</h2>

<p>In fact, the average can be calculated
without using the overflowed <script type="math/tex">sum_{n+1}</script>.
Let <script type="math/tex">\mu_n</script> be the mean of <script type="math/tex">x_1, x_2, \cdots, x_n</script>,
we can get <script type="math/tex">\mu_n</script> by <script type="math/tex">\mu_{n-1}</script>:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\mu_n
&= \frac{ \mu_{n-1} \cdot (n-1) + x_n }{ n } \\
&= \frac{ n \cdot \mu_{n-1} + x_n - \mu_{n-1}}{ n } \\
&= \mu_{n-1} + \frac{ x_n - \mu_{n-1} }{ n }
\end{align} %]]></script>

<h3 id="sample-code">Sample code</h3>

<p>On this ground, we could correct the <a href="https://gist.github.com/ChunMinChang/a1d7533859dba59a1701d1d42c29bf82" title="Calculating average without sum">code</a> into:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">average</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">average</span> <span class="o">+=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">average</span><span class="p">)</span> <span class="o">/</span> <span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">GetAverage</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">average</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>or</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">UpdateAverage</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">double</span> <span class="n">average</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">average</span> <span class="o">+=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">average</span><span class="p">)</span> <span class="o">/</span> <span class="o">++</span><span class="n">count</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">average</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>or</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Averager</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Averager</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">average</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="o">~</span><span class="n">Averager</span><span class="p">()</span> <span class="p">{};</span>

  <span class="kt">void</span> <span class="n">Add</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="n">average</span> <span class="o">+=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">average</span><span class="p">)</span> <span class="o">/</span> <span class="o">++</span><span class="n">count</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">double</span> <span class="n">GetAverage</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">average</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">double</span> <span class="n">average</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="references">References</h2>

<p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1423834" title="Bug 1423834 - Wrong calculation for mp3 time length as we prevent overflow">Bug 1423834</a> has been filed for this problem
when I found this code in <a href="https://searchfox.org/mozilla-central/rev/f5f1c3f294f89cfd242c3af9eb2c40d19d5e04e7/dom/media/mp3/MP3Demuxer.cpp#709-715,720,728,756-760" title="Wrong calculation for mp3 time length as we prevent overflow">MP3Demuxer</a>.
You could find more detail there.</p>

<p>The following links are some related resources:</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Moving_average">Moving average on Wiki</a></li>
  <li><a href="https://math.stackexchange.com/questions/106700/incremental-averageing">Incremental averageing</a></li>
  <li><a href="https://stackoverflow.com/questions/3316261/prevent-long-running-averaging-from-overflow">Prevent long running averaging from overflow?</a></li>
</ul>

:ET