I"µ<p>In <!--[last post](/post/refptr-v-s-shared-ptr)-->
<a href="https://chunminchang.github.io/blog/post/refptr-v-s-shared-ptr">previous post</a>,
I introduced the <code class="highlighter-rouge">RefPtr&lt;T&gt;</code> that can keep tracking the references to the
object <code class="highlighter-rouge">T</code> and the references are counted by object <code class="highlighter-rouge">T</code> itself.</p>

<p>Today, I will note my misuse of it several weeks ago.
This is also why I want to write the posts about <code class="highlighter-rouge">RefPtr&lt;T&gt;</code>.</p>

<h2 id="what-behavior-i-want">What behavior I want</h2>
<p>The following behavior is what I want when I was implementing one patch
for Firefox:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Solder</span><span class="o">&gt;&gt;</span> <span class="n">l</span><span class="p">;</span> <span class="c1">// A list containing all of the solders.</span>
<span class="p">{</span>
  <span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Solder</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="k">new</span> <span class="n">Solder</span><span class="p">(</span><span class="mi">99</span><span class="p">));</span> <span class="c1">// Put the `s` into the list.</span>
<span class="p">}</span>
<span class="c1">// The `s` is destroyed, so it should be removed from the list now.</span>
</code></pre></div></div>

<p>and we will put the <code class="highlighter-rouge">Solder</code> instance into the <code class="highlighter-rouge">l</code> when
itâ€™s created and remove it when itâ€™s destroyed.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Solder</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Add</span> <span class="k">this</span> <span class="n">into</span> <span class="err">`</span><span class="n">l</span><span class="err">`</span>
<span class="p">}</span>
<span class="o">~</span><span class="n">Solder</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Remove</span> <span class="k">this</span> <span class="n">from</span> <span class="err">`</span><span class="n">l</span><span class="err">`</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="why-it-doesnt-work">Why it doesnâ€™t work</h2>
<p>This is a wrong pattern to meet our expectation.
The solders in the list will <strong>only</strong> be destroyed and removed from the list
when the whole program is ended.
The solders are only removed from the list in its deconstructor.
However, whenever the <code class="highlighter-rouge">RefPtr&lt;Solder&gt; s(new Solder())</code>
is deconstructed (by <code class="highlighter-rouge">~RefPtr</code>) in the main function,
the <code class="highlighter-rouge">~Solder()</code> wonâ€™t be called
since there must be one another <code class="highlighter-rouge">RefPtr&lt;Solder&gt; some</code> in the list
referencing the solder.
Thus, the <code class="highlighter-rouge">~Solder()</code> is only be called
when the element in the list is decontructed.</p>

<h2 id="sample-code">Sample code</h2>
<noscript><pre>// $ g++ test.cpp --std=c++11
#include &quot;RefPtr.h&quot;
#include &lt;algorithm&gt;  // std::remove
#include &lt;cassert&gt;    // assert
#include &lt;iostream&gt;   // std::cout, std::endl
#include &lt;vector&gt;     // std::vector

///////////////////////////////////////////////////////////////////////////////
// Solder Interface
class Solder: public ReferenceCount
{
public:
  Solder(int n);
  ~Solder();
  int CountOff(); // Report the number.

private:
  int number;
};

///////////////////////////////////////////////////////////////////////////////
// Squad Interface
class Squad
{
public:
  static void Add(Solder* s);
  static void Remove(Solder* s);
  static void CountOff(); // Call all of the solders.
  static unsigned int Size();
private:
  static std::vector&lt;RefPtr&lt;Solder&gt;&gt; members;
};

///////////////////////////////////////////////////////////////////////////////
// Solder Implementation
Solder::Solder(int n)
  : number(n)
{
  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is created.&quot; &lt;&lt; std::endl;
  Squad::Add(this);
}

Solder::~Solder()
{
  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is destroyed.&quot; &lt;&lt; std::endl;
  Squad::Remove(this);
}

int
Solder::CountOff()
{
  return number;
}

///////////////////////////////////////////////////////////////////////////////
// Squad Implementation
std::vector&lt;RefPtr&lt;Solder&gt;&gt; Squad::members;

/* static */ void
Squad::Add(Solder* s)
{
  std::cout &lt;&lt; &quot;Add Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; to members.&quot; &lt;&lt; std::endl;
  members.push_back(s);
}

/* static */ void
Squad::Remove(Solder* s)
{
  std::cout &lt;&lt; &quot;Remove Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; from members.&quot; &lt;&lt; std::endl;
  members.erase(std::remove(members.begin(), members.end(), s), members.end());
}

/* static */ void
Squad::CountOff()
{
  for (auto&amp; m: members) {
    std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; m-&gt;CountOff() &lt;&lt; &quot; is here!&quot; &lt;&lt; std::endl;
  }
}

/* static */ unsigned int
Squad::Size()
{
  return members.size();
}

///////////////////////////////////////////////////////////////////////////////
// *** Wrong example to use RefPtr ***
//   We will put the Solder instances into the squad when they are created,
//   and remove the instances from the squad when they are destroyed.
//   We expect the following behavior.
//
//   List&lt;RefPtr&lt;Solder&gt;&gt; l;
//   {
//     RefPtr&lt;Solder&gt; s(new Solder(99)); // Put s into the list
//   }
//   // s is destroyed and removed from the list, so list is empty now.
int main()
{
  std::cout &lt;&lt; &quot;Creating a solder and put it into squad.&quot; &lt;&lt; std::endl;

  {
    RefPtr&lt;Solder&gt; s(new Solder(1));
    Squad::CountOff();
    // There should be one solder in the squad now.
    assert(Squad::Size() == 1 &amp;&amp; s-&gt;GetCount() == 2);
  }

  std::cout &lt;&lt; &quot;Solder should be removed from squad and destroyed.&quot; &lt;&lt; std::endl;
  // In our mind, we expect there is no solder in the squad now.
  assert(Squad::Size() == 0); // Comment this to check the below one.
  // But it&#39;s wrong. The correct status of the memebers is:
  // assert(Squad::Size() == 1);

  // In our expectation, we expect the solder 1 will be destroyed and removed
  // from the sqaud when the program is running out of &#39;}&#39; above.
  // At that time, the ~RefPtr() will be called and check whether we need to
  // release the solder 1. However, since we still have a reference to solder 1
  // in the members list of the squal, the reference count to solder 1 is not 0.
  // Therefore, it won&#39;t be removed!

  // Actually,
  // ------------------------------------
  // List&lt;RefPtr&lt;Solder&gt;&gt; list
  // Solder()
  // {
  //   Add &#39;this&#39; into the list
  // }
  // ~Solder()
  // {
  //   Remove &#39;this&#39; from the list
  // }
  // ------------------------------------
  // is a wrong pattern to meet our expectation.
  // The solders in the list will only be destroyed and removed from the list
  // when the whole program is ended. The solders are only removed from
  // the list in its deconstructor. However, whenever the
  // RefPtr&lt;Solder&gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,
  // the ~Solder() won&#39;t be called since there must be one another
  // RefPtr&lt;Solder&gt; in the list referencing the solder.
  // Thus, the ~Solder() is only be called when the element in the list is
  // decontructed.

  return 0;
}</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1.js?file=misuse.cpp"> </script>

:ET