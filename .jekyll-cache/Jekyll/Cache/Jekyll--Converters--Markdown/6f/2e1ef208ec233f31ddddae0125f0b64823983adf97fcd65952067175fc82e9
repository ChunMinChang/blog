I"±0<h1 id="how-to-simulate-a-c-class-in-c">How to simulate a C++ class in C</h1>

<p>After learning <em>C++</em>, I am curious about
how could I bring the <em>object-oriented</em> style to <em>C</em>.
Could we simulate a <em>C++</em> <code class="highlighter-rouge">class</code> by <code class="highlighter-rouge">struct</code> in C?</p>

<p>To find the answer,
I implement a simple <em>linked list</em> with <em>object-oriented</em> style in plain <em>C</em>.
The key is to use <em>function pointer</em> in <code class="highlighter-rouge">struct</code> to
simulate a <em>C++</em> member function.
you can find my code <a href="https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e" title="Class in C for linked-list implementation">here</a></p>

<p>To compare, I also implement a <a href="https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473" title="Linked-list in C++"><em>linked list</em> in <em>C++</em></a>.</p>

<h2 id="class-in-c">Class in C</h2>
<noscript><pre>#ifndef LIST_H
#define LIST_H

#include &lt;stddef.h&gt; // for size_t

struct Node {
  void* data; // Any data type can be stored in this node
  struct Node* next;
};

typedef void (*Callback)(struct Node* node);
struct List {
  struct Node* head;
  struct Node* cursor;

  void (* const destroy)(struct List* self);
  void (* const append)(struct List* self, void* data, size_t size);
  void (* const prepend)(struct List* self, void* data, size_t size);
  void (* const traverse)(struct List* self, Callback func);
};

extern const struct ListClass {
  struct List (*new)();
} /*ListProxy*/ List;

#endif // LIST_H</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=list.h"> </script>

<noscript><pre>#include &quot;list.h&quot;
#include &lt;assert.h&gt; // for assert
// #include &lt;stddef.h&gt; // for NULL, size_t, they are already included in list.h
#include &lt;stdlib.h&gt; // for calloc, free
#include &lt;string.h&gt; // for memcpy

// Using &quot;static&quot; prevents these functions from being exposed outside.

static void
destroy(struct List* self)
{
  for (struct Node* cur = self-&gt;head ; cur != NULL ;) {
    struct Node* next = cur-&gt;next;
    free(cur-&gt;data);
    free(cur);
    cur = next;
  }
  self-&gt;head = self-&gt;cursor = NULL;
}

static void
append(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&gt;next = NULL;
  n-&gt;data = calloc(1, size);
  assert(n-&gt;data);
  memcpy(n-&gt;data, data, size);

  if (!self-&gt;head) { // The list is empty.
    assert(!self-&gt;cursor); // cursor = head = NULL now.
    self-&gt;head = n;
  } else {
    assert(self-&gt;cursor);
    self-&gt;cursor-&gt;next = n;
  }
  self-&gt;cursor = n;
}

static void
prepend(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&gt;next = self-&gt;head;
  n-&gt;data = calloc(1, size);
  assert(n-&gt;data);
  memcpy(n-&gt;data, data, size);

  self-&gt;head = n;
  if(!self-&gt;cursor) { // The list is empty before inserting value.
    self-&gt;cursor = n;
  }
}

static void
traverse(struct List* self, Callback func)
{
  for (struct Node* cur = self-&gt;head ; cur != NULL ; cur = cur-&gt;next) {
    func(cur);
  }
}

static struct List
new()
{
  return (struct List) {
    .head = NULL,
    .cursor = NULL,
    .destroy = (void*) &amp;destroy,
    .append = (void*) &amp;append,
    .prepend = (void*) &amp;prepend,
    .traverse = (void*) &amp;traverse
  };
}

const struct ListClass /*ListProxy*/ List = {
  .new = &amp;new,
};</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=list.c"> </script>

<noscript><pre>#include &quot;list.h&quot;
#include &lt;stdbool.h&gt;  // for bool
#include &lt;stdio.h&gt;    // for printf

#define VA_ARGS(...) , ##__VA_ARGS__
#define CALL(obj, method, ...) ((obj).method(&amp;(obj) VA_ARGS(__VA_ARGS__)))

void print(struct Node* node, bool is_float)
{
  if (!node) {
    return;
  }
  is_float ? printf(&quot;%f&quot;, *(float*)node-&gt;data) :
             printf(&quot;%d&quot;, *(int*)node-&gt;data);
  printf(&quot;%s&quot;, (node-&gt;next) ? &quot;-&gt;&quot; : &quot;\n&quot;);
}

void print_int(struct Node* node)
{
  print(node, false);
}

void print_float(struct Node* node)
{
  print(node, true);
}

int main()
{
  int data_int[6] = { 11, 22, 33, 44, 55, 66 };
  float data_float[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  struct List l = /*ListProxy*/List.new();
  l.prepend(&amp;l, &amp;data_int[0], sizeof(data_int[0]));
  l.append(&amp;l, &amp;data_int[1], sizeof(data_int[1]));
  l.append(&amp;l, &amp;data_int[2], sizeof(data_int[2]));
  l.prepend(&amp;l, &amp;data_int[3], sizeof(data_int[3]));
  l.append(&amp;l, &amp;data_int[4], sizeof(data_int[4]));
  l.prepend(&amp;l, &amp;data_int[5], sizeof(data_int[5]));
  l.traverse(&amp;l, print_int);
  l.destroy(&amp;l);

  CALL(l, prepend,  &amp;data_float[0], sizeof(data_float[0]));
  CALL(l, append,   &amp;data_float[1], sizeof(data_float[1]));
  CALL(l, append,   &amp;data_float[2], sizeof(data_float[2]));
  CALL(l, prepend,  &amp;data_float[3], sizeof(data_float[3]));
  CALL(l, append,   &amp;data_float[4], sizeof(data_float[4]));
  CALL(l, prepend,  &amp;data_float[5], sizeof(data_float[5]));
  CALL(l, traverse, print_float);
  CALL(l, destroy);

  return 0;
}</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=test.c"> </script>

<h2 id="c-version">C++ version</h2>
<noscript><pre>#ifndef LIST_H
#define LIST_H

#include &lt;assert.h&gt; // for assert
#include &lt;memory&gt;   // for std::unique_ptr

template&lt;typename T&gt;
class List
{
public:
  struct Node // All it&#39;s members are public by default.
  {
    Node(T aData, Node* aNext)
      : mData(aData)
      , mNext(aNext)
    {}

    ~Node() {}

    T mData;
    Node* mNext;
  };

  List();
  ~List();

  void Append(T aData);
  void Prepend(T aData);

  typedef void (*Callback)(Node* aNode);
  void Traverse(Callback aCallback);

private:
  // No need to use smart pointer in low-level data structure.
  // It&#39;s more efficient for managing memory on our own.
  Node* mCursor;
  Node* mHead;
};

// nullptr is introduced in C++11.
template&lt;typename T&gt;
List&lt;T&gt;::List()
  : mCursor(nullptr)
  , mHead(nullptr)
{
}

template&lt;typename T&gt;
List&lt;T&gt;::~List()
{
  for (mCursor = mHead ; mCursor != nullptr ;) {
    std::unique_ptr&lt;Node&gt; autoRelease(mCursor);
    // Update mCursor here instead of afterthought in for-loop,
    // in case mCursor is already released.
    mCursor = mCursor-&gt;mNext;
    // The memory chuck pointed by old mCursor will be destroyed
    // upon leaving the &#39;}&#39;.
  }
}

template&lt;typename T&gt;
void
List&lt;T&gt;::Append(T aData)
{
  Node* n = new Node(aData, nullptr);
  if (!mHead) { // the list is empty.
    assert(!mCursor);
    mHead = n;
  } else {
    assert(mCursor);
    mCursor-&gt;mNext = n;
  }
  mCursor = n;
}

template&lt;typename T&gt;
void
List&lt;T&gt;::Prepend(T aData)
{
  Node* n = new Node(aData, mHead);
  mHead = n;
  if (!mCursor) { // The list is empty before inserting value.
    mCursor = n;
  }
}

template&lt;typename T&gt;
void
List&lt;T&gt;::Traverse(Callback aCallback)
{
  for (Node* cur = mHead ; cur != nullptr ; cur = cur-&gt;mNext) {
    aCallback(cur);
  }
}

#endif // LIST_H</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473.js?file=list.h"> </script>

<noscript><pre>#include &quot;list.h&quot;
#include &lt;iostream&gt;

template&lt;typename T&gt;
void Print(T aData, bool aBreakline)
{
  std::cout &lt;&lt; aData &lt;&lt; ((aBreakline)? &quot;-&gt;&quot; : &quot;\n&quot;);
}

void PrintInt(List&lt;int&gt;::Node* aNode)
{
  Print(aNode-&gt;mData, aNode-&gt;mNext);
}

void PrintFloat(List&lt;float&gt;::Node* aNode)
{
  Print(aNode-&gt;mData, aNode-&gt;mNext);
}

int main()
{
  int dataInt[6] = { 11, 22, 33, 44, 55, 66 };
  float dataFloat[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  List&lt;int&gt; li;
  li.Prepend(dataInt[0]);
  li.Append(dataInt[1]);
  li.Append(dataInt[2]);
  li.Prepend(dataInt[3]);
  li.Append(dataInt[4]);
  li.Prepend(dataInt[5]);
  li.Traverse(PrintInt);

  List&lt;float&gt; lf;
  lf.Prepend(dataFloat[0]);
  lf.Append(dataFloat[1]);
  lf.Append(dataFloat[2]);
  lf.Prepend(dataFloat[3]);
  lf.Append(dataFloat[4]);
  lf.Prepend(dataFloat[5]);
  lf.Traverse(PrintFloat);

  return 0;
}</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473.js?file=test.cpp"> </script>

<h2 id="comparison">Comparison</h2>
<ul>
  <li>The C version needs to call <code class="highlighter-rouge">destroy</code> explicitly,
while the C++ version will automatically run deconstructor <code class="highlighter-rouge">~List()</code>
to release the memory, or use smart pointers
like <code class="highlighter-rouge">unique_ptr</code> to help memory management.
    <ul>
      <li>To release <code class="highlighter-rouge">Foo* n = new Foo(...)</code>, we need to use <code class="highlighter-rouge">delete n</code>
instead of <code class="highlighter-rouge">n-&gt;~Foo()</code>
        <ul>
          <li>Calling a destructor releases the resources owned by the object,
but it does not release the memory allocated to the object itself.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>We need to pass self pointer to the <code class="highlighter-rouge">List</code> structure
for calling functions to access list‚Äôs data,
while we don‚Äôt need to do that in C++ version
because class object can get all data inside itself in its implementation.</li>
  <li>To allow storing different data type in the list,
the C++ version use <code class="highlighter-rouge">template</code> instead of <code class="highlighter-rouge">void*</code> in the C version.
    <ul>
      <li>The <code class="highlighter-rouge">void* data</code> with <code class="highlighter-rouge">size_t size</code>
is regarded as memory chunk beyond types,
pointed by <code class="highlighter-rouge">data</code> with <code class="highlighter-rouge">size</code> bytes,
so we can store different types data in <strong>runtime</strong>.</li>
      <li>While <code class="highlighter-rouge">template&lt;typename T&gt;</code> let us to declare a variable
with type <code class="highlighter-rouge">T</code> in <strong>compile time</strong>,
so <em>gcc/g++</em> can help us for debugging if there is any error.
        <ul>
          <li>function with <code class="highlighter-rouge">template</code> cannot be separated in <code class="highlighter-rouge">.cpp</code> and <code class="highlighter-rouge">.h</code>
because compiler needs to see both the template definition
and the specific types/whatever used to <strong>fill in</strong> the template.
Please read <a href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl" title="Why can‚Äôt I separate the definition of my templates class from its declaration and put it inside a .cpp file">this</a> for more details.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Replace <code class="highlighter-rouge">NULL</code> with <code class="highlighter-rouge">nullptr</code>
    <ul>
      <li><code class="highlighter-rouge">nullptr</code> is always a pointer type. <code class="highlighter-rouge">NULL</code>(0) could cause ambiguity
when we have functions: <code class="highlighter-rouge">void f(int)</code>, <code class="highlighter-rouge">void f(foo *)</code>,
and we call <code class="highlighter-rouge">f(NULL)</code>.</li>
    </ul>
  </li>
</ul>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://hackfoldr.org/dykc/https%253A%252F%252Fhackmd.io%252Fs%252FHJLyQaQMl" title="‰Ω†ÊâÄ‰∏çÁü•ÈÅìÁöÑ C Ë™ûË®ÄÔºöÁâ©‰ª∂Â∞éÂêëÁ®ãÂºèË®≠Ë®àÁØáÔºàÂÖ±Á≠ÜÔºâ">‰Ω†ÊâÄ‰∏çÁü•ÈÅìÁöÑ C Ë™ûË®ÄÔºöÁâ©‰ª∂Â∞éÂêëÁ®ãÂºèË®≠Ë®àÁØáÔºàÂÖ±Á≠ÜÔºâ</a></li>
  <li><a href="https://www.youtube.com/watch?v=GON5vID8srE" title="‰Ω†ÊâÄ‰∏çÁü•ÈÅìÁöÑ C Ë™ûË®ÄÔºöÁâ©‰ª∂Â∞éÂêëÁ®ãÂºèË®≠Ë®àÁØá (‰∏ä)">‰Ω†ÊâÄ‰∏çÁü•ÈÅìÁöÑ C Ë™ûË®ÄÔºöÁâ©‰ª∂Â∞éÂêëÁ®ãÂºèË®≠Ë®àÁØá video (‰∏ä)</a></li>
  <li><a href="https://www.youtube.com/watch?v=k0k9ZK64g1s" title="‰Ω†ÊâÄ‰∏çÁü•ÈÅìÁöÑ C Ë™ûË®ÄÔºöÁâ©‰ª∂Â∞éÂêëÁ®ãÂºèË®≠Ë®àÁØá (‰∏ã)">‰Ω†ÊâÄ‰∏çÁü•ÈÅìÁöÑ C Ë™ûË®ÄÔºöÁâ©‰ª∂Â∞éÂêëÁ®ãÂºèË®≠Ë®àÁØá video (‰∏ã)</a></li>
</ul>

:ET