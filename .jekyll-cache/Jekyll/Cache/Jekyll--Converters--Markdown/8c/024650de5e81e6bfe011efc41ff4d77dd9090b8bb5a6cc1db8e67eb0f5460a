I"O<p>In <!-- [previous post](/post/matrix-difference-equation-for-fibonacci-sequence) -->
<a href="https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence">previous post</a>,
we learned how to calculate <em>Fibonacci</em> numbers by <em>Fast Doubling</em> in math.
Today, we will apply it in programming and optimize it step by step.</p>

<h2 id="fast-doubling">Fast Doubling</h2>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
F_{2n+1} &= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]></script>

<p>Itâ€™s natural to write a recursive implementation by the above definition.
In the following steps, we will implement recursive versions first,
then try converting it into iterative versions.</p>

<h3 id="recursive-top-down-approach">Recursive (Top-down) Approach</h3>

<p>Given a <script type="math/tex">n</script>, we could calculate <em>Fibonacci</em> numbers <script type="math/tex">F_n</script> by:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n is odd: F(n) = F(((n-1) / 2) + 1)^2 + F((n-1) / 2)^2</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// n is even: F(n) = F(n/2) * [ 2 * F(n/2 + 1) - F(n/2) ]</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>From above code, we can know that the code stack will be entered again and again,
so we need to define when to stop it.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0.</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = F(2) = 0.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// Keep calling itself recursively to get the answer.</span>
  <span class="c1">// Put the main body here.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We only calculate <em>Fibonacci</em> numbers from <script type="math/tex">0</script>,
so we need to stop when <script type="math/tex">n = 0</script>.
The <code class="highlighter-rouge">fib(0)</code> may be asked from calculating <code class="highlighter-rouge">fib(1) = fib(0)*fib(0) + fib(1)*fib(1)</code>
(by setting <script type="math/tex">n = 0</script> to <script type="math/tex">F_{2n+1} = {F_{n+1}}^2 + {F_n}^2</script>,
so we also need to define <code class="highlighter-rouge">fib(1) = 1</code> directly,
or it will cause an endless recursion.</p>

<p>Similarly, the <code class="highlighter-rouge">fib(1)</code> may be asked from calculating <code class="highlighter-rouge">fib(2) = fib(1) * [2 * fib(2) - fib(1)]</code>
(by setting <script type="math/tex">n = 1</script> to <script type="math/tex">F_{2n} = F_n \cdot (2 \cdot F_{n+1} - F_n)</script>,
so <code class="highlighter-rouge">fib(2) = 1</code> also needs to be returned directly.</p>

<p>As the result, the code can be written into:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Fast doubling: O(log(n))</span>
<span class="c1">//   Using 2n to the Fibonacci matrix above, we can derive that:</span>
<span class="c1">//     F(2n)   = F(n) * [ 2 * F(n+1) â€“ F(n) ]</span>
<span class="c1">//     F(2n+1) = F(n+1)^2 + F(n)^2</span>
<span class="c1">//     (and F(2n-1) = F(n)^2 + F(n-1)^2)</span>
<span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = F(2) = 0.</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, let we look where we could improve from this simple version.
We use duplicated <code class="highlighter-rouge">fib(k)</code> and <code class="highlighter-rouge">fib(k + 1)</code> to calculate <code class="highlighter-rouge">fib(n)</code>.
That is, we will have two duplicated recursive processes to do the same work.
It would be a waste of the time.</p>

<p>Another trick is that we could use <code class="highlighter-rouge">n = n / 2</code> in both cases
(<script type="math/tex">n</script> is odd or even) since the result of <code class="highlighter-rouge">n = (n - 1) / 2</code> is same
as <code class="highlighter-rouge">n = n / 2</code> in <em>C/C++</em>â€™s world if <code class="highlighter-rouge">n</code> is an <strong>odd</strong> integer.</p>

<p>Thus, we can rewrite the code into:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// When n = 2: k = 1 and we want to use F(k+1) to calculate F(2k),</span>
  <span class="c1">// However, F(2k) = F(k+1) = F(2) is unknown then.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0, F(1) = F(2) = 1.</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// k = n/2 if n is even. k = (n-1)/2 if n is odd.</span>
  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fib1</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fib1</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="memoization">Memoization</h4>

<p>Do we save all duplicated task now? No.
Suppose we need to find <script type="math/tex">F_6</script>, then we need to get <script type="math/tex">F_3, F_4</script> â€¦.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{matrix}
 & & & & & 6 & & & & & & & \\
 & & & & \diagup & & \diagdown & & & & & & \\
 & & & \diagup & & & & \diagdown & & & & & \\
 & & 3 & & & & & & 4 & & & & \\
 & \diagup & & \diagdown & & & & \diagup & & \diagdown & & & \\
 1 & & & & 2 & & 2 & & & & 3 & & \\
 & & & & & & & & & \diagup & & \diagdown & \\
 & & & & & & & & 1 & & & & 2
\end{matrix} %]]></script>

<p>Itâ€™s clear that we have a duplicated <script type="math/tex">F_1, F_2, F_3</script> on above figure.
<script type="math/tex">F_1, F_2</script> can return value directly, while <script type="math/tex">F_3</script> can not.
Therefore, the sub-tree(sub-process) whose root is <script type="math/tex">F_3</script> will be executed twice.</p>

<p>The larger the <script type="math/tex">n</script> is, the more duplicated sub-process will be executed.
To avoid the waste, we can add an <em>array</em> to save all the calculated value.
We check the <em>array</em> first when <script type="math/tex">F_n</script> is calculated.
If there is already a saved value in the <em>array</em> at <script type="math/tex">n</script>,
then we can use it directly.
Otherwise, it will be calculated as usual.
Itâ€™s called <em>memoization</em>.
We will save <script type="math/tex">F_n</script> as the <script type="math/tex">n</script> element in the <em>array</em>.</p>

<p>In this case, the <script type="math/tex">F_n</script> is not calculated successively.
For example, to get <script type="math/tex">F_6</script>, we only need <script type="math/tex">F_4, F_3, F_2, F_1, F_0</script>.
We donâ€™t need <script type="math/tex">F_5</script>, so there is no value at the <script type="math/tex">5</script> element in the <em>array</em>.
You can use <em>hash map</em> instead of <em>array</em> to avoid the waste of memory.
However, retrieving data from <em>array</em> is faster than <em>hash map</em>,
so we apply <em>array</em> in our sample code:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="c1">// 4 is not a fibonacci number, so using it as initialized value.</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">INIT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">// In this case, F is not calculated successively. For example,</span>
<span class="c1">// To get F(6), we only need F(4), F(3), F(2), F(1), F(0) (no F(5)),</span>
<span class="c1">// so the other elements in F is still INIT.</span>
<span class="c1">// Another way is to use hash map(std::unordered_map), however,</span>
<span class="c1">// it will be slower.</span>
<span class="kt">uint64_t</span> <span class="n">MEM</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INIT</span> <span class="p">};</span>
<span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INIT</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// F(0) = 0.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// F(1) = F(2) = 1.</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// k = n/2 if n is even. k = (n-1)/2 if n is odd.</span>
  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2, if n is odd.</span>
  <span class="c1">//    F(n) = F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ], if n is even.</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">:</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="state-vector">State vector</h4>
<p>Although we can speed up the calculating by applying <em>memoization</em> above,
the memory consumption with this approach grows with <script type="math/tex">n</script>.
Is it possible to use a fixed memory no matter how big <script type="math/tex">n</script> is?
The answer is yes. Actually, we could just use a two-elements array to do it.</p>

<p>From the formula, we can calculate <script type="math/tex">[F_{2n}, F_{2n+1}]</script> from <script type="math/tex">[F_n, F_{n+1}]</script>.
For example, to calculate <script type="math/tex">F_{10}</script>, we need <script type="math/tex">F_5, F_6</script>.
To calculate <script type="math/tex">F_5</script>, we need <script type="math/tex">F_2, F_3</script>.
To calculate <script type="math/tex">F_2</script>, we need <script type="math/tex">F_1, F_0</script>.
To calculate <script type="math/tex">F_1</script>, we need <script type="math/tex">F_0, F_1</script>
(so we need to stop here since <script type="math/tex">F_1</script> is the dead end).</p>

<p>However, how do we get <script type="math/tex">F_6</script>
when we only have <script type="math/tex">F_2, F_3</script> to calculate <script type="math/tex">F_5</script>?
Or how to get <script type="math/tex">F_3</script>
when we only have <script type="math/tex">F_0, F_1</script> to calculate <script type="math/tex">F_2</script> â€¦?</p>

<p>By applying <script type="math/tex">n = 2</script> to formula, we can use <script type="math/tex">F_2, F_3</script> to get <script type="math/tex">F_4, F_5</script>.
Then we can get <script type="math/tex">F_6 = F_4 + F_5</script>.</p>

<p>Thus, we are able to get <script type="math/tex">F_{10}</script> by the following procedure:</p>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    F_0 \\
    F_1
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}</script>

<p>Thus, we could keep using two-elements array
for <script type="math/tex">\begin{bmatrix} F_n \\ F_{n+1} \end{bmatrix}</script>
to compute what we want and update it step by step.</p>

<p>But how to determine the state we should update from <script type="math/tex">[F_n, F_{n + 1}]</script>,
<script type="math/tex">[F_{2n}, F_{2n + 1}]</script> or <script type="math/tex">[F_{2n + 1}, F_{2n + 2}]</script> ?</p>

<p>Itâ€™s simple. If <script type="math/tex">n</script> is even, we need to find <script type="math/tex">F_k</script>
, where <script type="math/tex">k = \frac{n}{2}</script> since <script type="math/tex">n = 2x</script>.
Then we can use <script type="math/tex">[F_k, F_{k+1}] = [F_{n/2}, F_{n/2 + 1}]</script>
to calculate <script type="math/tex">[F_{2k}, F_{2k + 1}] = [F_n, F_{n + 1}]</script>.</p>

<p>Otherwise, if <script type="math/tex">n</script> is odd, we need to find <script type="math/tex">F_k</script>
, where <script type="math/tex">k = \frac{n-1}{2}</script> since <script type="math/tex">n = 2k + 1</script>.
Then we can use <script type="math/tex">[F_k, F_{k+1}] = [F_{(n-1)/2}, F_{(n-1)/2 + 1}]</script>
to calculate <script type="math/tex">[F_{2k}, F_{2k+1}] = [F_{n-1}, F_n]</script>
and then get <script type="math/tex">[F_n, F_{n + 1}]</script> by <script type="math/tex">[F_n, F_{n-1} + F_n]</script>.</p>

<p>In summary, the procedure can be organized as follows:</p>

<table>
  <thead>
    <tr>
      <th><script type="math/tex">k_i</script></th>
      <th><script type="math/tex">k_1</script></th>
      <th><script type="math/tex">k_2</script></th>
      <th><script type="math/tex">k_3</script></th>
      <th><script type="math/tex">k_4</script></th>
      <th><script type="math/tex">k_5</script></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><script type="math/tex">n(= k_i)</script></td>
      <td>10</td>
      <td>5</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td><script type="math/tex">n</script> is odd</td>
      <td>Â </td>
      <td>v</td>
      <td>Â </td>
      <td>v</td>
      <td>Â </td>
    </tr>
    <tr>
      <td><script type="math/tex">F_{2k_{i+1}}</script></td>
      <td>Â </td>
      <td><script type="math/tex">F_4</script></td>
      <td>Â </td>
      <td><script type="math/tex">F_0</script></td>
      <td>Â </td>
    </tr>
    <tr>
      <td><script type="math/tex">F_n</script></td>
      <td><script type="math/tex">F_{10}</script></td>
      <td><script type="math/tex">F_5</script></td>
      <td><script type="math/tex">F_2</script></td>
      <td><script type="math/tex">F_1</script></td>
      <td><script type="math/tex">F_0</script></td>
    </tr>
    <tr>
      <td><script type="math/tex">F_{n+1}</script></td>
      <td>Â </td>
      <td><script type="math/tex">F_6</script></td>
      <td><script type="math/tex">F_3</script></td>
      <td><script type="math/tex">F_2</script></td>
      <td><script type="math/tex">F_1</script></td>
    </tr>
  </tbody>
</table>

<p>The last two rows, <script type="math/tex">F_n, F_{n+1}(= F_{k_i}, F_{k_i+1})</script>, are the state vector
that contains our answer.</p>

<p>The first row <script type="math/tex">n</script>, is the index of the first element
of the state vector <script type="math/tex">F_n</script>.
The second row indicates that whether <script type="math/tex">n</script> is odd or not.
If <script type="math/tex">n(= k_i)</script> is odd(recall what we discuss above),
then we need to update state from from <script type="math/tex">[F_{k_{i+1}}, F_{k_{i+1}+1}]</script>
to <script type="math/tex">[F_{2k_i + 1}, F_{2k_i + 2}]</script> since <script type="math/tex">k_{i+1} = \frac{k_i - 1}{2}</script>.
The third row is used to record if we need get <script type="math/tex">[F_{2k_i + 1}, F_{2k_i + 2}]</script>
from <script type="math/tex">[F_{2k_i}, F_{2k_i + 1}]</script>.
Otherwise, if <script type="math/tex">n(= k_i)</script> is even, updating state
from <script type="math/tex">[F_{k_{i+1}}, F_{k_{i+1}+1}]</script> to <script type="math/tex">[F_{2k_i}, F_{2k_i + 1}]</script> directly.</p>

<p>From the top-down perspective, to get <script type="math/tex">F_{10}</script>, we need <script type="math/tex">F_5, F_6</script>.
To get <script type="math/tex">F_5, F_6</script>, we need <script type="math/tex">F_2, F_3</script>.
To get <script type="math/tex">F_2, F_3</script>, we need <script type="math/tex">F_1, F_2</script>.
To get <script type="math/tex">F_1, F_2</script>, we need <script type="math/tex">F_0, F_1</script>.
We will demonstrate how we do it recursively below.</p>

<p>From the bottom-up perspective, we can use <script type="math/tex">F_0, F_1</script>
to get <script type="math/tex">F_0, F_1, F_2</script>,
then <script type="math/tex">F_1, F_2</script> to get <script type="math/tex">F_2, F_3</script>,
<script type="math/tex">F_2, F_3</script> to get <script type="math/tex">F_4, F_5, F_6</script>,
<script type="math/tex">F_5, F_6</script> to get <script type="math/tex">F_10</script>.
We will demonstrate how we do it in iterative section.</p>

<p>The recursive approach is easier to understand.
By what we summarized above, the simplest implementation will be:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Set f[0], f[1] to F(n), F(n+1).</span>
<span class="kt">void</span> <span class="nf">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">f</span><span class="p">[]);</span>

<span class="c1">// 4 is not a fibonacci number, so using it as initialized value.</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">INIT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">INIT</span><span class="p">,</span> <span class="n">INIT</span> <span class="p">};</span>
  <span class="n">fib_helper</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">f</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">fib_helper</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>            <span class="c1">// F(k) = F((n-1)/2)</span>
    <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>            <span class="c1">// F(k + 1) = F((n- )/2 + 1)</span>
    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(n-1) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]</span>
    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(n) = F(2k + 1) = F(k)^2 + F(k+1)^2</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>                     <span class="c1">// F(n)</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>                 <span class="c1">// F(n+1) = F(n-1) + F(n)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">fib_helper</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>            <span class="c1">// F(k) = F(n/2)</span>
    <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>            <span class="c1">// F(k + 1) = F(n/2 + 1)</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>       <span class="c1">// F(n) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>         <span class="c1">// F(n + 1) = F(2k + 1) = F(k)^2 + F(k+1)^2</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above <code class="highlighter-rouge">fib_helper</code> is quite tedious,
we can be simplify it into:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Set f[0], f[1] to F(n), F(n+1).</span>
<span class="kt">void</span> <span class="nf">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">f</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">fib_helper</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="c1">// k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.</span>
  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// F(k)</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// F(k+1)</span>

  <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
  <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k+1)^2 + F(k)^2</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// F(n) = F(2k+1).</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// F(n+1) = F(n-1) + F(n) = F(2k) + F(2k+1).</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        <span class="c1">// k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>     <span class="c1">// F(n) = F(2k).</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// F(n+1) = F(2k).</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You could also replace <em>array</em> with <em>std::vector</em>,
so the code will looks more elegant.
However, it will be slower than using <em>array</em> directly.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Return vector [ F(n), F(n+1) ].</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">fib_helper</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// [F(0), F(1)] = [0 , 1]</span>
    <span class="k">return</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">fib_helper</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
  <span class="c1">// k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.</span>
  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// F(k)</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// F(k+1)</span>

  <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
  <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k+1)^2 + F(k)^2</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).</span>
    <span class="c1">// [F(n), F(n+1)] = [F(2k+1), F(2k+2)] = [F(2k+1), F(2k) + F(2k+1)]</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span> <span class="p">};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).</span>
    <span class="c1">// [F(n), F(n+1)] = [F(2k), F(2k+1)].</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="iterative-bottom-up-approach">Iterative (Bottom-up) Approach</h3>

<p>The recursive approach is implemented from the top-down perspective.
We could also do it in bottom-up way.</p>

<p>To convert the recursive steps into an iterative loop,
we need to find the <em>initialized state</em> and the <em>stop condition</em>.
In the recursive approach, no matter what <script type="math/tex">n</script> is, the final state vector
(when the recursive steps stops) is always <script type="math/tex">[F_0, F_1]</script>,
, and it must be called from calculating the state <script type="math/tex"></script>[F_1, F_2]<script type="math/tex"></script>.
Recall how we calculate <script type="math/tex">F_{10}</script>:</p>

<ul>
  <li>We recursively calculate <script type="math/tex">n \leftarrow \lfloor \frac{n}{2} \rfloor</script> from <script type="math/tex">n = 10</script>,
    <ul>
      <li>then <script type="math/tex">n = \lfloor \frac{10}{2} \rfloor = 5</script>,</li>
      <li>then <script type="math/tex">n = \lfloor \frac{5}{2} \rfloor = 2</script>,</li>
      <li>then <script type="math/tex">n = \lfloor \frac{2}{2} \rfloor = 1</script>,</li>
      <li>then stop recursive steps when <script type="math/tex">n = \lfloor \frac{1}{2} \rfloor = 0</script>.</li>
    </ul>
  </li>
  <li>Next, we get the state vector <script type="math/tex">[F_n, F_{n+1}]</script> for <script type="math/tex">n = 0</script>,
    <ul>
      <li>then return on the same track with opposite direction
to calculate the state vector for <script type="math/tex">n = 1</script>,</li>
      <li>then for <script type="math/tex">n = 2</script></li>
      <li>then for <script type="math/tex">n = 5</script>,</li>
      <li>and finally get the answer for <script type="math/tex">n = 10</script>.</li>
    </ul>
  </li>
</ul>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    F_0 \\
    F_1
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}</script>

<p>The recursive steps are used to get the track
from <script type="math/tex">n = 0</script> to <script type="math/tex">1, 2, 5, 10</script>,
then calculate <script type="math/tex">[F_n, F_{n+1}]</script> for each <script type="math/tex">n</script>.</p>

<p>To remove the recursive steps, we need to have a way to compute the track.
We can use a <em>stack</em> to track the change for <script type="math/tex">n</script>, starting push <script type="math/tex">n</script>
from <script type="math/tex">n = 10</script>, then <script type="math/tex">n = 5</script>, <script type="math/tex">n = 2</script>, <script type="math/tex">n = 1</script>, <script type="math/tex">n = 0</script>,
then the track can be get from popping them from <script type="math/tex">0</script> to <script type="math/tex">10</script>.</p>

<p>Thus, the <em>initialized state</em> is <script type="math/tex">n = 0</script>
and the <em>stop condition</em> is to check whether the stack is empty.</p>

<p>(Using <em>stack</em> is one common approach to
convert recursive code into the iterative one.)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// To compute the track from n, n/2, ..., 1, 0.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// n = floor(n/2)</span>
  <span class="p">}</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// n = 0 now.</span>

  <span class="kt">uint64_t</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// F(n)</span>
  <span class="kt">uint64_t</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// F(n+1)</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Initializing a, b.</span>
      <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0</span>
      <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.</span>
    <span class="c1">// k = m/2, if m is even. k = (m-1)/2, if m is odd.</span>
    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// m = 2k+1:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>      <span class="c1">//  F(m) = F(2k+1)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>  <span class="c1">//  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>      <span class="c1">// m = 2k:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>      <span class="c1">//  F(m) = F(2k)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>      <span class="c1">//  F(m+1) = F(2k+1)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above code is a bit ugly for simulating the recursive steps like:
<script type="math/tex">\require{AMScd}
\underbrace{
\begin{CD}
\left(
  \begin{array}{c}
    \boldsymbol{a} = F_0 \\
    \boldsymbol{b} = F_1
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}
}_{loop}</script></p>

<p>The <em>initialized state</em> is usually set outside of the loop directly like below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0</span>
<span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    \boldsymbol{a} = F_0 \\
    \boldsymbol{b} = F_1
  \end{array}
\right)
\end{CD}
\underbrace{
\begin{CD}
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}
}_{loop}</script>

<p>Since <em>initialized state</em> is set before the loop,
we should start the track from <script type="math/tex">n = 1</script> to <script type="math/tex">2, 5, 10</script>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// No `s.push(n); // n = 0 now.` here!</span>
</code></pre></div></div>

<p>Therefore, the code will be:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="cm">/*n /= 2*/</span><span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="c1">// Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.</span>
    <span class="c1">// k = m/2, if m is even. k = (m-1)/2, if m is odd.</span>
    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2</span>

    <span class="k">if</span> <span class="p">(</span><span class="cm">/*m % 2*/</span><span class="n">m</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// m = 2k+1:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>              <span class="c1">//  F(m) = F(2k+1)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>          <span class="c1">//  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>              <span class="c1">// m = 2k:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>              <span class="c1">//  F(m) = F(2k)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>              <span class="c1">//  F(m+1) = F(2k+1)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Another trick above is to replace <code class="highlighter-rouge">n /= 2</code> by <code class="highlighter-rouge">n &gt;&gt;= 1</code>
and <code class="highlighter-rouge">m % 2</code> by <code class="highlighter-rouge">m &amp; 1</code>.
It will be faster a little bit.</p>

<h4 id="non-stack-approach">Non-stack approach</h4>
<p>Since applying <code class="highlighter-rouge">std::stack</code> will pay for memory allocation,
so we should try not using it for better performance.</p>

<p>The reason we need the <em>stack</em> is to get the <strong>track for each <script type="math/tex">n</script></strong>,
where <script type="math/tex">n \leftarrow \lfloor \frac{n}{2} \rfloor</script> until <script type="math/tex">n = 1</script>.
And the track is used to determine what state we should update
from <script type="math/tex">[F_n, F_{n+1}]</script>, to <script type="math/tex">[F_{2n}, F_{2n+1}]</script> or <script type="math/tex">[F_{2n+1}, F_{2n+2}]</script>,
by the given <script type="math/tex">n</script> is <strong>even or odd</strong>.</p>

<p>In the above implementation,
we put the <script type="math/tex">n_0 = n, n_1, n_2, ..., n_j, ..., n_{t-1}, n_t = 1</script>,
where <script type="math/tex">n_j = \lfloor \frac{n}{2^j} \rfloor</script> denotes
<script type="math/tex">n</script> is right shifted by <script type="math/tex">j</script> bits(<code class="highlighter-rouge">n_j = n &gt;&gt; j</code>)
and <script type="math/tex">j \geq 1</script> is an integer,
to the <em>stack</em>, and then iteratively check <script type="math/tex">n_t = 1, n_{t-1}, ..., n_2, n_1, n_0 = n</script>
is odd or even.
We could do it without <em>stack</em>!
Assume the <strong>highest</strong> 1-bit in <script type="math/tex">n</script> is the <script type="math/tex">h</script>th bit from right side,
then the loop will execute <script type="math/tex">h = t + 1 = \log_2 n + 1</script> times.
(so the time complexity is <script type="math/tex">O(\log n)</script>)
Therefore, we could loop <script type="math/tex">h</script> times to calculate <script type="math/tex">F_{n_j}</script>
from <script type="math/tex">j = t = h-1</script> to <script type="math/tex">j = 0</script>.
As the result, the code will be:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The position of the highest bit of n.</span>
  <span class="c1">// So we need to loop `h` times to get the answer.</span>
  <span class="c1">// Example: n = (Dec)50 = (Bin)00110010, then h = 6.</span>
  <span class="c1">//                               ^ 6th bit from right side</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">++</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// n_j = floor(n / 2^j) = n &gt;&gt; j, k = floor(n_j / 2), (n_j = n when j = 0)</span>
    <span class="c1">// then a = F(k), b = F(k+1) now.</span>
    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>            <span class="c1">//   F(n_j) = F(2k+1)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k+1)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>            <span class="c1">// n_j is even: k = n_j/2 =&gt; n_j = 2k</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>            <span class="c1">//   F(n_j) = F(2k)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>            <span class="c1">//   F(n_j + 1) = F(2k + 1)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="by-bit-mask">By Bit-mask</h5>
<p>Doing <em>AND</em> operation(<code class="highlighter-rouge">&amp;</code>) to the last bit of <script type="math/tex">n_j</script> above is same as
doing <em>AND</em> operation(<code class="highlighter-rouge">&amp;</code>) <strong>from the highest bit to the lowest bit</strong>
of the <script type="math/tex">n</script>. Thus, we could also rewrite the code into:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The position of the highest bit of n.</span>
  <span class="c1">// So we need to loop `h` times to get the answer.</span>
  <span class="c1">// Example: n = (Dec)50 = (Bin)00110010, then h = 6.</span>
  <span class="c1">//                               ^ 6th bit from right side</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">++</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1</span>
  <span class="c1">// There is only one `1` in the bits of `mask`. The `1`'s position is same as</span>
  <span class="c1">// the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right</span>
  <span class="c1">// iteratively to do `AND` operation with `n` to check `n_j` is odd or even,</span>
  <span class="c1">// where n_j is defined below.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="n">mask</span> <span class="p">;</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Run h times!</span>
    <span class="c1">// Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &gt;&gt; j</span>
    <span class="c1">// (n_j = n when j = 0), k = floor(n_j / 2), then a = F(k), b = F(k+1) now.</span>
    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j) = F(2k + 1)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        <span class="c1">// n_j is even: k = n_j/2 =&gt; n_j = 2k</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>        <span class="c1">//   F(n_j) = F(2k)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j + 1) = F(2k + 1)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>All the above code are on <a href="https://gist.github.com/ChunMinChang/f80ef4decca23b88df16f2f7846049b6" title="Calculating Fibonacci Numbers by Fast Doubling">gist here</a>.</p>

:ET