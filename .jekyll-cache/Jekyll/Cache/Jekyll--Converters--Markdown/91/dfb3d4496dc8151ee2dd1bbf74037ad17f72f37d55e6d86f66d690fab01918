I"ð™<p>What is the time complexity of the computation for <script type="math/tex">k^n</script>?
We might intuitively think itâ€™s <script type="math/tex">O(n)</script>.
In fact, it can be done in <script type="math/tex">O(\log n)</script>
by <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">exponentiation by squaring</a>.</p>

<p>The key idea is:</p>

<script type="math/tex; mode=display">% <![CDATA[
k^n =
\begin{cases}
(k^\frac{n}{2})^2,  & \text{if $n$ is even} \\
k \cdot (k^\frac{n-1}{2})^2, & \text{if $n$ is odd}
\end{cases} %]]></script>

<p>or</p>

<script type="math/tex; mode=display">% <![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  & \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, & \text{if $n$ is odd}
\end{cases} %]]></script>

<p>By dividing <script type="math/tex">n</script> to <script type="math/tex">\frac{n}{2}</script> again and again,
then stop when <script type="math/tex">n = 0</script>,
we could solve <script type="math/tex">k^n</script> in <script type="math/tex">O(\log n)</script>.</p>

<h2 id="top-down-approach">Top-down Approach</h2>

<h3 id="recursive">Recursive</h3>
<p>If we apply the first conversion, we could get the following code:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="n">pow1</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow1</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pow1</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow1</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above program uses two same recursions, <code class="highlighter-rouge">... * pow1(...) * pow1(...)</code>,
as the returned value, so it will duplicate two same stacks.
On the other hand, if we apply the second conversion,
then there is no duplicated stack needed.
It could save almost half computation time of the <code class="highlighter-rouge">pow1</code>
since it only uses half recursions than <code class="highlighter-rouge">pow1</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="n">pow2</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pow2</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above code still could be simplified.
The result of the division <script type="math/tex">y = \frac{x}{2}</script> is
actually <script type="math/tex">y = \lfloor \frac{x}{2} \rfloor</script> in the world of <em>C</em> and <em>C++</em>,
if <script type="math/tex">y</script> is an integer.</p>

<p>That is, if <code class="highlighter-rouge">n</code> is an <strong>odd</strong> integer,
then the result of <code class="highlighter-rouge">n = (n - 1) / 2</code> is same as <code class="highlighter-rouge">n = n / 2</code>.</p>

<p>Thus, the code could be simplified as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow3</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pow3</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="c1">// so x = (k^2)^(n/2),      if n is even</span>
  <span class="c1">//     or (k^2)^((n-1)/2),  if n is odd</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span> <span class="c1">// so x = k * (k^2)^((n-1)/2)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Another trick is that We could replace <code class="highlighter-rouge">a = b / 2</code> by <code class="highlighter-rouge">a = b &gt;&gt; 1</code>
and <code class="highlighter-rouge">a = b % 2</code> by <code class="highlighter-rouge">a = b &amp; 0x01</code>.
(But I guess your compiler might already do that for you.)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pow4</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">x</span> <span class="o">*</span> <span class="n">k</span> <span class="o">:</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="iterative">Iterative</h3>
<p>If we could rewrite a recursive algorithm into an iterative version,
it usually run faster.</p>

<p>If <script type="math/tex">n</script> is always even, then itâ€™s easy to calculate in a loop.
For example, when <script type="math/tex">k = 3, n = 8</script>, we can calculate <script type="math/tex">k^n = 3^8</script>
by <script type="math/tex">3^8 = (3^2)^4 = ((3^2)^2)^2 = (((3^2)^2)^2)^1</script>.</p>

<p>Thus, we can find <script type="math/tex">k^n</script> by:</p>
<ol>
  <li><script type="math/tex">k_0 = 3, n_0 = 8</script>, now <script type="math/tex">k^n = k_0^{n_0}</script></li>
  <li><script type="math/tex">k_1 = k_0^2 = 3^2, n_1 = \frac{n_0}{2} = 4</script>, now <script type="math/tex">k^n = k_1^{n_1}</script></li>
  <li><script type="math/tex">k_2 = (k_1)^2 = 3^4, n_2 = \frac{n_1}{2} = 2</script>, now <script type="math/tex">k^n = k_2^{n_2}</script></li>
  <li><script type="math/tex">k_3 = (k_2)^2 = 3^8, n_3 = \frac{n_2}{2} = 1</script>, now <script type="math/tex">k^n = k_3^{n_3}</script></li>
  <li><script type="math/tex">n_3 = 1</script>, so <script type="math/tex">k^n = k_3^{n_3} = k_3 = 3^8</script></li>
</ol>

<p>On the other hand, if <script type="math/tex">n</script> is not always even,
then we need to deal with the single leading <script type="math/tex">k</script>
in the <script type="math/tex">k \cdot (k^2)^\frac{n-1}{2}</script>,
which will not used to square.
For example, when <script type="math/tex">k = 3, n = 7</script>, we can calculate <script type="math/tex">k^n = 3^7</script>
by <script type="math/tex">3 \cdot (3^2)^3 = 3 \cdot (3^2 \cdot ((3^2)^2)^1)</script>.</p>

<p>In this case, we need one more variable <script type="math/tex">r</script>
to track the single leading <script type="math/tex">k</script>.
That is, we can find <script type="math/tex">k^n</script> by:</p>
<ol>
  <li><script type="math/tex">k_0 = 3, n_0 = 7, r_0 = 1</script>, now <script type="math/tex">k^n = r_0 \cdot k_0^{n_0}</script></li>
  <li><script type="math/tex">k_1 = k_0^2 = 3^2, n_1 = \frac{n_0 - 1}{2} = 3, r_1 = r_0 \cdot k_0 = 3</script>,
now <script type="math/tex">k^n = r_1 \cdot k_1^{n_1}</script></li>
  <li><script type="math/tex">k_2 = k_1^2 = 3^4, n_2 = \frac{n_1 - 1}{2} = 1, r_2 = r_1 \cdot k_1 = 3^3</script>,
now <script type="math/tex">k^n = r_2 \cdot k_2^{n_2}</script></li>
  <li><script type="math/tex">n_2 = 1</script>, so <script type="math/tex">k^n = r_2 \cdot k_2^{n_2} = r_2 \cdot k_2 = 3^3 \cdot 3^4</script></li>
</ol>

<p>Wrapping up the above ideas, we could summarize the following code:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow5</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// The remaining part for the squaring.</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">k</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">k</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <script type="math/tex">r</script> is the product of all the single leading <script type="math/tex">k</script>.
The loop finishes when <script type="math/tex">n = 1</script> in above code and return <script type="math/tex">r \cdot k</script>.</p>

<p>We could see there is a duplicated <code class="highlighter-rouge">r * k</code> in above.
If we keep looping when <script type="math/tex">n = 1</script>, then the <code class="highlighter-rouge">r = r * k</code> is our final answer.
Moreover, when <script type="math/tex">n = 0</script>, the initial <code class="highlighter-rouge">r = 1</code> is also correct,
so the beginning <code class="highlighter-rouge">if</code> could be saved.
However, we will waste a little time to compute the useless <code class="highlighter-rouge">k = k * k</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The `r` should be the remaining part for the squaring(in pow5).</span>
  <span class="c1">// However, we notice that the `r * k` is duplicated in pow5. We will get</span>
  <span class="c1">// the answer by `r * k` when n = 1. If we keep looping when n = 1,</span>
  <span class="c1">// `r` is our answer. Nevertheless, we will waste time to do `k *= k`</span>
  <span class="c1">// when n = 1.</span>
  <span class="kt">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">k</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">k</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There is different angle to see the above algorithm.
Actually, we can define <script type="math/tex">k^n</script> by:</p>

<script type="math/tex; mode=display">% <![CDATA[
k^n =
\begin{cases}
r \cdot (k^2)^\frac{n}{2}, r = 1 & \text{if $n$ is even} \\
r \cdot (k^2)^\frac{n-1}{2}, r = k & \text{if $n$ is odd}
\end{cases} %]]></script>

<p>Thus, we could also use <script type="math/tex">r</script> to find <script type="math/tex">k^n</script>.
By the example above when <script type="math/tex">k = 3, n = 8</script>:</p>
<ol>
  <li><script type="math/tex">k_0 = 3, n_0 = 8, r_0 = 1</script>, now <script type="math/tex">k^n = r_0 \cdot k_0^{n_0}</script></li>
  <li><script type="math/tex">k_1 = k_0^2 = 3^2, n_1 = \frac{n_0}{2} = 4, r_1 = r_0 \cdot 1 = 1</script>, now <script type="math/tex">k^n = r_1 \cdot k_1^{n_1}</script></li>
  <li><script type="math/tex">k_2 = (k_1)^2 = 3^4, n_2 = \frac{n_1}{2} = 2, r_2 = r_1 \cdot 1 = 1</script>, now <script type="math/tex">k^n = r_2 \cdot k_2^{n_2}</script></li>
  <li><script type="math/tex">k_3 = (k_2)^2 = 3^8, n_3 = \frac{n_2}{2} = 1, r_3 = r_2 \cdot 1 = 1</script>, now <script type="math/tex">k^n = r_3 \cdot k_3^{n_3}</script></li>
  <li><script type="math/tex">k_4 = (k_3)^2 = 3^16, n_4 = \frac{n_3 - 1}{2} = 0, r_4 = r_3 \cdot k_3 = 3^8</script>,
now <script type="math/tex">k^n = r_4 \cdot k_4^{n_4}</script></li>
  <li><script type="math/tex">n_4 = 0</script>, so <script type="math/tex">k^n = r_4 = 3^8</script></li>
</ol>

<p>We could see a more general case when <script type="math/tex">k = 3, n = 10</script>:</p>
<ol>
  <li><script type="math/tex">k_0 = 3, n_0 = 10, r_0 = 1</script>, now <script type="math/tex">k^n = r_0 \cdot k_0^{n_0}</script></li>
  <li><script type="math/tex">k_1 = k_0^2 = 3^2, n_1 = \frac{n_0}{2} = 5, r_1 = r_0 \cdot 1 = 1</script>, now <script type="math/tex">k^n = r_1 \cdot k_1^{n_1}</script></li>
  <li><script type="math/tex">k_2 = (k_1)^2 = 3^4, n_2 = \frac{n_1 - 1}{2} = 2, r_2 = r_1 \cdot k_1 = 3^2</script>, now <script type="math/tex">k^n = r_2 \cdot k_2^{n_2}</script></li>
  <li><script type="math/tex">k_3 = (k_2)^2 = 3^8, n_3 = \frac{n_2}{2} = 1, r_3 = r_2 \cdot 1 = 3^2</script>, now <script type="math/tex">k^n =  r_3 \cdot k_3^{n_3}</script></li>
  <li><script type="math/tex">k_4 = (k_3)^2 = 3^{16}, n_4 = \frac{n_3 - 1}{2} = 0, r_4 = r_3 \cdot k_3 = 3^{10}</script>,
now <script type="math/tex">k^n = r_4 \cdot k_4^{n_4}</script></li>
  <li><script type="math/tex">n_4 = 0</script>, so <script type="math/tex">k^n = r_4 = 3^{10}</script></li>
</ol>

<p>In summary, the whole process can be organized into following table:</p>

<table>
  <thead>
    <tr>
      <th>round <script type="math/tex">i</script></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><script type="math/tex">n</script></td>
      <td><script type="math/tex">10</script></td>
      <td><script type="math/tex">5</script></td>
      <td><script type="math/tex">2</script></td>
      <td><script type="math/tex">1</script></td>
      <td><script type="math/tex">0</script></td>
    </tr>
    <tr>
      <td><script type="math/tex">k</script></td>
      <td><script type="math/tex">3</script></td>
      <td><script type="math/tex">3^2</script></td>
      <td><script type="math/tex">3^4</script></td>
      <td><script type="math/tex">3^8</script></td>
      <td><script type="math/tex">3^{16}</script></td>
    </tr>
    <tr>
      <td><script type="math/tex">r</script></td>
      <td><script type="math/tex">1</script></td>
      <td><script type="math/tex">1</script></td>
      <td><script type="math/tex">3^2</script></td>
      <td><script type="math/tex">3^2</script></td>
      <td><script type="math/tex">3^{10}</script></td>
    </tr>
  </tbody>
</table>

<p>By calculating <script type="math/tex">n_{i+1} = \lfloor \frac{n_i}{2} \rfloor</script>,
<script type="math/tex">k_{i+1} = {k_i}^2</script> and <script type="math/tex">r_{i+1} = r_i \cdot c_i</script>,
where <script type="math/tex">c_i = k_i</script> when <script type="math/tex">n_i</script> is odd or <script type="math/tex">c_i = 1</script> when <script type="math/tex">n_i</script> is even,
we can get the answer by <script type="math/tex">k^n = r_j</script> when <script type="math/tex">n_j = 0</script> for some <script type="math/tex">j</script>.</p>

<p>As a result, the algorithm is:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">k</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">r</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// This could be saved!</span>
      <span class="n">k</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Like what we mentioned in recursive part,
If <code class="highlighter-rouge">n</code> is an <strong>odd</strong> integer,
then the result of <code class="highlighter-rouge">n = (n - 1) / 2</code> is same as <code class="highlighter-rouge">n = n / 2</code>.
nd we can also replace <code class="highlighter-rouge">a = b / 2</code> by <code class="highlighter-rouge">a = b &gt;&gt; 1</code>
and <code class="highlighter-rouge">a = b % 2</code> by <code class="highlighter-rouge">a = b &amp; 0x01</code>.
Finally, the algorithm can be shorten as:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow7</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n % 2</span>
      <span class="n">r</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">k</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// n = n / 2;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="bottom-up-approach">Bottom-up Approach</h2>

<p>The top-down approach is to calculate the value
from <script type="math/tex">x = n</script> to <script type="math/tex">x = 0</script> repeatedly,
where <script type="math/tex">x \leftarrow \lfloor \frac{x}{2} \rfloor</script>,
and the <script type="math/tex">r</script>â€™s value is updated when <script type="math/tex">x</script> is odd.</p>

<p>The <script type="math/tex">j</script> is changed like:</p>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
10
@>{n = \frac{n}{2}}>>
5
@>{n = \frac{n-1}{2}}>>
2
@>{n = \frac{n}{2}}>>
1
@>{n = \frac{n-1}{2}}>>
0
\end{CD}</script>

<p>To convert it into bottom-up approach,
we need to run in the <strong>opposite</strong> direction:</p>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
0
@>{n = 2n + 1}>>
1
@>{n = 2n}>>
2
@>{n = 2n + 1}>>
5
@>{n = 2n}>>
10
\end{CD}</script>

<p>Suppose we have <script type="math/tex">k^{n_j}</script>,
where <script type="math/tex">n_j = \lfloor \frac{n_{j+1}}{2} \rfloor</script>,
then we can calculate <script type="math/tex">k^{n_{j+1}}</script> by:</p>

<script type="math/tex; mode=display">% <![CDATA[
k^{n_{j+1}} =
\begin{cases}
k^{2 n_j} = (k^{n_j})^2,  & \text{if $n_{j+1}$ is even} \\
k^{2 n_j + 1} = k \cdot (k^{n_j})^2, & \text{if $n_{j+1}$ is odd}
\end{cases} %]]></script>

<p>since</p>

<script type="math/tex; mode=display">% <![CDATA[
n_{j+1} =
\begin{cases}
2 n_j,  & \text{if $n_{j+1}$ is even} \\
2 n_j + 1, & \text{if $n_{j+1}$ is odd}
\end{cases} %]]></script>

<p>Thus, if we have the track the changing of <script type="math/tex">n_j</script>,
then we can use a single variable <script type="math/tex">a</script> to calculate <script type="math/tex">k^{n_j} = a_j</script> by</p>

<script type="math/tex; mode=display">% <![CDATA[
k^{n_{j+1}} = a_{j+1} =
\begin{cases}
(k^{n_j})^2 = {a_j}^2,  & \text{if $n_{j+1}$ is even} \\
k \cdot (k^{n_j})^2 = k \cdot {a_j}^2, & \text{if $n_{j+1}$ is odd}
\end{cases} %]]></script>

<p>, where <script type="math/tex">n_j = 0, a_0 = 1</script>.</p>

<table>
  <thead>
    <tr>
      <th>round <script type="math/tex">j</script></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><script type="math/tex">n</script></td>
      <td><script type="math/tex">0</script></td>
      <td><script type="math/tex">1</script></td>
      <td><script type="math/tex">2</script></td>
      <td><script type="math/tex">5</script></td>
      <td><script type="math/tex">10</script></td>
    </tr>
    <tr>
      <td>odd</td>
      <td>Â </td>
      <td>v</td>
      <td>Â </td>
      <td>v</td>
      <td>Â </td>
    </tr>
    <tr>
      <td><script type="math/tex">a</script></td>
      <td><script type="math/tex">1</script></td>
      <td><script type="math/tex">k\cdot{a_0}^2=k</script></td>
      <td><script type="math/tex">{a_1}^2=k^2</script></td>
      <td><script type="math/tex">k\cdot{a_2}^2 = k^5</script></td>
      <td><script type="math/tex">{a_3}^2=k^{10}</script></td>
    </tr>
  </tbody>
</table>

<p>The only question now is how we could get <script type="math/tex">n_j</script>.
The changing of <script type="math/tex">n_j</script> here is <strong>opposite</strong> to the changing
of the recursive approach.
Thus, if we could push all the changing in recursive approach
into a <em>stack</em>, then we can pop them to get the opposite changing.
That is,</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// To track the variation of n.</span>
<span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>

<span class="c1">// Get the n's changing in the recursive approach.</span>
<span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// We lost 0 here, so we need to set the initial state for n_j = 0</span>

<span class="c1">// Initializing variable for n_j = 0 ...</span>

<span class="c1">// Get the opposite track in the recursive approach.</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// Get the current n_j.</span>
  <span class="c1">// Calculate our answer here ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Obviously, we have <script type="math/tex">h = \lceil log_2 n \rceil</script> items in the <em>stack</em>,
so the loop will run <script type="math/tex">h</script> rounds (the above <script type="math/tex">j</script> is from <script type="math/tex">0</script> to <script type="math/tex">h</script>).</p>

<p>In the case for <script type="math/tex">n = 10</script>, the bottom-up approach will run as follows:</p>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
0
\end{CD}
\underbrace{
\begin{CD}
@>{n = 2n + 1}>>
1
@>{n = 2n}>>
2
@>{n = 2n + 1}>>
5
@>{n = 2n}>>
10
\end{CD}
}_{loop}</script>

<p>To calculate our answer,
we need to add a variable <script type="math/tex">a</script>
to keep tracking the <script type="math/tex">k^{n_j} = a_j</script>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow8</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="cm">/*n /= 2*/</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// a = k^0 = 1</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="c1">// Let y = floor(x/2), y = x/2 if x is even, y = (x-1)/2 if x is odd.</span>
    <span class="c1">// then a = k^y now.</span>
    <span class="n">a</span> <span class="o">*=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// a = (k^y)^2 = k^(2y)</span>
                  <span class="c1">// x is even:</span>
                  <span class="c1">//   a = k^x = k^(2y)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="cm">/*x % 2*/</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// x is odd:</span>
      <span class="n">a</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>     <span class="c1">//   a = k^x = k^(2y+1) = k * k^(2y)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To get even or odd the <code class="highlighter-rouge">x</code> is, the <code class="highlighter-rouge">x</code> is checked iteratively,
where <code class="highlighter-rouge">x = n &gt;&gt; j</code> and <code class="highlighter-rouge">j</code> is the times we have looped,
by <code class="highlighter-rouge">x &amp; 1</code> in the <code class="highlighter-rouge">while (!s.empty())</code>.
In other word, we are actually checking
from the <strong>lowest bit to highest bit</strong> of <code class="highlighter-rouge">x</code>.</p>

<p>Thus, the code could be rewritten into:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">pow9</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The position of the highest bit of n.</span>
  <span class="c1">// So we need to loop `h` times to get the answer.</span>
  <span class="c1">// Example: n = (Dec)50 = (Bin)00110010, then h = 6.</span>
  <span class="c1">//                               ^ 6th bit from right side</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">++</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// a = k^0 = 1</span>
  <span class="c1">// There is only one `1` in the bits of `mask`. The `1`'s position is same as</span>
  <span class="c1">// the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right</span>
  <span class="c1">// iteratively to do `AND` operation with `n` to check `n_j` is odd or even,</span>
  <span class="c1">// where n_j is defined below.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="n">mask</span> <span class="p">;</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Run h times!</span>
    <span class="c1">// Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &gt;&gt; j</span>
    <span class="c1">// (n_j = n when j = 0), x = floor(n_j / 2), then a = k^x now.</span>
    <span class="n">a</span> <span class="o">*=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// a = (k^x)^2 = k^(2x)</span>
    <span class="c1">// n_j is even: x = n_j / 2 =&gt; n_j = 2x</span>
    <span class="c1">//   a = k^(n_j) = k^(2x)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n_j is odd: x = (n_j - 1) / 2 =&gt; n_j = 2x + 1</span>
      <span class="n">a</span> <span class="o">*=</span> <span class="n">k</span><span class="p">;</span>       <span class="c1">//   a = k^(n_j) = k^(2x+1) = k * k^(2x)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>All the above code are on <a href="https://gist.github.com/ChunMinChang/9753c72e2441343e14757f5a9ac95a98" title="Exponentiation by squaring">gist here</a>.</p>

:ET