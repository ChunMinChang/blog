I"O£<h2 id="recurrence-relation"><a href="https://en.wikipedia.org/wiki/Recurrence_relation" title="Recurrence relation">Recurrence relation</a></h2>

<p>Suppose we have a difference equation defined by:</p>

<script type="math/tex; mode=display">x_n = a \cdot x_{n - 1} + b \cdot x_{n - 2}</script>

<p>Then,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
x_n &= a \cdot x_{n - 1} + b \cdot x_{n - 2}
\\
x_{n - 1} &= 1 \cdot x_{n - 1} + 0 \cdot x_{n - 2}
\end{align} %]]></script>

<p>could be written into a matrix form(<a href="https://en.wikipedia.org/wiki/Matrix_difference_equation" title="Matrix difference equation"><em>matrix difference equation</em></a>):</p>

<script type="math/tex; mode=display">% <![CDATA[
\vec{x_n} =
\begin{bmatrix} x_n \\ x_{n - 1} \end{bmatrix}
=
\begin{bmatrix} a & b \\ 1 & 0 \end{bmatrix}
\cdot
\begin{bmatrix} x_{n - 1} \\ x_{n - 2} \end{bmatrix}
=
S \cdot \vec{x_{n-1}} %]]></script>

<p>Since <script type="math/tex">S</script> can transit the state from <script type="math/tex">\vec{x_{n-1}}</script> to <script type="math/tex">\vec{x_n}</script>,
the state vector can be expanded by adding any pair <script type="math/tex">\vec{x_{t-1}}, \vec{x_t}</script>
to the above equation.</p>

<p>For example,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
x_t, x_n &= a \cdot x_{t - 1} + b \cdot x_{t - 2}, a \cdot x_{n - 1} + b \cdot x_{n - 2}
\\
x_{t - 1}, x_{n - 1} &= 1 \cdot x_{t - 1} + 0 \cdot x_{t - 2}, 1 \cdot x_{n - 1} + 0 \cdot x_{n - 2}
\end{align} %]]></script>

<p>can be written into</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{bmatrix} x_t & x_n \\ x_{t - 1} & x_{n - 1} \end{bmatrix}
=
\begin{bmatrix} a & b \\ 1 & 0 \end{bmatrix}
\cdot
\begin{bmatrix} x_{t - 1} & x_{n - 1} \\ x_{t - 2} & x_{n - 2} \end{bmatrix} %]]></script>

<p>In fact, this can be generalized.
Given <script type="math/tex">y_n</script> by:</p>

<script type="math/tex; mode=display">y_n = c_{n - 1} \cdot y_{n - 1} +
      c_{n - 2} \cdot y_{n - 2} +
      \cdots +
      c_0 \cdot y_0</script>

<p>, where <script type="math/tex">c_k</script> is constant and <script type="math/tex">k \in [0, n-1]</script> is a integer.</p>

<p>then we can rewritten the equations into:</p>

<script type="math/tex; mode=display">% <![CDATA[
\vec{y_n} =
\begin{bmatrix}
  y_n \\
  y_{n - 1} \\
  \vdots \\
  y_1
\end{bmatrix}
=
\begin{bmatrix}
  c_{n - 1} & c_{n - 2} & \cdots & c_1 & c_0 \\
  1 & 0 & \cdots & 0 & 0 \\
  0 & 1 & \cdots & 0 & 0 \\
  \vdots \\
  0 & 0 & \cdots & 1 & 0
\end{bmatrix}
\cdot
\begin{bmatrix}
  y_{n - 1} \\
  y_{n - 2} \\
  \vdots \\
  y_0
\end{bmatrix}
= C \cdot\ \vec{y_{n - 1}} %]]></script>

<p>and we could expand the matrix to</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{bmatrix}
  y_{2n - 1} & \cdots & y_{n + 1} & y_n \\
  y_{2n - 2} & \cdots & y_n & y_{n - 1} \\
  \vdots \\
  y_n & \cdots & y_2 & y_1
\end{bmatrix}
=
\begin{bmatrix}
  c_{n - 1} & c_{n - 2} & \cdots & c_1 & c_0 \\
  1 & 0 & \cdots & 0 & 0 \\
  0 & 1 & \cdots & 0 & 0 \\
  \vdots \\
  0 & 0 & \cdots & 1 & 0
\end{bmatrix}
\cdot
\begin{bmatrix}
  y_{2n - 2} & \cdots & y_n & y_{n - 1} \\
  y_{2n - 3} & \cdots & y_{n - 1} & y_{n - 2} \\
  \vdots \\
  y_{n - 1} & \cdots & y_1 & y_0
\end{bmatrix} %]]></script>

<h2 id="fibonacci-sequence">Fibonacci Sequence</h2>

<p>Fibonacci number is defined by:</p>

<script type="math/tex; mode=display">F_n = F_{n - 1} + F_{n - 2}, \text{where } F_0 = 0 \text{ and } F_1 = 0</script>

<p>Obviously, <em>Fibonacci</em> sequence is a <a href="https://en.wikipedia.org/wiki/Recurrence_relation" title="Recurrence relation"><em>difference equation</em></a>
(<script type="math/tex">a = b = 1</script> in above example) and it could be written in:</p>

<script type="math/tex; mode=display">% <![CDATA[
\vec{F_n} =
\begin{bmatrix} F_n \\ F_{F - 1} \end{bmatrix}
=
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_{n - 1} \\ F_{n - 2} \end{bmatrix}
=
S \cdot \vec{F_{n-1}} %]]></script>

<h3 id="matrix-form">Matrix Form</h3>

<p>If we expand the <script type="math/tex">\vec{F_n}</script> by taking <script type="math/tex">t = n + 1</script> in above example,
then</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
&=
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_n & F_{n - 1} \\ F_{n - 1} & F_{n - 2} \end{bmatrix}
\\
&=
{\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^2
\cdot
\begin{bmatrix} F_{n - 1} & F_{n - 2} \\ F_{n - 2} & F_{n - 3} \end{bmatrix}
\\
\vdots
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} F_2 & F_1 \\ F_1 & F_0 \end{bmatrix}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\end{align} %]]></script>

<h4 id="computing-fibonacci-number-by-exponentiation">Computing <em>Fibonacci</em> number by exponentiation</h4>
<p>By the above formula, the <em>Fibonacci</em> number <script type="math/tex">F_n</script>
can be calculated in <script type="math/tex">O(\log n)</script>.
The key is to compute the exponentiation by squaring.</p>

<script type="math/tex; mode=display">% <![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  & \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, & \text{if $n$ is odd}
\end{cases} %]]></script>

<p>I explained how to do it in my
<!-- [previous post](/post/exponentiation-by-squaring) -->
<a href="https://chunminchang.github.io/blog/post/exponentiation-by-squaring">previous post</a>.
Please read it if you need.</p>

<p>As a result, we can compute <em>Fibonacci</em> number <script type="math/tex">F_n</script> as follows:</p>

<h5 id="by-stdvector">By <code class="highlighter-rouge">std::vector</code></h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Matrix</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">rows</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cols</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">data</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>

  <span class="n">Matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">rows</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cols</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">cols</span><span class="p">);</span>
    <span class="n">data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">cols</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Matrix</span><span class="p">()</span>
  <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">Read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; m)</span>
  <span class="c1">// {</span>
  <span class="c1">//   for (unsigned int i = 0; i &lt; m.rows; ++i) {</span>
  <span class="c1">//     for (unsigned int j = 0; j &lt; m.cols; ++j) {</span>
  <span class="c1">//       os &lt;&lt; m.data[i][j] &lt;&lt; " ";</span>
  <span class="c1">//     }</span>
  <span class="c1">//     os &lt;&lt; std::endl;</span>
  <span class="c1">//   }</span>
  <span class="c1">//   return os;</span>
  <span class="c1">// }</span>

  <span class="n">Matrix</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">cols</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span> <span class="c1">// Check if they can be multiplied.</span>

    <span class="n">Matrix</span> <span class="n">z</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">z</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Calculate the power by fast doubling:</span>
  <span class="c1">//   k ^ n = (k^2) ^ (n/2)          , if n is even</span>
  <span class="c1">//        or k x (k^2) ^ ((k-1)/2)  , if n is odd</span>
  <span class="n">Matrix</span> <span class="n">pow</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">x</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// Copy constructor = Matrix x(rows, cols, data);</span>
    <span class="n">Matrix</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="cm">/*n % 2*/</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="cm">/*n /= 2*/</span><span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Matrix</span> <span class="n">Identity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">z</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">z</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The Fibonacci matrix can be written into the following equation:</span>
<span class="c1">// +-             -+   +-    -+^n</span>
<span class="c1">// | F(n+1)   F(n) |   | 1  1 |</span>
<span class="c1">// |               | = |      |</span>
<span class="c1">// | F(n)   F(n-1) |   | 1  0 |</span>
<span class="c1">// +-             -+   +-    -+</span>
<span class="kt">uint64_t</span> <span class="nf">fibonacci_matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Matrix</span> <span class="n">F</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="p">}</span> <span class="p">};</span>

  <span class="c1">// Using F.data[0][1] since n might be 0.</span>
  <span class="c1">// (we need to power by n - 1 if we return F.data[0][0].)</span>
  <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">pow</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">F</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="by-native-array">By Native Array</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Matrix</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="o">**</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">rows</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cols</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">data</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">AllocateData</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">Matrix</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="c1">// copy ctor</span>
    <span class="o">:</span> <span class="n">rows</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">rows</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cols</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">);</span>
    <span class="n">AllocateData</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span> <span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Matrix</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">FreeData</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">Read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; m)</span>
  <span class="c1">// {</span>
  <span class="c1">//   for (unsigned int i = 0; i &lt; m.rows; ++i) {</span>
  <span class="c1">//     for (unsigned int j = 0; j &lt; m.cols; ++j) {</span>
  <span class="c1">//       os &lt;&lt; m.data[i][j] &lt;&lt; " ";</span>
  <span class="c1">//     }</span>
  <span class="c1">//     os &lt;&lt; std::endl;</span>
  <span class="c1">//   }</span>
  <span class="c1">//   return os;</span>
  <span class="c1">// }</span>

  <span class="n">Matrix</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Matrix</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">// move assignment</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">FreeData</span><span class="p">();</span> <span class="c1">// Free this data if it exists.</span>
      <span class="c1">// Move original other.data to data and set other.data to nullptr.</span>
      <span class="c1">// data = std::exchange(other.data, nullptr); // C++14</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
      <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Matrix</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">cols</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span> <span class="c1">// Check if they can be multiplied.</span>
    <span class="n">Matrix</span> <span class="n">z</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">z</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Calculate the power by fast doubling:</span>
  <span class="c1">//   k ^ n = (k^2) ^ (n/2)          , if n is even</span>
  <span class="c1">//        or k x (k^2) ^ ((k-1)/2)  , if n is odd</span>
  <span class="n">Matrix</span> <span class="n">pow</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">x</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// Copy constructor = Matrix x(rows, cols, data);</span>
    <span class="n">Matrix</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="cm">/*n % 2*/</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="cm">/*n /= 2*/</span><span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Matrix</span> <span class="n">Identity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">z</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">z</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">AllocateData</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">);</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">**</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">FreeData</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">;</span>
  <span class="kt">uint64_t</span><span class="o">**</span> <span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The Fibonacci matrix can be written into the following equation:</span>
<span class="c1">// +-             -+   +-    -+^n</span>
<span class="c1">// | F(n+1)   F(n) |   | 1  1 |</span>
<span class="c1">// |               | = |      |</span>
<span class="c1">// | F(n)   F(n-1) |   | 1  0 |</span>
<span class="c1">// +-             -+   +-    -+</span>
<span class="kt">uint64_t</span> <span class="nf">fibonacci_matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Matrix</span> <span class="n">F</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="k">new</span> <span class="kt">uint64_t</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">new</span> <span class="kt">uint64_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="k">new</span> <span class="kt">uint64_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="p">}</span> <span class="p">};</span>

  <span class="c1">// Using F.data[0][1] since n might be 0.</span>
  <span class="c1">// (we need to power by n - 1 if we return F.data[0][0].)</span>
  <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">pow</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">F</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="fast-doubling">Fast Doubling</h3>

<p>If we calculate <script type="math/tex">F_{2n}</script> directly, we can get the equation follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\begin{bmatrix} F_{2n+1} & F_{2n} \\ F_{2n} & F_{2n - 1} \end{bmatrix}
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{2n}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\cdot
{\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\\
&= \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
\cdot \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
\\
&=
\begin{bmatrix}
  {F_{n+1}}^2 + {F_n}^2 & F_n \cdot (F_{n+1} + F_{n-1}) \\
  F_n \cdot (F_{n+1} + F_{n-1}) & {F_n}^2 + {F_{n-1}}^2
\end{bmatrix}
\end{align} %]]></script>

<p>Thus, <script type="math/tex">F_{2n}, F_{2n + 1}</script> can be calculated by <script type="math/tex">F_n, F_{n+1}</script> since</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
F_{2n+1} &= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]></script>

<p>This two equations help us to calculate <script type="math/tex">F_{N}</script> in <script type="math/tex">O(\log N)</script> time,
since <script type="math/tex">F_{N}</script> can be derived from <script type="math/tex">F_{2N'}</script> or <script type="math/tex">F_{2N' + 1}</script>.</p>

<h4 id="implementation">implementation</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Fast doubling: O(log(n))</span>
<span class="c1">//   Using 2n to the Fibonacci matrix above, we can derive that:</span>
<span class="c1">//     F(2n)   = F(n) * [ 2 * F(n+1) â F(n) ]</span>
<span class="c1">//     F(2n+1) = F(n+1)^2 + F(n)^2</span>
<span class="c1">//     (and F(2n-1) = F(n)^2 + F(n-1)^2)</span>
<span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// When n = 2: k = 1 and we want to use F(k+1) to calculate F(2k),</span>
  <span class="c1">// However, F(2k) = F(k+1) = F(2) is unknown then.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// F(0) = 0, F(1) = 1.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(2) = 1</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) â F(k) ]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The implementation are easy to understand
but it still has a lot of room to improve.
We will discuss it in
<!-- [next post](/post/calculating-fibonacci-numbers-by-fast-doubling) -->
<a href="https://chunminchang.github.io/blog/post/calculating-fibonacci-numbers-by-fast-doubling">next post</a>.
Stay tuned!</p>

:ET