I"Íh<p>This post is synchronized with my <a href="https://gist.github.com/ChunMinChang/beb8db168260166e8f4759f97c7a11c7" title="Opaque or Transparent Data Type in a Rust Library">gist</a> file.</p>

<p>To develop a <em>Rust</em> library that will be used for the external code, the data may be interoperable or non-interoperable. The interoperable data is a data whose underlying memory layout is known and their values can be modified directly by the external code. On the contrary, the non-interoperable data is a data whose underlying memory layout is unknown so their values cannot be changed directly. The underlying values can only be changed when they provide related APIs to do that.</p>

<!--read more-->

<p>In summary, an interoperable data must be a transparent-type data so it can be modified by external code, while a non-interoperable data must be an opaque-type data to prevent its values from being changed by the external code directly.</p>

<p>In this article, we will explain the above ideas in detail by using <em>Rust-to-C</em> examples.</p>

<h2 id="transparent-data-type-in-rust">Transparent Data Type in Rust</h2>
<p>By marking a data type with <code class="highlighter-rouge">#[repr(C)]</code>, the data is interoperable with <em>C/C++</em> since its memory layout is guaranteed to be aligned with <em>C</em>. It can be called as a normal <em>C</em> data. For example, we can operate the data with type <code class="highlighter-rouge">struct Foo</code> from <em>Rust</em></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">bar</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">baz</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">qux</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">get_foo</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">()))</span>
<span class="p">}</span>

<span class="o">...</span>
</code></pre></div></div>
<p>in <em>C</em> code like:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">bar</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">baz</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">qux</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">get_foo</span><span class="p">();</span>
<span class="n">foo</span><span class="o">-&gt;</span><span class="n">qux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// Data with type `Foo` can be modified directly!</span>

<span class="p">...</span>
</code></pre></div></div>

<h2 id="opaque-data-type-in-rust">Opaque Data Type in Rust</h2>
<p>For a non-interoperable data, we can just pass a pointer to its memory address with type <code class="highlighter-rouge">*void</code>. Without the knowledge of the underlaying dataâ€™s memory layout, <em>C/C++</em> code cannot do anything.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// No `#[repr(C)]` here!</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">bar</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">baz</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">qux</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">get_foo</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">c_void</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">()))</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="mi">_</span>
<span class="p">}</span>

<span class="o">...</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">get_foo</span><span class="p">();</span>
<span class="c1">// Cannot do anything with `foo` without knowing the memory layout under this</span>
<span class="c1">// void pointer.</span>

<span class="p">...</span>
</code></pre></div></div>
<p>Even the data type is known, itâ€™s unwise to cast the <code class="highlighter-rouge">*void</code> to a corresponding <em>C</em> data type since the memory layout may be different. That is, the memory layout of the following <code class="highlighter-rouge">struct Foo</code> in <em>Rust</em>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// No `#[repr(C)]` here!</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">bar</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">baz</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">qux</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>
<p>may be different from the the following <code class="highlighter-rouge">struct Foo</code> in <em>C</em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">bar</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">baz</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">qux</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>
</code></pre></div></div>

<p>Therefore, itâ€™s dangerous to cast a <code class="highlighter-rouge">void</code> pointer converted by a <em>Rust</em>-style <code class="highlighter-rouge">Foo</code> pointer to a <em>C</em>-style <code class="highlighter-rouge">Foo</code> pointer to operate it, without marking <code class="highlighter-rouge">struct Foo</code> with <code class="highlighter-rouge">#[repr(C)]</code> in <em>Rust</em>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span> <span class="n">get_foo</span><span class="p">();</span>
<span class="c1">// This is very likely to fail since `foo-&gt;qux` may point to a different</span>
<span class="c1">// address as expected!</span>
<span class="n">foo</span><span class="o">-&gt;</span><span class="n">qux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="p">...</span>
</code></pre></div></div>

<h3 id="why-we-need-to-use-opaque-data-type">Why we need to use Opaque Data Type</h3>

<p>The reason why we need to use a <em>opaque data type</em> is well described in <a href="https://en.wikipedia.org/wiki/Opaque_pointer" title="Opaque pointer">Opaque pointer</a> and <a href="https://en.wikipedia.org/wiki/Opaque_data_type" title="Opaque data type">Opaque data type</a> on <em>Wiki</em> page. In brief, it gives us the flexibility to change the underlying implementation without changing the interface or the need to recompile the code using the hidden data.</p>

<p>For example, the following <em>C</em> code</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">res</span> <span class="o">=</span> <span class="n">get_resource</span><span class="p">();</span>

<span class="p">...</span>

<span class="n">set_something_to_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">...)</span>

<span class="p">...</span>
</code></pre></div></div>

<p>based on the following <em>Rust</em> code</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">bar</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">baz</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">qux</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
      <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">SetSomething</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">set_something</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">SetSomething</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">set_something</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">get_resource</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">c_void</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Foo</span><span class="p">::</span><span class="nf">new</span><span class="p">()))</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="mi">_</span>
<span class="p">}</span>

<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">set_something_to_resource</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">c_void</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Foo</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">foo</span><span class="nf">.set_something</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="o">...</span>
</code></pre></div></div>

<p>doesnâ€™t need to be modified if we change the <em>Rust</em> code into</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Bar</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">baz</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
    <span class="n">qux</span><span class="p">:</span> <span class="p">[</span><span class="nb">i32</span><span class="p">;</span> <span class="mi">10</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Bar</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
      <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="k">trait</span> <span class="n">SetSomething</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">set_something</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">SetSomething</span> <span class="k">for</span> <span class="n">Bar</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">set_something</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">get_resource</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">c_void</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Bar</span><span class="p">::</span><span class="nf">new</span><span class="p">()))</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="mi">_</span>
<span class="p">}</span>

<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">set_something_to_resource</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">c_void</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">bar</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Bar</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">bar</span><span class="nf">.set_something</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="o">...</span>
</code></pre></div></div>

<p>The real-world example Iâ€™ve seen is <a href="https://en.wikipedia.org/wiki/Handle_(computing)" title="handle classes"><em>Handle</em> class</a>. <a href="https://stackoverflow.com/questions/902967/what-is-a-windows-handle/902987#902987" title="stackoverflow">Here</a> is the discussion for Windowsâ€™ <code class="highlighter-rouge">Handle</code> type. The basic idea for Windowsâ€™ <code class="highlighter-rouge">Handle</code> can be found <a href="https://docs.microsoft.com/en-us/windows/desktop/SysInfo/user-objects" title="User Objects">here</a>. One simple example for that is to <a href="https://docs.microsoft.com/en-us/windows/desktop/fileio/opening-a-file-for-reading-or-writing" title="Opening a File for Reading or Writing">open a file</a>.</p>

<p><a href="https://searchfox.org/mozilla-central/rev/0640ea80fbc8d48f8b197cd363e2535c95a15eb3/dom/media/CubebUtils.cpp#89,406" title="Handle for audio ipc">Here</a> is better example for us. This <a href="https://searchfox.org/mozilla-central/rev/0640ea80fbc8d48f8b197cd363e2535c95a15eb3/dom/media/CubebUtils.cpp#89,406" title="Handle for audio ipc">example</a> returns a <em>handle</em> from <em>Rust</em> code and it will be called in <em>C/C++</em> code. That is exactly what we want to do in this post.</p>

<h2 id="sample-code">Sample Code</h2>
<ul>
  <li><em>resource.rs</em>: List two <em>Rust</em> structures:
    <ul>
      <li><code class="highlighter-rouge">Opaque</code>: This is a <em>opaque</em> data type for external code.</li>
      <li><code class="highlighter-rouge">Transparent</code>: This is a <em>transparent</em> data type for external <em>C</em> code(marked with <code class="highlighter-rouge">#[repr(C)]</code>).</li>
    </ul>
  </li>
  <li><em>ext.rs</em>: Interface to <em>C</em>
    <ul>
      <li>Operations for <em>non-interoperable</em> data: <code class="highlighter-rouge">get_opaque</code>, <code class="highlighter-rouge">operate_opaque</code>, <code class="highlighter-rouge">return_opaque</code></li>
      <li>Operations for <em>interoperable</em> data: <code class="highlighter-rouge">get_transparent</code>, <code class="highlighter-rouge">return_transparent</code>
        <ul>
          <li>You can operate the underlying values of the data directly!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><em>ext.h</em>: Header containes the interfaces for the <em>Rust</em> library</li>
  <li><em>sample.c</em>: Sample <em>C</em> code to operate above data</li>
  <li><em>sample.cpp</em> Sample <em>C++</em> code to operate above data</li>
  <li><em>Makefile</em>: Build the sample by <code class="highlighter-rouge">$ make</code>. Clean files by <code class="highlighter-rouge">$ make clean</code></li>
</ul>

<h3 id="resourcers">resource.rs</h3>
<noscript><pre>// Non-interoperable resource
pub struct Opaque {
    value: i32,
}
impl Opaque {
    pub fn new() -&gt; Self {
        Opaque { value: 100 }
    }
    pub fn add(&amp;mut self, value: i32) {
        self.value += value;
    }
    pub fn get_value(&amp;self) -&gt; i32 {
        self.value
    }
}
impl Drop for Opaque {
    fn drop(&amp;mut self) {
        println!(&quot;drop a Opaque with value: {}&quot;, self.get_value());
    }
}

// Interoperable resource
#[repr(C)]
pub struct Transparent {
    value: i32,
}
impl Transparent {
    pub fn new() -&gt; Self {
        Transparent { value: 100 }
    }
    pub fn get_value(&amp;self) -&gt; i32 {
        self.value
    }
}
impl Drop for Transparent {
    fn drop(&amp;mut self) {
        println!(&quot;drop a Transparent with value: {}&quot;, self.get_value());
    }
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/beb8db168260166e8f4759f97c7a11c7.js?file=resource.rs"> </script>

<h3 id="extrs">ext.rs</h3>
<noscript><pre>use resource::{Opaque, Transparent};
use std::os::raw::c_void;

mod resource;

// Interface to a non-interoperable resource
type Handle = *mut c_void;

#[no_mangle]
pub extern &quot;C&quot; fn get_opaque() -&gt; Handle {
    // 1. Create a Opaque instance in stack by `Opaque::new()`
    // 2. Copy the Opaque instance from stack into heap by `Box::new(...)`
    // 3. Consume the `Box` and return the wrapped raw pointer
    let boxed_opa = Box::new(Opaque::new());
    println!(&quot;leak opaque @ {:p}&quot;, boxed_opa.as_ref());
    Box::into_raw(boxed_opa) as Handle
    // Box::into_raw(Box::new(Opaque::new())) as *mut _
}

#[no_mangle]
pub extern &quot;C&quot; fn operate_opaque(opa: Handle, value: i32) {
    assert!(!opa.is_null());
    println!(&quot;operate leaked opaque @ {:p}&quot;, opa);
    // 1. Cast a void pointer to a Opaque pointer
    // 2. Create a mutable Opaque reference from a Opaque pointer
    let opaque = unsafe { &amp;mut *(opa as *mut Opaque) };
    opaque.add(value);
}

#[no_mangle]
pub extern &quot;C&quot; fn return_opaque(opa: Handle) {
    assert!(!opa.is_null());
    println!(&quot;retake leaked opaque @ {:p}&quot;, opa);
    // 1. Cast a void pointer to a Opaque pointer
    // 2. Construct a box from a Opaque pointer
    let opaque = unsafe { Box::&lt;Opaque&gt;::from_raw(opa as *mut _ /* Opaque */) };
    // The box will be dropped after program runs out of the scope, or we can
    // call drop here directly.
    drop(opaque);
}

// Interface to a interoperable resource
#[no_mangle]
pub extern &quot;C&quot; fn get_transparent() -&gt; *mut Transparent {
    // 1. Create a Transparent instance in stack by `Transparent::new()`
    // 2. Copy the Transparent instance from stack into heap by `Box::new(...)`
    // 3. Consume the `Box` and return the wrapped raw pointer
    let boxed_trans = Box::new(Transparent::new());
    println!(&quot;leak transparent @ {:p}&quot;, boxed_trans.as_ref());
    Box::into_raw(boxed_trans)
    // Box::into_raw(Box::new(Transparent::new()))
}

#[no_mangle]
pub extern &quot;C&quot; fn return_transparent(tran: *mut Transparent) {
    assert!(!tran.is_null());
    println!(&quot;retake leaked transparent @ {:p}&quot;, tran);
    // 1. Cast a void pointer to a Transparent pointer
    // 2. Construct a box from a Transparent pointer
    let transparent = unsafe { Box::&lt;Transparent&gt;::from_raw(tran) };
    // The box will be dropped after program runs out of the scope, or we can
    // call drop here directly.
    drop(transparent);
}</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/beb8db168260166e8f4759f97c7a11c7.js?file=ext.rs"> </script>

<h3 id="exth">ext.h</h3>
<noscript><pre>#if !defined(EXT_H)
#define EXT_H

#include &lt;stdint.h&gt; // uint32_t

typedef struct {
  uint32_t value;
} Transparent;

typedef void* Handle;

#if defined(__cplusplus)
extern &quot;C&quot; {
#endif

extern Transparent* get_transparent();
extern void return_transparent(Transparent* transparent);

extern Handle get_opaque();
extern void return_opaque(Handle opaque);
extern void operate_opaque(Handle opaque, uint32_t value);

#if defined(__cplusplus)
}
#endif

#endif // EXT_H</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/beb8db168260166e8f4759f97c7a11c7.js?file=ext.h"> </script>

<h3 id="samplec">sample.c</h3>
<noscript><pre>#include &quot;ext.h&quot;    // Types and in the external library
#include &quot;stdio.h&quot;  // printf

int main() {
  Transparent* transparent = get_transparent();
  printf(&quot;get a transparent @ %p\n&quot;, transparent);
  transparent-&gt;value = 200;
  return_transparent(transparent);
  // Now transparent&#39;s memory is freed and it&#39;s a dangling pointer.

  Handle opaque = get_opaque();
  printf(&quot;get a opaque @ %p\n&quot;, opaque);
  operate_opaque(opaque, 500);
  return_opaque(opaque);
  // Now opaque&#39;s memory is freed and it&#39;s a dangling pointer.

  return 0;
}</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/beb8db168260166e8f4759f97c7a11c7.js?file=sample.c"> </script>

<h3 id="samplecpp">sample.cpp</h3>
<noscript><pre>#include &quot;ext.h&quot;    // Types and in the external library
#include &lt;iostream&gt; // printf
#include &lt;memory&gt;   // std::unique_ptr

int main() {
  std::unique_ptr&lt;Transparent, decltype(&amp;return_transparent)&gt;
    transparent(get_transparent(), return_transparent);
  printf(&quot;get a transparent @ %p\n&quot;, transparent.get());
  transparent-&gt;value = 200;

  std::unique_ptr&lt;void, decltype(&amp;return_opaque)&gt;
    opaque(get_opaque(), return_opaque);
  printf(&quot;get a opaque @ %p\n&quot;, opaque.get());
  operate_opaque(opaque.get(), 500);

  return 0;
}</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/beb8db168260166e8f4759f97c7a11c7.js?file=sample.cpp"> </script>

<h3 id="makefile">Makefile</h3>
<noscript><pre>all:
				# Build a static library from the Rust file
				rustc --crate-type=staticlib ext.rs
				# Compile the C file with the static library
				# gcc -o sample-c sample.c libext.a
				gcc -o sample-c sample.c -L. -lext
				./sample-c
				# g++ -o sample-cpp sample.cpp libext.a
				g++ -o sample-cpp sample.cpp -L. -lext
				./sample-cpp

clean:
				rm libext.a
				rm sample-c
				rm sample-cpp</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/beb8db168260166e8f4759f97c7a11c7.js?file=Makefile"> </script>

:ET