I"±><p>There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1337805">bug here</a>.
It <strong>only happens on OSX</strong>.
After <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1350511#c1">analysis</a>,
I wrote a test to prevent others from getting into the same problem.
The test is added to <a href="https://github.com/ChunMinChang/cubeb">cubeb</a>,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of <a href="https://github.com/ChunMinChang/cubeb/blob/8939c0d168a27b1d5047779caad46835ca4651b9/test/test_deadlock.cpp#L1-L43">the deadlock</a>)
in the test.</p>

<p>However, the code is not easy enough for those who are not familir with <em>cubeb</em>,
so I wrote a general version to highlight the issue to
everyone who uses <em>AudioUnit</em> in their audio backend.
You can find the code on <a href="https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9">gist here</a></p>

<noscript><pre>// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&gt; Thread B

#include &lt;assert.h&gt;               // for assert
#include &lt;pthread.h&gt;              // for pthread
#include &lt;signal.h&gt;               // for signal
#include &lt;unistd.h&gt;               // for sleep, usleep

#include &quot;AudioStream.h&quot;          // for AudioStream
#include &quot;utils.h&quot;                // for LOG
#include &quot;OwnedCriticalSection.h&quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&lt;OwnedCriticalSection&gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&quot;pending task thread is killed!\n&quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;&amp; LOG(&quot;Output callback is on thread %llu, holding mutex_AU\n&quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&quot;[%llu] Force to switch threads\n&quot;, id);
    usleep(10000);
  }

  LOG(&quot;[%llu] Try getting another mutex: gMutex...\n&quot;, id);
  locker guard(gMutex);

  LOG(&quot;[%llu] Got mutex finally!\n&quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&quot;Task thread: %llu, holding gMutex, is created\n&quot;, id);

  while(!gCalling) {
    LOG(&quot;[%llu] waiting for output callback before running task\n&quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already had one will cause a deadlock!
  LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&quot;[%llu] Another AudioUnit is created!\n&quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&quot;Task thread: %llu is created\n&quot;, id);
//
//   while(!gCalling) {
//     LOG(&quot;[%llu] waiting for output callback before running task\n&quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already had one will cause a deadlock!
//   LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&quot;[%llu] Another AudioUnit is created!\n&quot;, id);
//
//   // Hold the mutex.
//   LOG(&quot;[%llu] Try getting another mutex: gMutex...\n&quot;, id);
//   locker guard(gMutex);
//
//   LOG(&quot;[%llu] Got mutex finally!\n&quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&quot;Monitor thread %llu on thread %llu\n&quot;, sid, id);

  unsigned int sec = 1;
  LOG(&quot;[%llu] sleep %d seconds before checking task for thread %llu\n&quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&quot;[%llu] Kill the task thread %llu!\n&quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&#39;t be released,
    // so we need unlock it manually. Notice that we can&#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&quot;\n[%llu] Task is %sdone\n\n&quot;, id, gTaskDone ? &quot;&quot;: &quot;NOT &quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;subject, NULL, task, NULL);
  pthread_create(&amp;detector, NULL, watchdog, (void *) &amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be processed.
  // No need to keep checking in this case.
  assert(gCalled &amp;&amp; &quot;Callback should be fired!&quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;&amp; &quot;Deadlock detected!&quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;&amp; &quot;Killer is out of control!&quot;);

  return 0;
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=test_deadlock.cpp"> </script>

<p>The APIs called to play and stop the audio stream is:</p>
<noscript><pre>#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &lt;AudioUnit/AudioUnit.h&gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  bool SetDescription(Format aFormat);
  bool SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                               AudioUnitRenderActionFlags* aActionFlags,
                               const AudioTimeStamp* aTimeStamp,
                               UInt32 aBusNumber,
                               UInt32 aNumFrames,
                               AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.h"> </script>

<noscript><pre>#include &lt;assert.h&gt;
#include &lt;CoreAudio/CoreAudio.h&gt;

#include &quot;AudioStream.h&quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;&amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  assert(SetDescription(aFormat)); // Initialize mDescription
  assert(SetCallback()); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

bool
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      return false;
  }

  // The mFormatFlags below should be set by &quot;|&quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  return AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;mDescription,
                              sizeof(mDescription)) == noErr;
}

bool
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&#39;s arguments

  return AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;aurcbs,
                              sizeof(aurcbs)) == noErr;
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&lt;AudioStream*&gt;(aRefCon); // Get arguments
  void* buffer = aData-&gt;mBuffers[0].mData;
  as-&gt;mCallback(buffer, aNumFrames);
  return noErr;
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.cpp"> </script>

<p>The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as <em>Mutex-AU</em>)
shared with <em>AudioUnit</em>.
The <em>Mutex-AU</em> is held inside itâ€™s framework, so you donâ€™t notice it.</p>

<p>Thus, if the callback thread requests another <em>mutex M</em> held by the another
thread, without releasing <em>mutex-AU</em>, then it will cause a deadlock when the
another thread, which holds the <em>mutex M</em>, request to use AudioUnit.</p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock.gif" alt="" /></p>

<p>That is,
if we have a <em>thread T</em>, holding the <em>mutex M</em></p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-1.png" alt="" /></p>

<p>and one <em>callback thread</em> which holds the <em>mutex-AU</em>,</p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-2.png" alt="" /></p>

<p>The deadlock will occur when the <em>callback thread</em> requests the <em>mutex M</em>
(the callback thread is blocked for waiting the <em>mutex M</em>)</p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-3.png" alt="" /></p>

<p>and the <em>thread T</em> requests the <em>mutex-AU</em> to use AudioUnit</p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-4.png" alt="" /></p>
:ET