I"B”<p>You may know how to get n-th Fibonacci number,
but do you know what the fastest way to calculate it is?
<!--read more--></p>

<p>The <em>Fibonacci</em> number is defined as:</p>

<script type="math/tex; mode=display">F_n = F_{n-1} + F_{n-2}</script>

<p>where <script type="math/tex">F_0 = 0, F_1 = 1</script>.</p>

<p>It can be directly written into the following most common code
when we learned what the recursion is:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Recursive: O(2^n)</span>
<span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>However, if you try calculating <script type="math/tex">F_{100}</script>,
then you will wait a long long time to get the result
since it has so many overlapping processes.
For example, if we calculate <script type="math/tex">F_4</script>,
then there are duplicated calculations(overlapping substructures) for <script type="math/tex">F_2</script>:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{matrix}
 & & & & & & & 4 & & & & & \\
 & & & & & & \diagup & & \diagdown & & & & \\
 & & & & & \diagup & & & & \diagdown & & & \\
 & & & & 3 & & & & & & 2 & & \\
 & & & \diagup & & \diagdown & & & & \diagup & & \diagdown & \\
 & & 2 & & & & 1 & & 1 & & & & 0 \\
 & \diagup & & \diagdown & & & & & & & & & \\
 1 & & & & 0 & & & & & & & &
\end{matrix} %]]></script>

<p>The larger <script type="math/tex">n</script> is, the more overlapping processes we have.
As a result, the time-complexity is <script type="math/tex">O(2^n)</script>.</p>

<h3 id="memoization">Memoization</h3>

<p>To avoid that, we can use a <strong>cache</strong> to save all the results
and check it first before any calculation,
so all the <script type="math/tex">F_k</script> we need, for <script type="math/tex">k \in [0, n]</script>,
will be computed just once.
Therefore, the time complexity can be shorten to <script type="math/tex">O(n)</script>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Recursive with memoization: O(n)</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">mem</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span> <span class="c1">// F(k) = mem[k], F(0) = 0, F(1) = 1.</span>
<span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">mem</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// if n is not calculated yet</span>
    <span class="n">mem</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">mem</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="dynamic-programming">Dynamic programming</h3>

<p>The above implementation needs extra space to save the results,
and pay time for memory allocation.
If we iteratively calculate <script type="math/tex">F_n</script>
from <script type="math/tex">F_0, F_1</script> to <script type="math/tex">F_2</script>, <script type="math/tex">F_3</script>, â€¦ then we can get <script type="math/tex">F_n</script>
without extra memory:</p>

<p>The above implementation needs extra space to save the results,
and pay time for memory allocation.
If we iteratively calculate <script type="math/tex">F_n</script>
from <script type="math/tex">F_0, F_1</script> to <script type="math/tex">F_2</script>, <script type="math/tex">F_3</script>, â€¦,
to <script type="math/tex">F_{n-1}</script>, <script type="math/tex">F_n</script> or <script type="math/tex">F_n</script>, <script type="math/tex">F_{n+1}</script>
then we can use only three or four variables to get <script type="math/tex">F_n</script>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Dynamic programming: O(n)</span>
<span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// a = F(k), b = F(k+1), k = 0 now.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// loop k from 1 to n.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// a = F(k+1), b = F(k)</span>
    <span class="n">b</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// b = F(k) + F(k+1) = F(k+2)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>or</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Dynamic programming: O(n)</span>
<span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// a = F(0), b = F(1)</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// run if n &gt;= 2</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// sum = F(i+1)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>       <span class="c1">// a = F(i)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>     <span class="c1">// b = F(i+1)</span>
  <span class="p">}</span>
  <span class="c1">// Now, i = n, sum = F(n), a = F(n-1), b = F(n)</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>They also run in <script type="math/tex">O(n)</script> with less memory consumption
than <em>memoization</em> approach.
Furthermore, they avoid the memory overhead for the <em>activation records</em>
on the <em>stack segment/space</em> for the recursions.
(The recursion will call itself multiple times,
so it will push multiple <em>activation records</em> for the same function itself,
with different arguments, into the <em>stack segment/space</em>
of the process loading the program.)</p>

<h3 id="closed-form">Closed-form</h3>

<p>In fact, the <em>Fibonacci</em> number can be calculated by the following formula:</p>

<script type="math/tex; mode=display">F_n = \frac{1}{\sqrt{5}} \cdot [ (\frac{1 + \sqrt{5}}{2})^n -  (\frac{1 - \sqrt{5}}{2})^n ]</script>

<p>(Please read
<!-- [this post](/post/closed-form-for-the-fibonacci-sequence) -->
<a href="https://chunminchang.github.io/blog/post/closed-form-for-the-fibonacci-sequence">this post</a>
to know how itâ€™s derived.)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// closed-form: O(log(n))</span>
<span class="c1">//   Theoretically, the power of n could be done in O(log(n)), but it's</span>
<span class="c1">//   complicated to calculate the floating numbers.</span>
<span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// double sqrt5 = sqrt((double)5);</span>
  <span class="kt">double</span> <span class="n">sqrt5</span> <span class="o">=</span> <span class="mf">2.2360679775</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">pow</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sqrt5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">pow</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sqrt5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">sqrt5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Its time-complexity depends on how the power of <script type="math/tex">n</script> is calculated.
It could be done in <script type="math/tex">O(\log n)</script> time(we will explain it below).
However, the floating point operations limit the calculable number of <script type="math/tex">n</script>,
and it might block the performance.</p>

<h3 id="matrix-algebra">Matrix Algebra</h3>

<p>The <em>Fibonacci</em> numbers can be written into the following matrix:</p>

<script type="math/tex; mode=display">% <![CDATA[
\vec{F_n} =
\begin{bmatrix} F_n \\ F_{F - 1} \end{bmatrix}
=
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_{n - 1} \\ F_{n - 2} \end{bmatrix} %]]></script>

<p>, so it could be easily expanded by the same rule:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
&=
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_n & F_{n - 1} \\ F_{n - 1} & F_{n - 2} \end{bmatrix}
\\
&=
{\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^2
\cdot
\begin{bmatrix} F_{n - 1} & F_{n - 2} \\ F_{n - 2} & F_{n - 3} \end{bmatrix}
\\
\vdots
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} F_2 & F_1 \\ F_1 & F_0 \end{bmatrix}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\end{align} %]]></script>

<p>(Please read
<!-- [this post](/post/matrix-difference-equation-for-fibonacci-sequence) -->
<a href="https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence">this post</a>
for more discussion.)</p>

<p>That is, the <em>Fibonacci</em> matrix turns into a perfect power.
Applying
<!-- [exponentiation by squaring](/post/exponentiation-by-squaring) -->
<a href="https://chunminchang.github.io/blog/post/exponentiation-by-squaring">exponentiation by squaring</a>
:</p>

<script type="math/tex; mode=display">% <![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  & \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, & \text{if $n$ is odd}
\end{cases} %]]></script>

<p>, we could implement the above idea to:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Power by matrix exponentiation: O(log(n))</span>
<span class="c1">// Matrix A:</span>
<span class="c1">//  &lt;---  cols: n  ---&gt;</span>
<span class="c1">// +-                 -+</span>
<span class="c1">// | A11, A12, ... A1n |   ^</span>
<span class="c1">// | A21, A22, ... A2n |   |</span>
<span class="c1">// | ...               | rows: m</span>
<span class="c1">// | ...               |   |</span>
<span class="c1">// | Am1, Am2, ... Amn |   v</span>
<span class="c1">// +-                 -+</span>
<span class="k">class</span> <span class="nc">Matrix</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">rows</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cols</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">data</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>

  <span class="n">Matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">rows</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cols</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">cols</span><span class="p">);</span>
    <span class="n">data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">cols</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Matrix</span><span class="p">()</span>
  <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">Read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; m)</span>
  <span class="c1">// {</span>
  <span class="c1">//   for (unsigned int i = 0; i &lt; m.rows; ++i) {</span>
  <span class="c1">//     for (unsigned int j = 0; j &lt; m.cols; ++j) {</span>
  <span class="c1">//       os &lt;&lt; m.data[i][j] &lt;&lt; " ";</span>
  <span class="c1">//     }</span>
  <span class="c1">//     os &lt;&lt; std::endl;</span>
  <span class="c1">//   }</span>
  <span class="c1">//   return os;</span>
  <span class="c1">// }</span>

  <span class="n">Matrix</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">cols</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span> <span class="c1">// Check if they can be multiplied.</span>

    <span class="n">Matrix</span> <span class="n">z</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">z</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Calculate the power by fast doubling:</span>
  <span class="c1">//   k ^ n = (k^2) ^ (n/2)          , if n is even</span>
  <span class="c1">//        or k * (k^2) ^ ((k-1)/2)  , if n is odd</span>
  <span class="n">Matrix</span> <span class="n">pow</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">k</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// Copy constructor = Matrix x(rows, cols, data);</span>
    <span class="n">Matrix</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="cm">/*n % 2*/</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
      <span class="cm">/*n /= 2*/</span><span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Matrix</span> <span class="n">Identity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">z</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">z</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The Fibonacci matrix can be written into the following equation:</span>
<span class="c1">// +-             -+   +-    -+^n</span>
<span class="c1">// | F(n+1)   F(n) |   | 1  1 |</span>
<span class="c1">// |               | = |      |</span>
<span class="c1">// | F(n)   F(n-1) |   | 1  0 |</span>
<span class="c1">// +-             -+   +-    -+</span>
<span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Matrix</span> <span class="n">F</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="p">}</span> <span class="p">};</span>

  <span class="c1">// Using F.data[0][1] since n might be 0.</span>
  <span class="c1">// (we need to power by n - 1 if we return F.data[0][0].)</span>
  <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">pow</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">F</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Its time-complexity is <script type="math/tex">O(\log n)</script> by halving and halving.
Without the floating point operations,
the <script type="math/tex">n</script> could be larger than using the <em>closed-form</em> approach.</p>

<p>To make it faster, you can use native array instead of <code class="highlighter-rouge">std::vector</code>,
but you need to manage the memory usage by yourself.
Please read
<!-- [this post](/post/matrix-difference-equation-for-fibonacci-sequence) -->
<a href="https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence">this post</a>
to know how to do it.</p>

<h3 id="fast-doubling">Fast doubling</h3>

<p>The following equations:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
F_{2n+1} &= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]></script>

<p>can be derived by applying <script type="math/tex">2n</script> to the above <em>Fibonacci</em> matrix:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\begin{bmatrix} F_{2n+1} & F_{2n} \\ F_{2n} & F_{2n - 1} \end{bmatrix}
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{2n}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\cdot
{\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\\
&= \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
\cdot \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
\\
&=
\begin{bmatrix}
  {F_{n+1}}^2 + {F_n}^2 & F_n \cdot (F_{n+1} + F_{n-1}) \\
  F_n \cdot (F_{n+1} + F_{n-1}) & {F_n}^2 + {F_{n-1}}^2
\end{bmatrix}
\end{align} %]]></script>

<p>Hence, we could calculate <script type="math/tex">F_n</script> by:</p>

<script type="math/tex; mode=display">% <![CDATA[
F_n =
\begin{cases}
F_{2n'},  & \text{if $n$ is even} \\
F_{2n'+1}, & \text{if $n$ is odd}
\end{cases} %]]></script>

<p>As a consequence, we could use <script type="math/tex">F_{n'}, F_{n' + 1}</script>
to compute <script type="math/tex">F_n</script> by the following program:
(Please read
<!-- [this post](/post/calculating-fibonacci-numbers-by-fast-doubling) -->
<a href="https://chunminchang.github.io/blog/post/calculating-fibonacci-numbers-by-fast-doubling">this post</a>
to know how the code is derived.)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The position of the highest bit of n.</span>
  <span class="c1">// So we need to loop `h` times to get the answer.</span>
  <span class="c1">// Example: n = (Dec)50 = (Bin)00110010, then h = 6.</span>
  <span class="c1">//                               ^ 6th bit from right side</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">++</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1</span>
  <span class="c1">// There is only one `1` in the bits of `mask`. The `1`'s position is same as</span>
  <span class="c1">// the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right</span>
  <span class="c1">// iteratively to do `AND` operation with `n` to check `n / 2^j` is odd</span>
  <span class="c1">// or even.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="n">mask</span> <span class="p">;</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Run h times!</span>
    <span class="c1">// Let j = h-i (looping from i = 1 to i = h),</span>
    <span class="c1">// n_j = floor(n / 2^j) = n &gt;&gt; j (n_j = n when j = 0), k = floor(n_j / 2),</span>
    <span class="c1">// then a = F(k), b = F(k+1) now.</span>
    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) â€“ F(k) ]</span>
    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j) = F(2k + 1)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        <span class="c1">// n_j is even: k = n_j/2 =&gt; n_j = 2k</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>        <span class="c1">//   F(n_j) = F(2k)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j + 1) = F(2k + 1)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Its time-complexity is also <script type="math/tex">O(\log n)</script> by halving and halving.
In contrast to <em>matrix algebra</em> approach,
there is no need for using matrix
that contains the duplicated <script type="math/tex">F_k</script>,
so it will be faster.</p>

<h3 id="performance">Performance</h3>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th><script type="math/tex">F_{45}</script></th>
      <th><script type="math/tex">F_{13100}</script></th>
      <th><script type="math/tex">F_{13500}</script></th>
      <th><script type="math/tex">F_{29108}</script></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Recursive</td>
      <td>7440.61</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Memoization</td>
      <td>0.034841</td>
      <td>3.03045</td>
      <td>3.05931</td>
      <td>6.10806</td>
    </tr>
    <tr>
      <td>Dynamic programming</td>
      <td>0.000508</td>
      <td>0.052462</td>
      <td>0.05395</td>
      <td>0.1069</td>
    </tr>
    <tr>
      <td>Closed-form</td>
      <td>0.030075</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Matrix Algebra</td>
      <td>0.02013</td>
      <td>0.052985</td>
      <td>0.052427</td>
      <td>0.050423</td>
    </tr>
    <tr>
      <td>Fast doubling</td>
      <td>0.000446</td>
      <td>0.000737</td>
      <td>0.000785</td>
      <td>0.000724</td>
    </tr>
  </tbody>
</table>

<p>The above results are the time in <em>millisecond</em> for calculating <script type="math/tex">F_n</script>.
It will take too long time to get the results from the <em>recursive</em> approach,
so we skip it.
The <em>closed-form</em> approach is also ignored
since the floating point operations only work
when <script type="math/tex">n \leq 97</script> in above implementation.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Although the performance is platform-dependent,
it still indicates that:</p>

<ul>
  <li>The <em>fast doubling</em> approach is always the fastest way
and its performance is far far better than others.</li>
  <li>The <em>dynamic programming</em> approach is faster than <em>matrix algebra</em> one
when <script type="math/tex">n</script> is small (<script type="math/tex">n \leq 13000</script> here),
but slower when <script type="math/tex">n</script> is large.</li>
  <li>Therefore, if you are pretty sure you have a small <script type="math/tex">n</script>,
and the bottleneck of your algorithm doesnâ€™t depend on
the <em>Fibonacci</em> calculation, then <em>dynamic programming</em> is acceptable
and itâ€™s easier to implement.</li>
</ul>

<p>This post is the end of my journey for the <em>Fibonacci</em> calculation.
Hope you enjoyed.
All the above code are uploaded to <a href="https://gist.github.com/ChunMinChang/b6325c148e8aff15b6e72dcac0aa904e" title="Ways to calculate Fibonacci">gist here</a>.
Please clone them to play with it.</p>

<p>I will start another journey for other interesting topics soon.
Stay tuned!</p>

:ET