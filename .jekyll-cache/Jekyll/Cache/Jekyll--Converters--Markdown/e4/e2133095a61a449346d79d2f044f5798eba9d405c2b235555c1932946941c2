I"ê<h1 id="how-to-avoid-duplicatesymbols-when-compiling">How to avoid duplicateÂ symbols when compiling</h1>

<p>The error: <code class="highlighter-rouge">duplicateÂ symbolÂ forÂ architectureÂ x86_64</code> will be prompted
if the following <a href="https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276" title="gist">files</a> are compiled.</p>

<ul>
  <li>makefile</li>
</ul>
<noscript><pre>CXX=g++
CFLAGS=-Wall
EXEC=run

all: bye.o hello.o
	$(CXX) $(CFLAGS) main.cpp bye.o hello.o -o $(EXEC)

bye.o: bye.cpp
	$(CXX) -c $(CFLAGS) bye.cpp

hello.o: hello.cpp
	$(CXX) -c $(CFLAGS) hello.cpp

clean:
	rm $(EXEC) *.o
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=makefile"> </script>

<ul>
  <li>main.cpp</li>
</ul>
<noscript><pre>#include &quot;bye.h&quot;
#include &quot;hello.h&quot;

int main()
{
  SayHello();
  SayBye();
  return 0;
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=main.cpp"> </script>

<ul>
  <li>utils.h</li>
</ul>
<noscript><pre>#ifndef UTILS_H
#define UTILS_H

#include &lt;iostream&gt;
#include &lt;string&gt;

void LOG(std::string s)
{
  std::cout &lt;&lt; s &lt;&lt; std::endl;
}

#endif /* UTILS_H */
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=utils.h"> </script>

<ul>
  <li>hello.h</li>
</ul>
<noscript><pre>#ifndef HELLO_H
#define HELLO_H

void SayHello();

#endif /* HELLO_H */
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=hello.h"> </script>

<ul>
  <li>hello.cpp</li>
</ul>
<noscript><pre>#include &quot;hello.h&quot;
#include &quot;utils.h&quot;

void SayHello()
{
  LOG(&quot;Hello&quot;);
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=hello.cpp"> </script>

<ul>
  <li>bye.h</li>
</ul>
<noscript><pre>#ifndef BYE_H
#define BYE_H

void SayBye();

#endif /* BYE_H */
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=bye.h"> </script>

<ul>
  <li>bye.cpp</li>
</ul>
<noscript><pre>#include &quot;bye.h&quot;
#include &quot;utils.h&quot;

void SayBye()
{
  LOG(&quot;Goodbye&quot;);
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=bye.cpp"> </script>

<p>You will see the <code class="highlighter-rouge">duplicateÂ symbolÂ forÂ architectureÂ x86_64</code> error
when you compile those files.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$Â </span>make
g++Â -cÂ -WallÂ bye.cpp
g++Â -cÂ -WallÂ hello.cpp
g++Â -WallÂ main.cppÂ bye.oÂ hello.oÂ -oÂ run
duplicateÂ symbolÂ __Z3LOGNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEÂ in:
Â Â Â Â bye.o
Â Â Â Â hello.o
ld:Â 1Â duplicateÂ symbolÂ forÂ architectureÂ x86_64
clang:Â error:Â linkerÂ commandÂ failedÂ withÂ exitÂ codeÂ 1Â <span class="o">(</span>useÂ -vÂ toÂ seeÂ invocation<span class="o">)</span>
make:Â <span class="k">***</span>Â [all]Â ErrorÂ 1
</code></pre></div></div>

<p>The reason is that we include the shared header(<code class="highlighter-rouge">utils.h</code>)
into different files(<code class="highlighter-rouge">bye.cpp</code> and <code class="highlighter-rouge">hello.cpp</code>),
and compile those files into different libraries(<code class="highlighter-rouge">bye.o</code> and <code class="highlighter-rouge">hello.o</code>),
so the functions in the shared header(<code class="highlighter-rouge">LOG</code>)
duplicate in those different libraries.</p>

<p>Thus, when we try using those different libraries(<code class="highlighter-rouge">bye.o</code> and <code class="highlighter-rouge">hello.o</code>)
at the same time, there are duplicated symbols for functions(<code class="highlighter-rouge">LOG</code>)
included from the shared header(<code class="highlighter-rouge">utils.h</code>).
The program has no idea about which one it should call
among those duplicated symbols.</p>

<h2 id="solution-1-using-macros-instead-of-functions">Solution 1: Using macros instead of functions</h2>
<p>The macro is only textual substitution that expanded by the preprocessor,
so there is no symbol generated.</p>

<p>You can replace function <code class="highlighter-rouge">LOG</code> by</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define LOG(s) (std::cout &lt;&lt; s &lt;&lt; std::endl)
</span></code></pre></div></div>

<p>Then the <code class="highlighter-rouge">SayBye()</code> will be expanded into:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">SayBye</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Goodbye"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can run: <code class="highlighter-rouge">$ g++ -E &lt;file_name&gt;.cpp</code> to watch
and confirm the preprocessorâ€™s output.</p>

<h2 id="solution-2-make-functions-inline">Solution 2: Make functions <strong>inline</strong></h2>
<p>It works almost same as macro.
Inline functions are actual functions
whose copy of the function body are injected directly into
each place the function is called.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">LOG</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The insertion occurs only if
the compilerâ€™s cost/benefit analysis shows it to be profitable.
Same as the macros, inline expansion eliminates
the overhead associated with function calls.</p>

<p>Inline functions are parsed by the compiler,
whereas macros are expanded by the preprocessor.
The preprocessor macros are just substitution patterns in code
before the compilation,
so there is no <strong>type-checking</strong> at that time.
While inline functions are actual functions, so compiler can keep an eye on
type-checking issues to help debugging.</p>

<p>See <a href="https://chunminchang.gitbooks.io/cplusplus-learning-note/content/Appendix/preprocessor_macros_vs_inline_functions.html#inline-functions" title="Inline functions">here</a> for more details.</p>

<h2 id="solution-3-using-static-to-make-functions-local-in-each-file">Solution 3: Using <strong>static</strong> to make functions local in each file</h2>
<p>Since their states are <strong>not</strong> sharable,
they should <strong>not</strong> visible across each other.
Thus, the generated symbols are also local in each file.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">LOG</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

:ET