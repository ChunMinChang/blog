<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-08-31T16:43:45+08:00</updated><id>http://localhost:4000//</id><title type="html">Peak Up</title><subtitle>everyday surpass myself</subtitle><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><entry><title type="html">Matrix Difference Equation for Fibonacci Sequence</title><link href="http://localhost:4000/post/matrix-difference-equation-for-fibonacci-sequence" rel="alternate" type="text/html" title="Matrix Difference Equation for Fibonacci Sequence" /><published>2017-08-22T00:00:00+08:00</published><updated>2017-08-22T00:00:00+08:00</updated><id>http://localhost:4000/post/matrix-difference-equation-for-fibonacci-sequence</id><content type="html" xml:base="http://localhost:4000/post/matrix-difference-equation-for-fibonacci-sequence">&lt;h2 id=&quot;recurrence-relation&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot; title=&quot;Recurrence relation&quot;&gt;Recurrence relation&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Suppose we have a difference equation defined by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_n = a \cdot x_{n - 1} + b \cdot x_{n - 2}&lt;/script&gt;

&lt;p&gt;Then,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_n &amp;= a \cdot x_{n - 1} + b \cdot x_{n - 2}
\\
x_{n - 1} &amp;= 1 \cdot x_{n - 1} + 0 \cdot x_{n - 2}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;could be written into a matrix form(&lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_difference_equation&quot; title=&quot;Matrix difference equation&quot;&gt;&lt;em&gt;matrix difference equation&lt;/em&gt;&lt;/a&gt;):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\vec{x_n} =
\begin{bmatrix} x_n \\ x_{n - 1} \end{bmatrix}
=
\begin{bmatrix} a &amp; b \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} x_{n - 1} \\ x_{n - 2} \end{bmatrix}
=
S \cdot \vec{x_{n-1}} %]]&gt;&lt;/script&gt;

&lt;p&gt;Since &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; can transit the state from &lt;script type=&quot;math/tex&quot;&gt;\vec{x_{n-1}}&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\vec{x_n}&lt;/script&gt;,
the state vector can be expanded by adding any pair &lt;script type=&quot;math/tex&quot;&gt;\vec{x_{t-1}}, \vec{x_t}&lt;/script&gt;
to the above equation.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_t, x_n &amp;= a \cdot x_{t - 1} + b \cdot x_{t - 2}, a \cdot x_{n - 1} + b \cdot x_{n - 2}
\\
x_{t - 1}, x_{n - 1} &amp;= 1 \cdot x_{t - 1} + 0 \cdot x_{t - 2}, 1 \cdot x_{n - 1} + 0 \cdot x_{n - 2}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;can be written into&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix} x_t &amp; x_n \\ x_{t - 1} &amp; x_{n - 1} \end{bmatrix}
=
\begin{bmatrix} a &amp; b \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} x_{t - 1} &amp; x_{n - 1} \\ x_{t - 2} &amp; x_{n - 2} \end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;In fact, this can be generalized.
Given &lt;script type=&quot;math/tex&quot;&gt;y_n&lt;/script&gt; by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_n = c_{n - 1} \cdot y_{n - 1} +
      c_{n - 2} \cdot y_{n - 2} +
      \cdots +
      c_0 \cdot y_0&lt;/script&gt;

&lt;p&gt;, where &lt;script type=&quot;math/tex&quot;&gt;c_k&lt;/script&gt; is constant and &lt;script type=&quot;math/tex&quot;&gt;k \in [0, n-1]&lt;/script&gt; is a integer.&lt;/p&gt;

&lt;p&gt;then we can rewritten the equations into:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\vec{y_n} =
\begin{bmatrix}
  y_n \\
  y_{n - 1} \\
  \vdots \\
  y_1
\end{bmatrix}
=
\begin{bmatrix}
  c_{n - 1} &amp; c_{n - 2} &amp; \cdots &amp; c_1 &amp; c_0 \\
  1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 \\
  \vdots \\
  0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0
\end{bmatrix}
\cdot
\begin{bmatrix}
  y_{n - 1} \\
  y_{n - 2} \\
  \vdots \\
  y_0
\end{bmatrix}
= C \cdot\ \vec{y_{n - 1}} %]]&gt;&lt;/script&gt;

&lt;p&gt;and we could expand the matrix to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
  y_{2n - 1} &amp; \cdots &amp; y_{n + 1} &amp; y_n \\
  y_{2n - 2} &amp; \cdots &amp; y_n &amp; y_{n - 1} \\
  \vdots \\
  y_n &amp; \cdots &amp; y_2 &amp; y_1
\end{bmatrix}
=
\begin{bmatrix}
  c_{n - 1} &amp; c_{n - 2} &amp; \cdots &amp; c_1 &amp; c_0 \\
  1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 \\
  \vdots \\
  0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0
\end{bmatrix}
\cdot
\begin{bmatrix}
  y_{2n - 2} &amp; \cdots &amp; y_n &amp; y_{n - 1} \\
  y_{2n - 3} &amp; \cdots &amp; y_{n - 1} &amp; y_{n - 2} \\
  \vdots \\
  y_{n - 1} &amp; \cdots &amp; y_1 &amp; y_0
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;fibonacci-sequence&quot;&gt;Fibonacci Sequence&lt;/h2&gt;

&lt;p&gt;Fibonacci number is defined by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_n = F_{n - 1} + F_{n - 2}, \text{where } F_0 = 0 \text{ and } F_1 = 0&lt;/script&gt;

&lt;p&gt;Obviously, &lt;em&gt;Fibonacci&lt;/em&gt; sequence is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot; title=&quot;Recurrence relation&quot;&gt;&lt;em&gt;difference equation&lt;/em&gt;&lt;/a&gt;
(&lt;script type=&quot;math/tex&quot;&gt;a = b = 1&lt;/script&gt; in above example) and it could be written in:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\vec{F_n} =
\begin{bmatrix} F_n \\ F_{F - 1} \end{bmatrix}
=
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_{n - 1} \\ F_{n - 2} \end{bmatrix}
=
S \cdot \vec{F_{n-1}} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;matrix-form&quot;&gt;Matrix Form&lt;/h3&gt;

&lt;p&gt;If we expand the &lt;script type=&quot;math/tex&quot;&gt;\vec{F_n}&lt;/script&gt; by taking &lt;script type=&quot;math/tex&quot;&gt;t = n + 1&lt;/script&gt; in above example,
then&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
&amp;=
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_n &amp; F_{n - 1} \\ F_{n - 1} &amp; F_{n - 2} \end{bmatrix}
\\
&amp;=
{\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^2
\cdot
\begin{bmatrix} F_{n - 1} &amp; F_{n - 2} \\ F_{n - 2} &amp; F_{n - 3} \end{bmatrix}
\\
\vdots
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} F_2 &amp; F_1 \\ F_1 &amp; F_0 \end{bmatrix}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\end{align} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;computing-fibonacci-number-by-exponentiation&quot;&gt;Computing &lt;em&gt;Fibonacci&lt;/em&gt; number by exponentiation&lt;/h4&gt;
&lt;p&gt;By the above formula, the &lt;em&gt;Fibonacci&lt;/em&gt; number &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;
can be calculated in &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt;.
The key is to compute the exponentiation by squaring.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  &amp; \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;I explained how to do it in my &lt;a href=&quot;/post/exponentiation-by-squaring&quot;&gt;last post&lt;/a&gt;.
Please read it if you need.&lt;/p&gt;

&lt;p&gt;As a result, we can compute &lt;em&gt;Fibonacci&lt;/em&gt; number &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; as fellow:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Power by matrix exponentiation: O(log(n))
// Matrix A:
//  &amp;lt;---     n     ---&amp;gt;
// +-                 -+
// | A11, A12, ... A1n | ^
// | A21, A22, ... A2n | |
// | ...               | m
// | ...               | |
// | Am1, Am2, ... Amn | v
// +-                 -+
// could be written into 2D vector like:
// { { A11, A12, ... A1n },
//   { A21, A22, ... A2n },
//   ...
///  { Am1, Am2, ... Amn } }
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Comment the assertion so it will run faster.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// assert(isMatrix(x) &amp;amp;&amp;amp; isMatrix(y)); // Check if the 2D vectors are martix.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// assert(x[0].size() == y.size()); // Check if they can be multiplied.
&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Returns identity matrix with size * size
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Calculate the power by fast doubling:
//   P ^ n = (P ^ 2) ^ (n / 2)            if n is even
//        or P x (P ^ 2) ^ ((n - 1) / 2)  if n is odd
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Comment the assertion so it will run faster.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// assert(isMatrix(x) &amp;amp;&amp;amp; x.size() == x[0].size()); // Check it's square matrix.
&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*n % 2*/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci_matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Using r[0][1] instead of r[0][0] since n might be 0.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// (we need to power by n - 1 if we return r[0][0].)
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// When n = 0, the identity matrix of r[0][1] is 0.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;fast-doubling&quot;&gt;Fast Doubling&lt;/h3&gt;

&lt;p&gt;If we calculate &lt;script type=&quot;math/tex&quot;&gt;F_{2n}&lt;/script&gt; directly, we can get the equation as fellow:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{bmatrix} F_{2n+1} &amp; F_{2n} \\ F_{2n} &amp; F_{2n - 1} \end{bmatrix}
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{2n}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\cdot
{\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\\
&amp;= \begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
\cdot \begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
\\
&amp;=
\begin{bmatrix}
  {F_{n+1}}^2 + {F_n}^2 &amp; F_n \cdot (F_{n+1} + F_{n-1}) \\
  F_n \cdot (F_{n+1} + F_{n-1}) &amp; {F_n}^2 + {F_{n-1}}^2
\end{bmatrix}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, &lt;script type=&quot;math/tex&quot;&gt;F_{2n}, F_{2n + 1}&lt;/script&gt; can be calculated by &lt;script type=&quot;math/tex&quot;&gt;F_n, F_{n+1}&lt;/script&gt; since&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
F_{2n+1} &amp;= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &amp;= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &amp;= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &amp;= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;This two equations help us to calculate &lt;script type=&quot;math/tex&quot;&gt;F_{N}&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;O(\log N)&lt;/script&gt; time,
since &lt;script type=&quot;math/tex&quot;&gt;F_{N}&lt;/script&gt; can be derived from &lt;script type=&quot;math/tex&quot;&gt;F_{2N'}&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;F_{2N' + 1}&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;implementation&quot;&gt;implementation&lt;/h4&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Fast doubling: O(log(n))
//   Using 2n to the Fibonacci matrix above, we can derive that:
//     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]
//     F(2n+1) = F(n+1)^2 + F(n)^2
//     (and F(2n-1) = F(n)^2 + F(n-1)^2)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// When n = 2: k = 1 and we want to use F(k+1) to calculate F(2k),
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// However, F(2k) = F(k+1) = F(2) is unknown then.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0, F(1) = 1.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2) = 1
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The implementation are easy to understand
but it still has a lot of room to improve.
We will discuss it in next post.
Stay tuned!&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Algorithm&quot;, &quot;Math&quot;]" /><category term="Fibonacci" /><summary type="html">Recurrence relation

Suppose we have a difference equation defined by:



Then,



could be written into a matrix form(matrix difference equation):



Since  can transit the state from  to ,
the state vector can be expanded by adding any pair 
to the above equation.

For example,



can be written into



In fact, this can be generalized.
Given  by:



, where  is constant and  is a integer.

then we can rewritten the equations into:



and we could expand the matrix to



Fibonacci Sequence

Fibonacci number is defined by:



Obviously, Fibonacci sequence is a difference equation
( in above example) and it could be written in:



Matrix Form

If we expand the  by taking  in above example,
then



Computing Fibonacci number by exponentiation
By the above formula, the Fibonacci number 
can be calculated in .
The key is to compute the exponentiation by squaring.



I explained how to do it in my last post.
Please read it if you need.

As a result, we can compute Fibonacci number  as fellow:

///////////////////////////////////////////////////////////////////////////////
// Power by matrix exponentiation: O(log(n))
// Matrix A:
//  &amp;lt;---     n     ---&amp;gt;
// +-                 -+
// | A11, A12, ... A1n | ^
// | A21, A22, ... A2n | |
// | ...               | m
// | ...               | |
// | Am1, Am2, ... Amn | v
// +-                 -+
// could be written into 2D vector like:
// { { A11, A12, ... A1n },
//   { A21, A22, ... A2n },
//   ...
///  { Am1, Am2, ... Amn } }
typedef std::vector&amp;lt;std::vector&amp;lt;unsigned int&amp;gt;&amp;gt; Matrix;

bool isMatrix(Matrix&amp;amp; x)
{
  assert(x.size());
  for (unsigned int i = 0 ; i &amp;lt; x.size(); ++i) {
    if (x[i].size() != x[0].size()) {
      return false;
    }
  }
  return true;
}

Matrix mul(Matrix&amp;amp; x, Matrix&amp;amp; y)
{
  // Comment the assertion so it will run faster.
  // assert(isMatrix(x) &amp;amp;&amp;amp; isMatrix(y)); // Check if the 2D vectors are martix.
  // assert(x[0].size() == y.size()); // Check if they can be multiplied.

  Matrix z;
  z.resize(x.size());

  for (unsigned int i = 0 ; i &amp;lt; x.size() ; ++i) {
    z[i].resize(y[0].size());
    for (unsigned int j = 0 ; j &amp;lt; y[0].size(); ++j) {
      for (unsigned int k = 0 ; k &amp;lt; y.size(); ++k) {
        z[i][j] += x[i][k] * y[k][j];
      }
    }
  }

  return z;
}

// Returns identity matrix with size * size
Matrix identity(unsigned int size)
{
  Matrix z;
  z.resize(size);
  for (unsigned int i = 0 ; i &amp;lt; size ; ++i) {
    for (unsigned int j = 0 ; j &amp;lt; size ; ++j) {
      z[i].push_back(i == j);
    }
  }
  return z;
}

// Calculate the power by fast doubling:
//   P ^ n = (P ^ 2) ^ (n / 2)            if n is even
//        or P x (P ^ 2) ^ ((n - 1) / 2)  if n is odd
Matrix pow(Matrix&amp;amp; x, unsigned int n)
{
  // Comment the assertion so it will run faster.
  // assert(isMatrix(x) &amp;amp;&amp;amp; x.size() == x[0].size()); // Check it's square matrix.

  Matrix r = identity(x.size());
  while (n) {
    if (/*n % 2*/ n &amp;amp; 1) {
      r = mul(x, r);
    }
    x = mul(x, x);
    n &amp;gt;&amp;gt;= 1 ;
  }

  return r;
}

// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
uint64_t fibonacci_matrix(unsigned int n)
{
  Matrix r { {1, 1},
             {1, 0} };
  // Using r[0][1] instead of r[0][0] since n might be 0.
  // (we need to power by n - 1 if we return r[0][0].)
  r = pow(r, n); // When n = 0, the identity matrix of r[0][1] is 0.
  return r[0][1];
}



Fast Doubling

If we calculate  directly, we can get the equation as fellow:



Thus,  can be calculated by  since



This two equations help us to calculate  in  time,
since  can be derived from  or .

implementation

///////////////////////////////////////////////////////////////////////////////
// Fast doubling: O(log(n))
//   Using 2n to the Fibonacci matrix above, we can derive that:
//     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]
//     F(2n+1) = F(n+1)^2 + F(n)^2
//     (and F(2n-1) = F(n)^2 + F(n-1)^2)
uint64_t fib(unsigned int n)
{
  // When n = 2: k = 1 and we want to use F(k+1) to calculate F(2k),
  // However, F(2k) = F(k+1) = F(2) is unknown then.
  if (n &amp;lt; 2) {
    return n; // F(0) = 0, F(1) = 1.
  } else if (n == 2) {
    return 1; // F(2) = 1
  }

  unsigned int k = 0;
  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
    k = (n - 1) / 2;
    return fib(k + 1) * fib(k + 1) + fib(k) * fib(k);
  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    k = n / 2;
    return fib(k) * (2 * fib(k + 1) - fib(k));
  }
}


The implementation are easy to understand
but it still has a lot of room to improve.
We will discuss it in next post.
Stay tuned!</summary></entry><entry><title type="html">Exponentiation by squaring</title><link href="http://localhost:4000/post/exponentiation-by-squaring" rel="alternate" type="text/html" title="Exponentiation by squaring" /><published>2017-08-19T00:00:00+08:00</published><updated>2017-08-19T00:00:00+08:00</updated><id>http://localhost:4000/post/exponentiation-by-squaring</id><content type="html" xml:base="http://localhost:4000/post/exponentiation-by-squaring">&lt;p&gt;What is the time complexity of the computation for &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt;?
We might intuitively think it’s &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;.
In fact, it can be done in &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt;
by &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponentiation_by_squaring&quot;&gt;exponentiation by squaring&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The key idea is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
(k^\frac{n}{2})^2,  &amp; \text{if $n$ is even} \\
k \cdot (k^\frac{n-1}{2})^2, &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  &amp; \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;By dividing &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\frac{n}{2}&lt;/script&gt; again and again,
then stop when &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt;,
we could solve &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;recursive-approach&quot;&gt;Recursive approach&lt;/h2&gt;

&lt;p&gt;If we apply the first conversion, we could get the following code:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above program uses two same recursions, &lt;code class=&quot;highlighter-rouge&quot;&gt;... * pow1(...) * pow1(...)&lt;/code&gt;,
as the returned value, so it will duplicate two same stacks.
On the other hand, if we apply the second conversion,
then there is no duplicated stack needed.
It could save almost half computation time of the &lt;code class=&quot;highlighter-rouge&quot;&gt;pow1&lt;/code&gt;
since it only uses half recursions than &lt;code class=&quot;highlighter-rouge&quot;&gt;pow1&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above code still could be simplified.
The result of the division &lt;script type=&quot;math/tex&quot;&gt;y = \frac{x}{2}&lt;/script&gt; is
actually &lt;script type=&quot;math/tex&quot;&gt;y = \lfloor \frac{x}{2} \rfloor&lt;/script&gt; in the world of &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;C++&lt;/em&gt;,
if &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; is an integer.&lt;/p&gt;

&lt;p&gt;That is, if &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is an &lt;strong&gt;odd&lt;/strong&gt; integer,
then the result of &lt;code class=&quot;highlighter-rouge&quot;&gt;n = (n - 1) / 2&lt;/code&gt; is same as &lt;code class=&quot;highlighter-rouge&quot;&gt;n = n / 2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Thus, the code could be simplified as fellow:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// so x = (k^2)^(n/2),      if n is even
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     or (k^2)^((n-1)/2),  if n is odd
&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// so x = k * (k^2)^((n-1)/2)
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Another trick is that We could replace &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b / 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b &amp;gt;&amp;gt; 1&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b % 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b &amp;amp; 0x01&lt;/code&gt;.
(But I guess your compiler might already do that for you.)&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;iterative-approach&quot;&gt;Iterative approach&lt;/h2&gt;
&lt;p&gt;If we could rewrite a recursive algorithm into an iterative version,
it usually run faster.&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is always even, then it’s easy to calculate in a loop.
For example, when &lt;script type=&quot;math/tex&quot;&gt;k = 3, n = 8&lt;/script&gt;, we can calculate &lt;script type=&quot;math/tex&quot;&gt;k^n = 3^8&lt;/script&gt;
by &lt;script type=&quot;math/tex&quot;&gt;3^8 = (3^2)^4 = ((3^2)^2)^2 = (((3^2)^2)^2)^1&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Thus, we can find &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt; by:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1 = 3, n_1 = 8&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = k_1^{n_1}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2 = k_1^2 = 3^2, n_2 = \frac{n_1}{2} = 4&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = k_2^{n_2}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_3 = (k_2)^2 = 3^4, n_3 = \frac{n_2}{2} = 2&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = k_3^{n_3}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_4 = (k_3)^2 = 3^8, n_4 = \frac{n_3}{2} = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = k_4^{n_4}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;n_4 = 1&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;k^n = k_4^{n_4} = k_4 = 3^8&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
On the other hand, if &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is not always even,
then we need to deal with the single leading &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;
in the &lt;script type=&quot;math/tex&quot;&gt;k \cdot (k^2)^\frac{n-1}{2}&lt;/script&gt;,
which will not used to square.
For example, when &lt;script type=&quot;math/tex&quot;&gt;k = 3, n = 7&lt;/script&gt;, we can calculate &lt;script type=&quot;math/tex&quot;&gt;k^n = 3^7&lt;/script&gt;
by &lt;script type=&quot;math/tex&quot;&gt;3 \cdot (3^2)^3 = 3 \cdot (3^2 \cdot ((3^2)^2)^1)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;In this case, we need one more variable &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;
to track the single leading &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;.
That is, we can find &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt; by:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1 = 3, n_1 = 7, r_1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_1 \cdot k_1^{n_1}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2 = k_1^2 = 3^2, n_2 = \frac{n_1 - 1}{2} = 3, r_2 = r_1 \cdot k_1 = 3&lt;/script&gt;,
now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_2 \cdot k_2^{n_2}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_3 = k_2^2 = 3^4, n_3 = \frac{n_2 - 1}{2} = 1, r_3 = r_2 \cdot k_2 = 3^3&lt;/script&gt;,
now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_3 \cdot k_3^{n_3}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;n_3 = 1&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;k^n = r_3 \cdot k_3^{n_3} = 3^3 \cdot 3^4&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Wrapping up the above ideas, we could summarize the following code:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// The remaining part for the squaring.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; is the product of all the single leading &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;.
The loop finishes when &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt; in above code and return &lt;script type=&quot;math/tex&quot;&gt;r \cdot k&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We could see there is a duplicated &lt;code class=&quot;highlighter-rouge&quot;&gt;r * k&lt;/code&gt; in above.
If we keep looping when &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt;, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;r = r * k&lt;/code&gt; is our final answer.
Moreover, when &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt;, the initial &lt;code class=&quot;highlighter-rouge&quot;&gt;r = 1&lt;/code&gt; is also correct,
so the beginning &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; could be saved.
However, we will waste a little time to compute the useless &lt;code class=&quot;highlighter-rouge&quot;&gt;k = k * k&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// The `r` should be the remaining part for the squaring(in pow5).
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// However, we notice that the `r * k` is duplicated in pow5. We will get
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// the answer by `r * k` when n = 1. If we keep looping when n = 1,
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// `r` is our answer. Nevertheless, we will waste time to do `k *= k`
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// when n = 1.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;There is different angle to see the above algorithm.
Actually, we can define &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt; by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
r \cdot (k^2)^\frac{n}{2}, r = 1 &amp; \text{if $n$ is even} \\
r \cdot (k^2)^\frac{n-1}{2}, r = k &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, we could also use &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; to find &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt;.
By the example above when &lt;script type=&quot;math/tex&quot;&gt;k = 3, n = 8&lt;/script&gt;:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1 = 3, n_1 = 8, r_1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_1 \cdot k_1^{n_1}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2 = k_1^2 = 3^2, n_2 = \frac{n_1}{2} = 4, r_2 = r_1 \cdot 1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_2 \cdot k_2^{n_2}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_3 = (k_2)^2 = 3^4, n_3 = \frac{n_2}{2} = 2, r_3 = r_2 \cdot 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_3 \cdot k_3^{n_3}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_4 = (k_3)^2 = 3^8, n_4 = \frac{n_3}{2} = 1, r_4 = r_3 \cdot 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_4 \cdot k_4^{n_4}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_5 = (k_4)^2 = 3^16, n_5 = \frac{n_4 - 1}{2} = 0, r_5 = r_4 \cdot k_4 = 3^8&lt;/script&gt;,
now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_5 \cdot k_5^{n_5}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;n_5 = 0&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;k^n = r_5 = 3^8&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We could see a more general case when &lt;script type=&quot;math/tex&quot;&gt;k = 3, n = 10&lt;/script&gt;:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1 = 3, n_1 = 10, r_1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_1 \cdot k_1^{n_1}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2 = k_1^2 = 3^2, n_2 = \frac{n_1}{2} = 5, r_2 = r_1 \cdot 1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_2 \cdot k_2^{n_2}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_3 = (k_2)^2 = 3^4, n_3 = \frac{n_2 - 1}{2} = 2, r_3 = r_2 \cdot k_2 = 3^2&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_3 \cdot k_3^{n_3}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_4 = (k_3)^2 = 3^8, n_4 = \frac{n_3}{2} = 1, r_4 = r_3 \cdot 1 = 3^2&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n =  r_4 \cdot k_4^{n_4}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_5 = (k_4)^2 = 3^{16}, n_5 = \frac{n_4 - 1}{2} = 0, r_5 = r_4 \cdot k_4 = 3^{10}&lt;/script&gt;,
now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_5 \cdot k_5^{n_5}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;n_5 = 0&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;k^n = r_5 = 3^{10}&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a result, the algorithm is:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// This could be saved!
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Like what we mentioned in recursive part,
If &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is an &lt;strong&gt;odd&lt;/strong&gt; integer,
then the result of &lt;code class=&quot;highlighter-rouge&quot;&gt;n = (n - 1) / 2&lt;/code&gt; is same as &lt;code class=&quot;highlighter-rouge&quot;&gt;n = n / 2&lt;/code&gt;.
nd we can also replace &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b / 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b &amp;gt;&amp;gt; 1&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b % 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b &amp;amp; 0x01&lt;/code&gt;.
Finally, the algorithm can be shorten as:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n % 2
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n = n / 2;
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All the above code are on &lt;a href=&quot;https://gist.github.com/ChunMinChang/9753c72e2441343e14757f5a9ac95a98&quot; title=&quot;Exponentiation by squaring&quot;&gt;gist here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Algorithm&quot;, &quot;Math&quot;]" /><category term="power" /><summary type="html">What is the time complexity of the computation for ?
We might intuitively think it’s .
In fact, it can be done in 
by exponentiation by squaring.

The key idea is:



or



By dividing  to  again and again,
then stop when ,
we could solve  in .

Recursive approach

If we apply the first conversion, we could get the following code:

uint64_t pow1(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  if (n % 2) {
    return k * pow1(k, (n - 1) / 2) * pow1(k, (n - 1) / 2);
  } else {
    return pow1(k, n / 2) * pow1(k, n / 2);
  }
}



The above program uses two same recursions, ... * pow1(...) * pow1(...),
as the returned value, so it will duplicate two same stacks.
On the other hand, if we apply the second conversion,
then there is no duplicated stack needed.
It could save almost half computation time of the pow1
since it only uses half recursions than pow1.

uint64_t pow2(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  if (n % 2) {
    return k * pow2(k * k, (n - 1) / 2);
  } else {
    return pow2(k * k, n / 2);
  }
}



The above code still could be simplified.
The result of the division  is
actually  in the world of C and C++,
if  is an integer.

That is, if n is an odd integer,
then the result of n = (n - 1) / 2 is same as n = n / 2.

Thus, the code could be simplified as fellow:

uint64_t pow3(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  uint64_t x = pow3(k * k, n / 2);
  // so x = (k^2)^(n/2),      if n is even
  //     or (k^2)^((n-1)/2),  if n is odd

  if (n % 2) {
    x = x * k; // so x = k * (k^2)^((n-1)/2)
  }
  return x;
}



Another trick is that We could replace a = b / 2 by a = b &amp;gt;&amp;gt; 1
and a = b % 2 by a = b &amp;amp; 0x01.
(But I guess your compiler might already do that for you.)

uint64_t pow4(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  uint64_t x = pow4(k * k, n &amp;gt;&amp;gt; 1);
  return (n &amp;amp; 1) ? x * k : x;
}



Iterative approach
If we could rewrite a recursive algorithm into an iterative version,
it usually run faster.

If  is always even, then it’s easy to calculate in a loop.
For example, when , we can calculate 
by .

Thus, we can find  by:

  , now 
  , now 
  , now 
  , now 
  , so 



On the other hand, if  is not always even,
then we need to deal with the single leading 
in the ,
which will not used to square.
For example, when , we can calculate 
by .

In this case, we need one more variable 
to track the single leading .
That is, we can find  by:

  , now 
  ,
now 
  ,
now 
  , so 


Wrapping up the above ideas, we could summarize the following code:
uint64_t pow5(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  uint64_t r = 1; // The remaining part for the squaring.
  while (n &amp;gt; 1) {
    if (n % 2) {
      r *= k;
      k *= k;
      n = (n - 1) / 2;
    } else {
      k *= k;
      n = n / 2;
    }
  }

  return r * k;
}



The  is the product of all the single leading .
The loop finishes when  in above code and return .

We could see there is a duplicated r * k in above.
If we keep looping when , then the r = r * k is our final answer.
Moreover, when , the initial r = 1 is also correct,
so the beginning if could be saved.
However, we will waste a little time to compute the useless k = k * k.

uint64_t pow6(unsigned int k, unsigned int n)
{
  // The `r` should be the remaining part for the squaring(in pow5).
  // However, we notice that the `r * k` is duplicated in pow5. We will get
  // the answer by `r * k` when n = 1. If we keep looping when n = 1,
  // `r` is our answer. Nevertheless, we will waste time to do `k *= k`
  // when n = 1.
  uint64_t r = 1;

  while (n) {
    if (n % 2) {
      r *= k;
      k *= k;
      n = (n - 1) / 2;
    } else {
      k *= k;
      n = n / 2;
    }
  }

  return r;
}



There is different angle to see the above algorithm.
Actually, we can define  by:



Thus, we could also use  to find .
By the example above when :

  , now 
  , now 
  , now 
  , now 
  ,
now 
  , so 


We could see a more general case when :

  , now 
  , now 
  , now 
  , now 
  ,
now 
  , so 


As a result, the algorithm is:

uint64_t pow6(unsigned int k, unsigned int n)
{
  uint64_t r = 1;

  while (n) {
    if (n % 2) {
      r *= k;
      k *= k;
      n = (n - 1) / 2;
    } else {
      r *= 1; // This could be saved!
      k *= k;
      n = n / 2;
    }
  }

  return r;
}



Like what we mentioned in recursive part,
If n is an odd integer,
then the result of n = (n - 1) / 2 is same as n = n / 2.
nd we can also replace a = b / 2 by a = b &amp;gt;&amp;gt; 1
and a = b % 2 by a = b &amp;amp; 0x01.
Finally, the algorithm can be shorten as:

uint64_t pow7(unsigned int k, unsigned int n)
{
  uint64_t r = 1;
  while (n) {
    if (n &amp;amp; 1) { // n % 2
      r *= k;
    }
    k *= k;
    n &amp;gt;&amp;gt;= 1; // n = n / 2;
  }

  return r;
}



All the above code are on gist here.</summary></entry><entry><title type="html">Closed Form for the Fibonacci Sequence</title><link href="http://localhost:4000/post/closed-form-for-the-fibonacci-sequence" rel="alternate" type="text/html" title="Closed Form for the Fibonacci Sequence" /><published>2017-08-13T00:00:00+08:00</published><updated>2017-08-13T00:00:00+08:00</updated><id>http://localhost:4000/post/closed-form-for-the-fibonacci-sequence</id><content type="html" xml:base="http://localhost:4000/post/closed-form-for-the-fibonacci-sequence">&lt;p&gt;The &lt;em&gt;Fibonacci&lt;/em&gt; number can be defined as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_n = F_{n-1} + F_{n-2}&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;F_0 = 0, F_1 = 1&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Assume &lt;script type=&quot;math/tex&quot;&gt;F_n = s \cdot r^n&lt;/script&gt;,
then &lt;script type=&quot;math/tex&quot;&gt;F_n = F_{n-1} + F_{n-2}&lt;/script&gt; can be rewritten into:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;s \cdot r^n = s \cdot r^{n-1} + s \cdot r^{n-2}&lt;/script&gt;

&lt;p&gt;Thus,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;s \cdot r^{n-2} \cdot (r^2 - r - 1) = 0&lt;/script&gt;

&lt;p&gt;and &lt;script type=&quot;math/tex&quot;&gt;r = \frac{1\pm \sqrt{5}}{2}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;p = \frac{1 + \sqrt{5}}{2}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;r = \frac{1 - \sqrt{5}}{2}&lt;/script&gt;,
and &lt;script type=&quot;math/tex&quot;&gt;x_k = u \cdot p^k + v \cdot q^k&lt;/script&gt;,
we now show that &lt;script type=&quot;math/tex&quot;&gt;x_k&lt;/script&gt; is also a solution for &lt;script type=&quot;math/tex&quot;&gt;F_k&lt;/script&gt;.
That is, we need to show &lt;script type=&quot;math/tex&quot;&gt;x_k = x_{k-1} + x_{k-2}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_{k-1} + x_{k-2}
&amp;= u \cdot p^{k-1} + v \cdot q^{k-1} + u \cdot p^{k-2} + v \cdot q^{k-2} \\
&amp;= u \cdot p^{k-2} \cdot (1 + p) + v \cdot q^{k-2} \cdot (1 + q) \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Since &lt;script type=&quot;math/tex&quot;&gt;r + 1 = r^2(\text{by } r^2 - r - 1 = 0)&lt;/script&gt;,
we know &lt;script type=&quot;math/tex&quot;&gt;p + 1 = p^2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q + 1 = q^2&lt;/script&gt;
Thus,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_{k-1} + x_{k-2}
&amp;= u \cdot p^{k-2} \cdot (1 + p) + v \cdot q^{k-2} \cdot (1 + q) \\
&amp;= u \cdot p^{k-2} \cdot p^2 + v \cdot q^{k-2} \cdot q^2 \\
&amp;= u \cdot p^k + v \cdot q^k \\
&amp;= x_k
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Next, if we take &lt;script type=&quot;math/tex&quot;&gt;x_k&lt;/script&gt; as our closed form for the &lt;em&gt;Fibonacci&lt;/em&gt; number,
we also need to know what &lt;script type=&quot;math/tex&quot;&gt;u, v&lt;/script&gt; are.
Fortunately, by the definition, we already know &lt;script type=&quot;math/tex&quot;&gt;F_0 = 0, F_1 = 1&lt;/script&gt;,
so&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_0 &amp;= 0 = u \cdot p^0+ v \cdot q^0 = u + v \\
x_1 &amp;= 1 = u \cdot p + v \cdot q
= u \cdot \frac{1 + \sqrt{5}}{2} + v \cdot \frac{1 - \sqrt{5}}{2} \\
\Rightarrow 2 &amp;= u + u \cdot \sqrt{5} + v - v \cdot \sqrt{5} \\
&amp;= (u + v) + \sqrt{5} \cdot (u - v) \\
&amp;= \sqrt{5} \cdot (u - v)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;By &lt;script type=&quot;math/tex&quot;&gt;u + v = 0&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;u - v = \frac{2}{\sqrt{5}}&lt;/script&gt;, we know that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
u &amp;= \frac{1}{\sqrt{5}} \\
v &amp;= \frac{-1}{\sqrt{5}}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;As a result,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_k &amp;= u \cdot p^k + v \cdot q^k \\
&amp;= \frac{1}{\sqrt{5}} \cdot (\frac{1 + \sqrt{5}}{2})^k - \frac{1}{\sqrt{5}} \cdot (\frac{1 - \sqrt{5}}{2})^k \\
&amp;= \frac{1}{\sqrt{5}} \cdot [ (\frac{1 + \sqrt{5}}{2})^k -  (\frac{1 - \sqrt{5}}{2})^k ]
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;graph&quot;&gt;Graph&lt;/h2&gt;
&lt;p&gt;See the online &lt;a href=&quot;https://www.wolframalpha.com/input/?i=(((1%2Bsqrt(5))%2F2)%5Ex+-+((1-sqrt(5))%2F2)%5Ex)%2Fsqrt(5)&quot;&gt;graph here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;questions&quot;&gt;Questions&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Why we assume &lt;script type=&quot;math/tex&quot;&gt;F_n = s \cdot r^n&lt;/script&gt;?&lt;/li&gt;
  &lt;li&gt;Why we use &lt;script type=&quot;math/tex&quot;&gt;F_n = u \cdot p^n + v \cdot q^n&lt;/script&gt;
instead of &lt;script type=&quot;math/tex&quot;&gt;F_n = s \cdot r^n&lt;/script&gt; as our closed form?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;http://math.ucr.edu/~res/math153/history07a.pdf&lt;/li&gt;
  &lt;li&gt;http://gozips.uakron.edu/~crm23/fibonacci/fibonacci.htm&lt;/li&gt;
  &lt;li&gt;https://math.stackexchange.com/questions/65011/prove-this-formula-for-the-fibonacci-sequence&lt;/li&gt;
  &lt;li&gt;http://mathproofs.blogspot.tw/2005/04/nth-term-of-fibonacci-sequence.html&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Math" /><category term="Fibonacci" /><summary type="html">The Fibonacci number can be defined as:



where .

Assume ,
then  can be rewritten into:



Thus,



and 

Let , ,
and ,
we now show that  is also a solution for .
That is, we need to show .

Proof:



Since ,
we know  and 
Thus,



Next, if we take  as our closed form for the Fibonacci number,
we also need to know what  are.
Fortunately, by the definition, we already know ,
so



By  and , we know that



As a result,



Graph
See the online graph here

Questions

  Why we assume ?
  Why we use 
instead of  as our closed form?


References

  http://math.ucr.edu/~res/math153/history07a.pdf
  http://gozips.uakron.edu/~crm23/fibonacci/fibonacci.htm
  https://math.stackexchange.com/questions/65011/prove-this-formula-for-the-fibonacci-sequence
  http://mathproofs.blogspot.tw/2005/04/nth-term-of-fibonacci-sequence.html</summary></entry><entry><title type="html">The Misuse of RefPtr</title><link href="http://localhost:4000/post/the-misuse-of-refptr" rel="alternate" type="text/html" title="The Misuse of RefPtr" /><published>2017-08-08T00:00:00+08:00</published><updated>2017-08-08T00:00:00+08:00</updated><id>http://localhost:4000/post/the-misuse-of-refptr</id><content type="html" xml:base="http://localhost:4000/post/the-misuse-of-refptr">&lt;p&gt;In &lt;a href=&quot;/post/refptr-v-s-shared-ptr&quot;&gt;last post&lt;/a&gt;,
I introduced the &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt; that can keep tracking the references to the
object &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; and the references are counted by object &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;Today, I will note my misuse of it several weeks ago.
This is also why I want to write the posts about &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-behavior-i-want&quot;&gt;What behavior I want&lt;/h2&gt;
&lt;p&gt;The following behavior is what I want when I was implementing one patch
for Firefox:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A list containing all of the solders.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Put the `s` into the list.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The `s` is destroyed, so it should be removed from the list now.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and we will put the &lt;code class=&quot;highlighter-rouge&quot;&gt;Solder&lt;/code&gt; instance into the &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt; when
it’s created and remove it when it’s destroyed.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;why-it-doesnt-work&quot;&gt;Why it doesn’t work&lt;/h2&gt;
&lt;p&gt;This is a wrong pattern to meet our expectation.
The solders in the list will &lt;strong&gt;only&lt;/strong&gt; be destroyed and removed from the list
when the whole program is ended.
The solders are only removed from the list in its deconstructor.
However, whenever the &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Solder&amp;gt; s(new Solder())&lt;/code&gt;
is deconstructed (by &lt;code class=&quot;highlighter-rouge&quot;&gt;~RefPtr&lt;/code&gt;) in the main function,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;~Solder()&lt;/code&gt; won’t be called
since there must be one another &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Solder&amp;gt; some&lt;/code&gt; in the list
referencing the solder.
Thus, the &lt;code class=&quot;highlighter-rouge&quot;&gt;~Solder()&lt;/code&gt; is only be called
when the element in the list is decontructed.&lt;/p&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample code&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;// $ g++ test.cpp --std=c++11
#include &amp;quot;RefPtr.h&amp;quot;
#include &amp;lt;algorithm&amp;gt;  // std::remove
#include &amp;lt;cassert&amp;gt;    // assert
#include &amp;lt;iostream&amp;gt;   // std::cout, std::endl
#include &amp;lt;vector&amp;gt;     // std::vector

///////////////////////////////////////////////////////////////////////////////
// Solder Interface
class Solder: public ReferenceCount
{
public:
  Solder(int n);
  ~Solder();
  int CountOff(); // Report the number.

private:
  int number;
};

///////////////////////////////////////////////////////////////////////////////
// Squad Interface
class Squad
{
public:
  static void Add(Solder* s);
  static void Remove(Solder* s);
  static void CountOff(); // Call all of the solders.
  static unsigned int Size();
private:
  static std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; members;
};

///////////////////////////////////////////////////////////////////////////////
// Solder Implementation
Solder::Solder(int n)
  : number(n)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is created.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Add(this);
}

Solder::~Solder()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Remove(this);
}

int
Solder::CountOff()
{
  return number;
}

///////////////////////////////////////////////////////////////////////////////
// Squad Implementation
std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; Squad::members;

/* static */ void
Squad::Add(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Add Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; to members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.push_back(s);
}

/* static */ void
Squad::Remove(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Remove Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; from members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.erase(std::remove(members.begin(), members.end(), s), members.end());
}

/* static */ void
Squad::CountOff()
{
  for (auto&amp;amp; m: members) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; m-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; is here!&amp;quot; &amp;lt;&amp;lt; std::endl;
  }
}

/* static */ unsigned int
Squad::Size()
{
  return members.size();
}

///////////////////////////////////////////////////////////////////////////////
// *** Wrong example to use RefPtr ***
//   We will put the Solder instances into the squad when they are created,
//   and remove the instances from the squad when they are destroyed.
//   We expect the following behavior.
//
//   List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l;
//   {
//     RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put s into the list
//   }
//   // s is destroyed and removed from the list, so list is empty now.
int main()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Creating a solder and put it into squad.&amp;quot; &amp;lt;&amp;lt; std::endl;

  {
    RefPtr&amp;lt;Solder&amp;gt; s(new Solder(1));
    Squad::CountOff();
    // There should be one solder in the squad now.
    assert(Squad::Size() == 1 &amp;amp;&amp;amp; s-&amp;gt;GetCount() == 2);
  }

  std::cout &amp;lt;&amp;lt; &amp;quot;Solder should be removed from squad and destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  // In our mind, we expect there is no solder in the squad now.
  assert(Squad::Size() == 0); // Comment this to check the below one.
  // But it&amp;#39;s wrong. The correct status of the memebers is:
  // assert(Squad::Size() == 1);

  // In our expectation, we expect the solder 1 will be destroyed and removed
  // from the sqaud when the program is running out of &amp;#39;}&amp;#39; above.
  // At that time, the ~RefPtr() will be called and check whether we need to
  // release the solder 1. However, since we still have a reference to solder 1
  // in the members list of the squal, the reference count to solder 1 is not 0.
  // Therefore, it won&amp;#39;t be removed!

  // Actually,
  // ------------------------------------
  // List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; list
  // Solder()
  // {
  //   Add &amp;#39;this&amp;#39; into the list
  // }
  // ~Solder()
  // {
  //   Remove &amp;#39;this&amp;#39; from the list
  // }
  // ------------------------------------
  // is a wrong pattern to meet our expectation.
  // The solders in the list will only be destroyed and removed from the list
  // when the whole program is ended. The solders are only removed from
  // the list in its deconstructor. However, whenever the
  // RefPtr&amp;lt;Solder&amp;gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,
  // the ~Solder() won&amp;#39;t be called since there must be one another
  // RefPtr&amp;lt;Solder&amp;gt; in the list referencing the solder.
  // Thus, the ~Solder() is only be called when the element in the list is
  // decontructed.

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1.js?file=misuse.cpp&quot;&gt; &lt;/script&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><category term="Firefox" /><summary type="html">In last post,
I introduced the RefPtr&amp;lt;T&amp;gt; that can keep tracking the references to the
object T and the references are counted by object T itself.

Today, I will note my misuse of it several weeks ago.
This is also why I want to write the posts about RefPtr&amp;lt;T&amp;gt;.

What behavior I want
The following behavior is what I want when I was implementing one patch
for Firefox:

List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l; // A list containing all of the solders.
{
  RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put the `s` into the list.
}
// The `s` is destroyed, so it should be removed from the list now.



and we will put the Solder instance into the l when
it’s created and remove it when it’s destroyed.

Solder()
{
  Add this into `l`
}
~Solder()
{
  Remove this from `l`
}



Why it doesn’t work
This is a wrong pattern to meet our expectation.
The solders in the list will only be destroyed and removed from the list
when the whole program is ended.
The solders are only removed from the list in its deconstructor.
However, whenever the RefPtr&amp;lt;Solder&amp;gt; s(new Solder())
is deconstructed (by ~RefPtr) in the main function,
the ~Solder() won’t be called
since there must be one another RefPtr&amp;lt;Solder&amp;gt; some in the list
referencing the solder.
Thus, the ~Solder() is only be called
when the element in the list is decontructed.

Sample code
// $ g++ test.cpp --std=c++11
#include &amp;quot;RefPtr.h&amp;quot;
#include &amp;lt;algorithm&amp;gt;  // std::remove
#include &amp;lt;cassert&amp;gt;    // assert
#include &amp;lt;iostream&amp;gt;   // std::cout, std::endl
#include &amp;lt;vector&amp;gt;     // std::vector

///////////////////////////////////////////////////////////////////////////////
// Solder Interface
class Solder: public ReferenceCount
{
public:
  Solder(int n);
  ~Solder();
  int CountOff(); // Report the number.

private:
  int number;
};

///////////////////////////////////////////////////////////////////////////////
// Squad Interface
class Squad
{
public:
  static void Add(Solder* s);
  static void Remove(Solder* s);
  static void CountOff(); // Call all of the solders.
  static unsigned int Size();
private:
  static std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; members;
};

///////////////////////////////////////////////////////////////////////////////
// Solder Implementation
Solder::Solder(int n)
  : number(n)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is created.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Add(this);
}

Solder::~Solder()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Remove(this);
}

int
Solder::CountOff()
{
  return number;
}

///////////////////////////////////////////////////////////////////////////////
// Squad Implementation
std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; Squad::members;

/* static */ void
Squad::Add(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Add Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; to members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.push_back(s);
}

/* static */ void
Squad::Remove(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Remove Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; from members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.erase(std::remove(members.begin(), members.end(), s), members.end());
}

/* static */ void
Squad::CountOff()
{
  for (auto&amp;amp; m: members) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; m-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; is here!&amp;quot; &amp;lt;&amp;lt; std::endl;
  }
}

/* static */ unsigned int
Squad::Size()
{
  return members.size();
}

///////////////////////////////////////////////////////////////////////////////
// *** Wrong example to use RefPtr ***
//   We will put the Solder instances into the squad when they are created,
//   and remove the instances from the squad when they are destroyed.
//   We expect the following behavior.
//
//   List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l;
//   {
//     RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put s into the list
//   }
//   // s is destroyed and removed from the list, so list is empty now.
int main()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Creating a solder and put it into squad.&amp;quot; &amp;lt;&amp;lt; std::endl;

  {
    RefPtr&amp;lt;Solder&amp;gt; s(new Solder(1));
    Squad::CountOff();
    // There should be one solder in the squad now.
    assert(Squad::Size() == 1 &amp;amp;&amp;amp; s-&amp;gt;GetCount() == 2);
  }

  std::cout &amp;lt;&amp;lt; &amp;quot;Solder should be removed from squad and destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  // In our mind, we expect there is no solder in the squad now.
  assert(Squad::Size() == 0); // Comment this to check the below one.
  // But it&amp;#39;s wrong. The correct status of the memebers is:
  // assert(Squad::Size() == 1);

  // In our expectation, we expect the solder 1 will be destroyed and removed
  // from the sqaud when the program is running out of &amp;#39;}&amp;#39; above.
  // At that time, the ~RefPtr() will be called and check whether we need to
  // release the solder 1. However, since we still have a reference to solder 1
  // in the members list of the squal, the reference count to solder 1 is not 0.
  // Therefore, it won&amp;#39;t be removed!

  // Actually,
  // ------------------------------------
  // List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; list
  // Solder()
  // {
  //   Add &amp;#39;this&amp;#39; into the list
  // }
  // ~Solder()
  // {
  //   Remove &amp;#39;this&amp;#39; from the list
  // }
  // ------------------------------------
  // is a wrong pattern to meet our expectation.
  // The solders in the list will only be destroyed and removed from the list
  // when the whole program is ended. The solders are only removed from
  // the list in its deconstructor. However, whenever the
  // RefPtr&amp;lt;Solder&amp;gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,
  // the ~Solder() won&amp;#39;t be called since there must be one another
  // RefPtr&amp;lt;Solder&amp;gt; in the list referencing the solder.
  // Thus, the ~Solder() is only be called when the element in the list is
  // decontructed.

  return 0;
}</summary></entry><entry><title type="html">RefPtr v.s. shared_ptr</title><link href="http://localhost:4000/post/refptr-v-s-shared-ptr" rel="alternate" type="text/html" title="RefPtr v.s. shared_ptr" /><published>2017-07-31T00:00:00+08:00</published><updated>2017-07-31T00:00:00+08:00</updated><id>http://localhost:4000/post/refptr-v-s-shared-ptr</id><content type="html" xml:base="http://localhost:4000/post/refptr-v-s-shared-ptr">&lt;p&gt;When I tried to replace Mozilla’s &lt;a href=&quot;http://searchfox.org/mozilla-central/source/mfbt/RefPtr.h&quot; title=&quot;RefPtr&quot;&gt;RefPtr&lt;/a&gt; with standard C++
smart-pointer to note one of my misusage of it,
I used &lt;em&gt;std::shard_ptr&lt;/em&gt; to do it.
However, it didn’t work since there is a huge difference between
Mozilla’s &lt;a href=&quot;http://searchfox.org/mozilla-central/source/mfbt/RefPtr.h&quot; title=&quot;RefPtr&quot;&gt;RefPtr&lt;/a&gt; and the &lt;em&gt;std::shard_ptr&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I’ve never noticed that because I never use smart-pointer
before I worked for Mozilla.
So it’s a perfect chance for me to get closer to look at their difference.&lt;/p&gt;

&lt;h2 id=&quot;reference-count&quot;&gt;Reference count&lt;/h2&gt;
&lt;p&gt;Although they’re both using reference-count to track object
and manage objects’ life-time by the count,
they are counting on different things.&lt;/p&gt;

&lt;p&gt;Suppose we have reference-counted pointers &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;T&amp;gt;&lt;/code&gt;,
we will call it like &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Foo&amp;gt; p(new Foo(...))&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;refptr&quot;&gt;&lt;em&gt;RefPtr&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;When using &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;,
the total reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt; objects.
That’s see an example below.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Foo must provide reference-counted interface.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// The total references will be counted on Foo object f.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of f is 1 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of f is 2 now.  
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the reference count of f is back to 1 now since p2 is destroyed.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;stdshard_ptr&quot;&gt;&lt;em&gt;std::shard_ptr&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;When using &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;T&amp;gt;&lt;/code&gt;,
the total reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&lt;/code&gt; itself.
That’s see an example below.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Bar does NOT need to provide reference-counted interface.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p1 is 1 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p1 and p2 is 2 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the reference count of p1 is back to 1 now since p2 is destroyed.
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p3 is 1 now.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Even worse, the above program will cause an error:
&lt;strong&gt;pointer being freed was not allocated&lt;/strong&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;p1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;p3&lt;/code&gt; both control the life-time of &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.
When &lt;code class=&quot;highlighter-rouge&quot;&gt;p1&lt;/code&gt; is destroyed, its reference-count is down to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;,
so it will deallocate &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.
Nevertheless, When &lt;code class=&quot;highlighter-rouge&quot;&gt;p3&lt;/code&gt; is destroyed,
its reference-count is also down to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;,
so it will deallocate &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; &lt;strong&gt;again&lt;/strong&gt; and cause an error:
&lt;strong&gt;Freeing an already-freed object&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Thus, using&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;to replace the following pattern should save your life.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// This is a bad pattern!
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample code&lt;/h2&gt;
&lt;p&gt;That’s see the example-implementation of these two smart-pointers.
Again, the key difference between &lt;em&gt;RefPtr&lt;/em&gt; and &lt;em&gt;std::shard_ptr&lt;/em&gt; is&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt; p(new T(...))&lt;/code&gt;:
the reference is counted on the newed &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; object
so the &lt;code class=&quot;highlighter-rouge&quot;&gt;class T&lt;/code&gt; must provide &lt;em&gt;reference-counted&lt;/em&gt; interface.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))&lt;/code&gt;:
the reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt; itself.&lt;/li&gt;
&lt;/ul&gt;

&lt;noscript&gt;&lt;pre&gt;#ifndef REFPTR_H
#define REFPTR_H

#include &amp;lt;cassert&amp;gt;

#define DEBUG
#ifdef DEBUG
#ifdef NDEBUG
#undef NDEBUG
#endif // NDEBUG
#include &amp;lt;iostream&amp;gt;
#endif // DEBUG

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Interface
class ReferenceCount
{
public:
  void AddRef();
  void Release();
  unsigned int GetCount();
  bool IsShared();

protected:
  ReferenceCount();
  // Disallow copy constructor
  ReferenceCount(const ReferenceCount&amp;amp; rhs) = delete;
  // ReferenceCount&amp;amp; operator=(const ReferenceCount&amp;amp; rhs);
  virtual ~ReferenceCount();

private:
  unsigned int count;
};

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Implementation
ReferenceCount::ReferenceCount()
  : count(0)
{
}

// ReferenceCount::ReferenceCount(const ReferenceCount&amp;amp; rhs)
//   : count(0)
// {
// }

ReferenceCount::~ReferenceCount()
{
}

// ReferenceCount&amp;amp;
// ReferenceCount::&amp;amp; operator=(const ReferenceCount&amp;amp; rhs)
// {
//   return this;
// }

void
ReferenceCount::AddRef()
{
  ++count;
}

void
ReferenceCount::Release()
{
  if (!--count) {
#ifdef DEBUG
    fprintf(stderr, &amp;quot;Release %s @ %p\n&amp;quot;, typeid(*this).name() + 1,this);
#endif
    delete this;
  }
}

unsigned int
ReferenceCount::GetCount()
{
  return count;
}

bool
ReferenceCount::IsShared()
{
  return count &amp;gt; 1;
}

///////////////////////////////////////////////////////////////////////////////
// RefPtr Interface
//   pointee must support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class RefPtr
{
public:
  // Default constructor
  RefPtr(T* realPtr = nullptr);

  // Copy constructor
  RefPtr(const RefPtr&amp;amp; rhs);

  ~RefPtr();

  RefPtr&amp;amp; operator=(const RefPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  bool operator==(const RefPtr&amp;amp; rhs);

  bool operator==(const T* rawPtr);

private:
  T *pointee;
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// RefPtr Implementation
template&amp;lt;class T&amp;gt;
void
RefPtr&amp;lt;T&amp;gt;::Init()
{
  if (!pointee) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p\n&amp;quot;, typeid(T).name() + 1, pointee);
#endif
  pointee-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(T* realPtr)
  : pointee(realPtr)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(const RefPtr&amp;amp; rhs)
  : pointee(rhs.pointee)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::~RefPtr()
{
  if (!pointee) {
    return;
  }
  pointee-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator=(const RefPtr&amp;amp; rhs)
{
  if (pointee != rhs.pointee) {
    if (pointee) {
      pointee-&amp;gt;Release();
    }
    pointee = rhs.pointee;
    Init();
  }

  return *this;
}

template&amp;lt;class T&amp;gt;
T*
RefPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(pointee);
  return pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(pointee);
  return *pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const RefPtr&amp;amp; rhs)
{
  return pointee == rhs.pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const T* rawPtr)
{
  return pointee == rawPtr;
}

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Interface
//   pointee doesn&amp;#39;t need to support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class SharedPtr
{
public:
  // Default constructor
  SharedPtr(T* realPtr = nullptr);

  // Copy constructor
  SharedPtr(const SharedPtr&amp;amp; rhs);

  ~SharedPtr();

  SharedPtr&amp;amp; operator=(const SharedPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  // Gives clients access to IsShared() and GetCount()
  ReferenceCount&amp;amp; GetCounter()
  {
    return *counter;
  }

private:
  ///////////////////////////////
  // The references are counted inside SharedPtr instead of in the pointee!
  struct Counter: public ReferenceCount {
    Counter(T* realPtr = nullptr)
      : pointee(realPtr) {}
    ~Counter() { delete pointee; }
    T *pointee;
  };

  Counter *counter;
  ///////////////////////////////
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Implementation
template&amp;lt;class T&amp;gt;
void
SharedPtr&amp;lt;T&amp;gt;::Init()
{
  if (!counter) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p\n&amp;quot;, typeid(counter).name() + 1, counter);
#endif
  counter-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(T* realPtr)
  : counter(new Counter(realPtr))
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(const SharedPtr&amp;amp; rhs)
  : counter(rhs.counter)
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::~SharedPtr()
{
  counter-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator=(const SharedPtr&amp;amp; rhs)
{
  if (counter != rhs.counter) {
    counter-&amp;gt;Release();
    counter = rhs.counter;
    Init();
  }
  return *this;
}
template&amp;lt;class T&amp;gt;
T*
SharedPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(counter-&amp;gt;pointee);
  return counter-&amp;gt;pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(counter-&amp;gt;pointee);
  return *(counter-&amp;gt;pointee);
}

#endif // REFPTR_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1.js?file=RefPtr.h&quot;&gt; &lt;/script&gt;

&lt;p&gt;You can look &lt;a href=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1&quot; title=&quot;RefPtr and SharedPtr&quot;&gt;here&lt;/a&gt; to see how to use it.&lt;/p&gt;

&lt;p&gt;The above code is referenced from &lt;a href=&quot;http://www.aristeia.com/BookErrata/M29Source.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><category term="Firefox" /><summary type="html">When I tried to replace Mozilla’s RefPtr with standard C++
smart-pointer to note one of my misusage of it,
I used std::shard_ptr to do it.
However, it didn’t work since there is a huge difference between
Mozilla’s RefPtr and the std::shard_ptr

I’ve never noticed that because I never use smart-pointer
before I worked for Mozilla.
So it’s a perfect chance for me to get closer to look at their difference.

Reference count
Although they’re both using reference-count to track object
and manage objects’ life-time by the count,
they are counting on different things.

Suppose we have reference-counted pointers RefPtr&amp;lt;T&amp;gt;
and std::shard_ptr&amp;lt;T&amp;gt;,
we will call it like RefPtr&amp;lt;Foo&amp;gt; p(new Foo(...))
and std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))

RefPtr
When using RefPtr&amp;lt;T&amp;gt;,
the total reference is counted on the Foo objects.
That’s see an example below.
// Foo must provide reference-counted interface.
Foo* f = new Foo(...) // The total references will be counted on Foo object f.
RefPtr&amp;lt;Foo&amp;gt; p1(f) // the reference count of f is 1 now.
{
  RefPtr&amp;lt;Foo&amp;gt; p2(f) // the reference count of f is 2 now.  
}
// the reference count of f is back to 1 now since p2 is destroyed.



std::shard_ptr
When using std::shard_ptr&amp;lt;T&amp;gt;,
the total reference is counted on the std::shard_ptr itself.
That’s see an example below.
// Bar does NOT need to provide reference-counted interface.
Bar* b = new Bar(...)
std::shard_ptr&amp;lt;Bar&amp;gt; p1(f) // the reference count of p1 is 1 now.
{
  std::shard_ptr&amp;lt;Bar&amp;gt; p2(p1) // the reference count of p1 and p2 is 2 now.
}
// the reference count of p1 is back to 1 now since p2 is destroyed.

std::shard_ptr&amp;lt;Bar&amp;gt; p3(b) // the reference count of p3 is 1 now.


Even worse, the above program will cause an error:
pointer being freed was not allocated.
The p1 and p3 both control the life-time of b.
When p1 is destroyed, its reference-count is down to 0,
so it will deallocate b.
Nevertheless, When p3 is destroyed,
its reference-count is also down to 0,
so it will deallocate b again and cause an error:
Freeing an already-freed object

Thus, using
std::shard_ptr&amp;lt;Bar&amp;gt; p(new Bar(...))


to replace the following pattern should save your life.
// This is a bad pattern!
Bar* b = new Bar(...)
std::shard_ptr&amp;lt;Bar&amp;gt; p(f)



Sample code
That’s see the example-implementation of these two smart-pointers.
Again, the key difference between RefPtr and std::shard_ptr is

  RefPtr&amp;lt;T&amp;gt; p(new T(...)):
the reference is counted on the newed T object
so the class T must provide reference-counted interface.
  std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...)):
the reference is counted on the q itself.


#ifndef REFPTR_H
#define REFPTR_H

#include &amp;lt;cassert&amp;gt;

#define DEBUG
#ifdef DEBUG
#ifdef NDEBUG
#undef NDEBUG
#endif // NDEBUG
#include &amp;lt;iostream&amp;gt;
#endif // DEBUG

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Interface
class ReferenceCount
{
public:
  void AddRef();
  void Release();
  unsigned int GetCount();
  bool IsShared();

protected:
  ReferenceCount();
  // Disallow copy constructor
  ReferenceCount(const ReferenceCount&amp;amp; rhs) = delete;
  // ReferenceCount&amp;amp; operator=(const ReferenceCount&amp;amp; rhs);
  virtual ~ReferenceCount();

private:
  unsigned int count;
};

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Implementation
ReferenceCount::ReferenceCount()
  : count(0)
{
}

// ReferenceCount::ReferenceCount(const ReferenceCount&amp;amp; rhs)
//   : count(0)
// {
// }

ReferenceCount::~ReferenceCount()
{
}

// ReferenceCount&amp;amp;
// ReferenceCount::&amp;amp; operator=(const ReferenceCount&amp;amp; rhs)
// {
//   return this;
// }

void
ReferenceCount::AddRef()
{
  ++count;
}

void
ReferenceCount::Release()
{
  if (!--count) {
#ifdef DEBUG
    fprintf(stderr, &amp;quot;Release %s @ %p &amp;quot;, typeid(*this).name() + 1,this);
#endif
    delete this;
  }
}

unsigned int
ReferenceCount::GetCount()
{
  return count;
}

bool
ReferenceCount::IsShared()
{
  return count &amp;gt; 1;
}

///////////////////////////////////////////////////////////////////////////////
// RefPtr Interface
//   pointee must support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class RefPtr
{
public:
  // Default constructor
  RefPtr(T* realPtr = nullptr);

  // Copy constructor
  RefPtr(const RefPtr&amp;amp; rhs);

  ~RefPtr();

  RefPtr&amp;amp; operator=(const RefPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  bool operator==(const RefPtr&amp;amp; rhs);

  bool operator==(const T* rawPtr);

private:
  T *pointee;
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// RefPtr Implementation
template&amp;lt;class T&amp;gt;
void
RefPtr&amp;lt;T&amp;gt;::Init()
{
  if (!pointee) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p &amp;quot;, typeid(T).name() + 1, pointee);
#endif
  pointee-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(T* realPtr)
  : pointee(realPtr)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(const RefPtr&amp;amp; rhs)
  : pointee(rhs.pointee)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::~RefPtr()
{
  if (!pointee) {
    return;
  }
  pointee-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator=(const RefPtr&amp;amp; rhs)
{
  if (pointee != rhs.pointee) {
    if (pointee) {
      pointee-&amp;gt;Release();
    }
    pointee = rhs.pointee;
    Init();
  }

  return *this;
}

template&amp;lt;class T&amp;gt;
T*
RefPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(pointee);
  return pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(pointee);
  return *pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const RefPtr&amp;amp; rhs)
{
  return pointee == rhs.pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const T* rawPtr)
{
  return pointee == rawPtr;
}

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Interface
//   pointee doesn&amp;#39;t need to support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class SharedPtr
{
public:
  // Default constructor
  SharedPtr(T* realPtr = nullptr);

  // Copy constructor
  SharedPtr(const SharedPtr&amp;amp; rhs);

  ~SharedPtr();

  SharedPtr&amp;amp; operator=(const SharedPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  // Gives clients access to IsShared() and GetCount()
  ReferenceCount&amp;amp; GetCounter()
  {
    return *counter;
  }

private:
  ///////////////////////////////
  // The references are counted inside SharedPtr instead of in the pointee!
  struct Counter: public ReferenceCount {
    Counter(T* realPtr = nullptr)
      : pointee(realPtr) {}
    ~Counter() { delete pointee; }
    T *pointee;
  };

  Counter *counter;
  ///////////////////////////////
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Implementation
template&amp;lt;class T&amp;gt;
void
SharedPtr&amp;lt;T&amp;gt;::Init()
{
  if (!counter) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p &amp;quot;, typeid(counter).name() + 1, counter);
#endif
  counter-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(T* realPtr)
  : counter(new Counter(realPtr))
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(const SharedPtr&amp;amp; rhs)
  : counter(rhs.counter)
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::~SharedPtr()
{
  counter-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator=(const SharedPtr&amp;amp; rhs)
{
  if (counter != rhs.counter) {
    counter-&amp;gt;Release();
    counter = rhs.counter;
    Init();
  }
  return *this;
}
template&amp;lt;class T&amp;gt;
T*
SharedPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(counter-&amp;gt;pointee);
  return counter-&amp;gt;pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(counter-&amp;gt;pointee);
  return *(counter-&amp;gt;pointee);
}

#endif // REFPTR_H


You can look here to see how to use it.

The above code is referenced from here</summary></entry><entry><title type="html">Development Notes for Mozilla</title><link href="http://localhost:4000/post/development-notes-for-mozilla" rel="alternate" type="text/html" title="Development Notes for Mozilla" /><published>2017-07-19T00:00:00+08:00</published><updated>2017-07-19T00:00:00+08:00</updated><id>http://localhost:4000/post/development-notes-for-mozilla</id><content type="html" xml:base="http://localhost:4000/post/development-notes-for-mozilla">&lt;p&gt;The following are some of my notes to develop the mozilla products.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.penflip.com/Chun-Min/mozilla-newbie-notes&quot; title=&quot;Mozilla Newbie Notes&quot;&gt;Basic knowledge&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;XPCOM&lt;/li&gt;
      &lt;li&gt;WebIDL&lt;/li&gt;
      &lt;li&gt;Mochitest&lt;/li&gt;
      &lt;li&gt;others&lt;/li&gt;
      &lt;li&gt;&lt;del&gt;Firefox OS&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1S4njAbl4tSFCrJ3cnE30L4PcYeWdvY-1wcghX2mWNOE/edit?usp=sharing&quot; title=&quot;IPDL&quot;&gt;IPDL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1o9qeSucSDAJO94TmZmebxRnGepY7MVy-MeVGqyaIO0s/edit?usp=sharing&quot; title=&quot;Firefox (System) Add-on&quot;&gt;(System) Add-on&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1eDjlmBdBrECQ_vXve0HgzmBilgL8HwHrcFQz9puGGr0/edit?usp=sharing&quot; title=&quot;Message Manager&quot;&gt;Message Manager&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1zxanY8xDioeIrfPyuzx9QDgggO1pC8erqhcL30gL7Wc/edit?usp=sharing&quot; title=&quot;Keyboard Event Dispatch&quot;&gt;Keyboard Event Dispatch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/15iXd4ZXy9Y1uKdXkuFsdoqXAzw7Y4pUFKlDaNiAFkb0/edit?usp=sharing&quot; title=&quot;JPAKE over TLS&quot;&gt;JPAKE over TLS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Firefox" /><category term="Fennec" /><summary type="html">The following are some of my notes to develop the mozilla products.


  Basic knowledge
    
      XPCOM
      WebIDL
      Mochitest
      others
      Firefox OS
    
  
  IPDL
  (System) Add-on
  Message Manager
  Keyboard Event Dispatch
  JPAKE over TLS</summary></entry><entry><title type="html">Hash Table v.s. Mutable Array</title><link href="http://localhost:4000/post/hash-table-v-s-mutable-array" rel="alternate" type="text/html" title="Hash Table v.s. Mutable Array" /><published>2017-07-15T00:00:00+08:00</published><updated>2017-07-15T00:00:00+08:00</updated><id>http://localhost:4000/post/hash-table-v-s-mutable-array</id><content type="html" xml:base="http://localhost:4000/post/hash-table-v-s-mutable-array">&lt;p&gt;It’s common sense that the time complexity of insertion and removal of a
hash table are all both &lt;em&gt;O(1)&lt;/em&gt;, while array takes &lt;em&gt;O(n)&lt;/em&gt; for removal.
However, when the data size(&lt;em&gt;n&lt;/em&gt;) is small, the array will beat the hash table.&lt;/p&gt;

&lt;p&gt;Here is the result from my test&lt;a href=&quot;https://gist.github.com/ChunMinChang/b6b7b534e1ef3683f76d830d72c489a6&quot; title=&quot;Performance: Mutable array v.s. Hashtable&quot;&gt;(gist here)&lt;/a&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;# Performance: Mutable array v.s. Hashtable

Subjects:
- mutable array: ```std::vector```
- hash table: ```std::unordered_map```

## Results

### Insertion time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000  | 10000 |
| ------------------ | ----- | ----- | ----- | ----- | ----- | ----- |
| std::vector        | 0.015 | 0.021 | 0.097 | 0.093 | 0.366 | 0.616 |
| std::unordered_map | 0.034 | 0.081 | 0.202 | 0.503 | 2.425 | 3.482 |


### Removal time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000   | 10000   |
| ------------------ | ----- | ----- | ----- | ----- | ------ | ------- |
| std::vector        | 0.008 | 0.046 | 0.129 | 3.82  | 88.562 | 344.566 |
| std::unordered_map | 0.013 | 0.051 | 0.078 | 0.456 | 2.14   | 3.6     |&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/b6b7b534e1ef3683f76d830d72c489a6.js?file=README.md&quot;&gt; &lt;/script&gt;

&lt;p&gt;By the results, if you are pretty sure the data size is less than &lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;
then you should use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unordered_map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On the other hand, if you need to insert and remove itmes frequently,
and the data size is greater than &lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;,
then you should use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unordered_map&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt;.
If items are inserted frequently but removed rarely, &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; is fine.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">It’s common sense that the time complexity of insertion and removal of a
hash table are all both O(1), while array takes O(n) for removal.
However, when the data size(n) is small, the array will beat the hash table.

Here is the result from my test(gist here)
# Performance: Mutable array v.s. Hashtable

Subjects:
- mutable array: ```std::vector```
- hash table: ```std::unordered_map```

## Results

### Insertion time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000  | 10000 |
| ------------------ | ----- | ----- | ----- | ----- | ----- | ----- |
| std::vector        | 0.015 | 0.021 | 0.097 | 0.093 | 0.366 | 0.616 |
| std::unordered_map | 0.034 | 0.081 | 0.202 | 0.503 | 2.425 | 3.482 |


### Removal time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000   | 10000   |
| ------------------ | ----- | ----- | ----- | ----- | ------ | ------- |
| std::vector        | 0.008 | 0.046 | 0.129 | 3.82  | 88.562 | 344.566 |
| std::unordered_map | 0.013 | 0.051 | 0.078 | 0.456 | 2.14   | 3.6     |


By the results, if you are pretty sure the data size is less than 50
then you should use std::vector instead of std::unordered_map.

On the other hand, if you need to insert and remove itmes frequently,
and the data size is greater than 50,
then you should use std::unordered_map instead of std::vector.
If items are inserted frequently but removed rarely, std::vector is fine.</summary></entry><entry><title type="html">Adding a IPDL into PContent</title><link href="http://localhost:4000/post/adding-a-ipdl-into-pcontent" rel="alternate" type="text/html" title="Adding a IPDL into PContent" /><published>2017-07-11T00:00:00+08:00</published><updated>2017-07-11T00:00:00+08:00</updated><id>http://localhost:4000/post/adding-a-ipdl-into-pcontent</id><content type="html" xml:base="http://localhost:4000/post/adding-a-ipdl-into-pcontent">&lt;p&gt;This is my note for adding a IPDL into PContent.&lt;/p&gt;

&lt;iframe src=&quot;https://docs.google.com/presentation/d/1S4njAbl4tSFCrJ3cnE30L4PcYeWdvY-1wcghX2mWNOE/embed?start=false&amp;amp;loop=false&amp;amp;delayms=3000&quot; frameborder=&quot;0&quot; width=&quot;960&quot; height=&quot;569&quot; allowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;The sample code is &lt;a href=&quot;https://github.com/ChunMinChang/gecko-dev/commit/54686d3fbc1ce7a696b4755060810d8ed8f4d567&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Multiprocess" /><category term="Firefox" /><summary type="html">This is my note for adding a IPDL into PContent.



The sample code is here</summary></entry><entry><title type="html">Pthread mutex with different types</title><link href="http://localhost:4000/post/pthread-mutex-with-different-types" rel="alternate" type="text/html" title="Pthread mutex with different types" /><published>2017-05-06T00:00:00+08:00</published><updated>2017-05-06T00:00:00+08:00</updated><id>http://localhost:4000/post/pthread-mutex-with-different-types</id><content type="html" xml:base="http://localhost:4000/post/pthread-mutex-with-different-types">&lt;p&gt;When I tried to &lt;a href=&quot;deadlock-when-using-audiounit&quot;&gt;produce a deadlock in &lt;em&gt;CoreAudio&lt;/em&gt;&lt;/a&gt; with pthread,
I realized that the &lt;em&gt;mutex&lt;/em&gt; with &lt;strong&gt;NORMAL&lt;/strong&gt; type locked by one pthread
could be unlocked by another pthread.
Normally, this behavior should be &lt;strong&gt;disallowed&lt;/strong&gt;.
It will result in undefined behaviors.
If one pthread could unlock a mutex owned by other thread whenever it wants,
then the mutex will be meaningless,
unless it’s a expected behavior.&lt;/p&gt;

&lt;p&gt;In my case, it’s exactly what I want, 
because I need to break the deadlock to continue the program.
However, in most case, this behavior should be &lt;strong&gt;forbidden&lt;/strong&gt;,
so I do some research about
what the behaviors of mutexes with different types are.&lt;/p&gt;

&lt;p&gt;Here is my conclusion:&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;# pthread

Sample code for demonstrating different behavior
in different pthread type
- *PTHREAD_MUTEX_NORMAL*
  - This type of mutex does **not** detect deadlock
  - A thread attempting to relock this mutex without first unlocking it
    shall deadlock
  - A thread attempting to unlock a mutex locked by a different thread
    results in undefined behavior
  - A thread attempting to unlock an unlocked mutex
    results in undefined behavior
- *PTHREAD_MUTEX_ERRORCHECK*
  - This type of mutex provides error checking
  - A thread attempting to relock this mutex without first unlocking
    it shall return with an error
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_RECURSIVE*
  - A thread attempting to relock this mutex without first unlocking it
    shall succeed in locking the mutex
    - The relocking is allowd only in the **same** thread
    - The relocking deadlock which can occur with mutexes of type
      *PTHREAD_MUTEX_NORMAL* **cannot** occur with this type of mutex
    - Multiple locks of this mutex shall require the same number of unlocks
      to release the mutex before another thread can acquire the mutex
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_DEFAULT*
  - Its default value is set to *PTHREAD_MUTEX_NORMAL*
  - It&amp;#39;s allowed to map its value to other types

## Scenarios and results
We have four scenarios:
1. Lock a locked mutex in same thread
2. Unlock a unlocked mutex
3. (Wait to) Lock a locked mutex owned by another thread (__normal use case__)
4. Unlock a locked mutex owned by another thread

Unlocking a mutex owned by current thread is definitely ok,
so it&amp;#39;s exclusive in our scenarios.

The results of our scenarios in different type is:

|            | 1 | 2 | 3 | 4 |
|------------|---|---|---|---|
| NORMAL     | ! | v | v | v |
| ERRORCHECK |   |   | v |   |
| RECURSIVE  | v |   | v |   |
| DEFAULT    | ! | v | v | v |

- ```!```: It works without any error, but it will be **self-deadlocked**
- ```v```: It works without any error
- empty: It can not works, with an error returned


## TODO
- Sample code for ```pthread_kill``` and ```pthread_detach```


## Note

### pthread_mutex_trylock
The ```pthread_mutex_trylock()``` shall be equivalent
to ```pthread_mutex_lock()```,
except that if the mutex object referenced by mutex is currently locked
(by any thread, including the current thread),
the call shall return immediately.
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/fe46f3760e2230c09675e258ae1cf8eb.js?file=README.md&quot;&gt; &lt;/script&gt;

&lt;p&gt;The test code can be found on &lt;a href=&quot;https://gist.github.com/ChunMinChang/fe46f3760e2230c09675e258ae1cf8eb&quot;&gt;gist here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="Multithread" /><summary type="html">When I tried to produce a deadlock in CoreAudio with pthread,
I realized that the mutex with NORMAL type locked by one pthread
could be unlocked by another pthread.
Normally, this behavior should be disallowed.
It will result in undefined behaviors.
If one pthread could unlock a mutex owned by other thread whenever it wants,
then the mutex will be meaningless,
unless it’s a expected behavior.

In my case, it’s exactly what I want, 
because I need to break the deadlock to continue the program.
However, in most case, this behavior should be forbidden,
so I do some research about
what the behaviors of mutexes with different types are.

Here is my conclusion:

# pthread

Sample code for demonstrating different behavior
in different pthread type
- *PTHREAD_MUTEX_NORMAL*
  - This type of mutex does **not** detect deadlock
  - A thread attempting to relock this mutex without first unlocking it
    shall deadlock
  - A thread attempting to unlock a mutex locked by a different thread
    results in undefined behavior
  - A thread attempting to unlock an unlocked mutex
    results in undefined behavior
- *PTHREAD_MUTEX_ERRORCHECK*
  - This type of mutex provides error checking
  - A thread attempting to relock this mutex without first unlocking
    it shall return with an error
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_RECURSIVE*
  - A thread attempting to relock this mutex without first unlocking it
    shall succeed in locking the mutex
    - The relocking is allowd only in the **same** thread
    - The relocking deadlock which can occur with mutexes of type
      *PTHREAD_MUTEX_NORMAL* **cannot** occur with this type of mutex
    - Multiple locks of this mutex shall require the same number of unlocks
      to release the mutex before another thread can acquire the mutex
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_DEFAULT*
  - Its default value is set to *PTHREAD_MUTEX_NORMAL*
  - It&amp;#39;s allowed to map its value to other types

## Scenarios and results
We have four scenarios:
1. Lock a locked mutex in same thread
2. Unlock a unlocked mutex
3. (Wait to) Lock a locked mutex owned by another thread (__normal use case__)
4. Unlock a locked mutex owned by another thread

Unlocking a mutex owned by current thread is definitely ok,
so it&amp;#39;s exclusive in our scenarios.

The results of our scenarios in different type is:

|            | 1 | 2 | 3 | 4 |
|------------|---|---|---|---|
| NORMAL     | ! | v | v | v |
| ERRORCHECK |   |   | v |   |
| RECURSIVE  | v |   | v |   |
| DEFAULT    | ! | v | v | v |

- ```!```: It works without any error, but it will be **self-deadlocked**
- ```v```: It works without any error
- empty: It can not works, with an error returned


## TODO
- Sample code for ```pthread_kill``` and ```pthread_detach```


## Note

### pthread_mutex_trylock
The ```pthread_mutex_trylock()``` shall be equivalent
to ```pthread_mutex_lock()```,
except that if the mutex object referenced by mutex is currently locked
(by any thread, including the current thread),
the call shall return immediately.



The test code can be found on gist here</summary></entry><entry><title type="html">Deadlock when using AudioUnit</title><link href="http://localhost:4000/post/deadlock-when-using-audiounit" rel="alternate" type="text/html" title="Deadlock when using AudioUnit" /><published>2017-05-05T00:00:00+08:00</published><updated>2017-05-05T00:00:00+08:00</updated><id>http://localhost:4000/post/deadlock-when-using-audiounit</id><content type="html" xml:base="http://localhost:4000/post/deadlock-when-using-audiounit">&lt;p&gt;There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1337805&quot;&gt;bug here&lt;/a&gt;.
It &lt;strong&gt;only happens on OSX&lt;/strong&gt;.
After &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1350511#c1&quot;&gt;analysis&lt;/a&gt;,
I wrote a test to prevent others from getting into the same problem.
The test is added to &lt;a href=&quot;https://github.com/ChunMinChang/cubeb&quot;&gt;cubeb&lt;/a&gt;,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of &lt;a href=&quot;https://github.com/ChunMinChang/cubeb/blob/8939c0d168a27b1d5047779caad46835ca4651b9/test/test_deadlock.cpp#L1-L43&quot;&gt;the deadlock&lt;/a&gt;)
in the test.&lt;/p&gt;

&lt;p&gt;However, the code is not easy enough for those who are not familir with &lt;em&gt;cubeb&lt;/em&gt;,
so I wrote a general version to highlight the issue to
everyone who uses &lt;em&gt;AudioUnit&lt;/em&gt; in their audio backend.
You can find the code on &lt;a href=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9&quot;&gt;gist here&lt;/a&gt;&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &amp;lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&amp;gt; Thread B

#include &amp;lt;assert.h&amp;gt;               // for assert
#include &amp;lt;pthread.h&amp;gt;              // for pthread
#include &amp;lt;signal.h&amp;gt;               // for signal
#include &amp;lt;unistd.h&amp;gt;               // for sleep, usleep

#include &amp;quot;AudioStream.h&amp;quot;          // for AudioStream
#include &amp;quot;utils.h&amp;quot;                // for LOG
#include &amp;quot;OwnedCriticalSection.h&amp;quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&amp;#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&amp;lt;OwnedCriticalSection&amp;gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&amp;quot;pending task thread is killed!\n&amp;quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;amp;&amp;amp; LOG(&amp;quot;Output callback is on thread %llu, holding mutex_AU\n&amp;quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&amp;#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&amp;quot;[%llu] Force to switch threads\n&amp;quot;, id);
    usleep(10000);
  }

  LOG(&amp;quot;[%llu] Try getting another mutex: gMutex...\n&amp;quot;, id);
  locker guard(gMutex);

  LOG(&amp;quot;[%llu] Got mutex finally!\n&amp;quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&amp;quot;Task thread: %llu, holding gMutex, is created\n&amp;quot;, id);

  while(!gCalling) {
    LOG(&amp;quot;[%llu] waiting for output callback before running task\n&amp;quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&amp;quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&amp;quot;[%llu] Another AudioUnit is created!\n&amp;quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&amp;quot;Task thread: %llu is created\n&amp;quot;, id);
//
//   while(!gCalling) {
//     LOG(&amp;quot;[%llu] waiting for output callback before running task\n&amp;quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&amp;quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&amp;quot;[%llu] Another AudioUnit is created!\n&amp;quot;, id);
//
//   // Hold the mutex.
//   LOG(&amp;quot;[%llu] Try getting another mutex: gMutex...\n&amp;quot;, id);
//   locker guard(gMutex);
//
//   LOG(&amp;quot;[%llu] Got mutex finally!\n&amp;quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&amp;quot;Monitor thread %llu on thread %llu\n&amp;quot;, sid, id);

  unsigned int sec = 1;
  LOG(&amp;quot;[%llu] sleep %d seconds before checking task for thread %llu\n&amp;quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&amp;quot;[%llu] Kill the task thread %llu!\n&amp;quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&amp;#39;t be released,
    // so we need unlock it manually. Notice that we can&amp;#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&amp;quot;\n[%llu] Task is %sdone\n\n&amp;quot;, id, gTaskDone ? &amp;quot;&amp;quot;: &amp;quot;NOT &amp;quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;amp;subject, NULL, task, NULL);
  pthread_create(&amp;amp;detector, NULL, watchdog, (void *) &amp;amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;amp;&amp;amp; &amp;quot;Callback should be fired!&amp;quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;amp;&amp;amp; &amp;quot;Deadlock detected!&amp;quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;amp;&amp;amp; &amp;quot;Killer is out of control!&amp;quot;);

  return 0;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=test_deadlock.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;The APIs called to play and stop the audio stream is:&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &amp;lt;AudioUnit/AudioUnit.h&amp;gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;CoreAudio/CoreAudio.h&amp;gt;

#include &amp;quot;AudioStream.h&amp;quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;amp;&amp;amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &amp;quot;|&amp;quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&amp;#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&amp;gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&amp;lt;AudioStream*&amp;gt;(aRefCon); // Get arguments
  void* buffer = aData-&amp;gt;mBuffers[0].mData;
  as-&amp;gt;mCallback(buffer, aNumFrames);
  return noErr;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as &lt;em&gt;Mutex-AU&lt;/em&gt;)
shared with &lt;em&gt;AudioUnit&lt;/em&gt;.
The &lt;em&gt;Mutex-AU&lt;/em&gt; is held inside it’s framework, so you don’t notice it.&lt;/p&gt;

&lt;p&gt;Thus, if the callback thread requests another &lt;em&gt;mutex M&lt;/em&gt; held by the another
thread, without releasing &lt;em&gt;mutex-AU&lt;/em&gt;, then it will cause a deadlock when the
another thread, which holds the &lt;em&gt;mutex M&lt;/em&gt;, request to use AudioUnit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That is,
if we have a &lt;em&gt;thread T&lt;/em&gt;, holding the &lt;em&gt;mutex M&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and one &lt;em&gt;callback thread&lt;/em&gt; which holds the &lt;em&gt;mutex-AU&lt;/em&gt;,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The deadlock will occur when the &lt;em&gt;callback thread&lt;/em&gt; requests the &lt;em&gt;mutex M&lt;/em&gt;
(the callback thread is blocked for waiting the &lt;em&gt;mutex M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and the &lt;em&gt;thread T&lt;/em&gt; requests the &lt;em&gt;mutex-AU&lt;/em&gt; to use AudioUnit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Media" /><category term="CoreAudio" /><category term="Multithread" /><summary type="html">There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the bug here.
It only happens on OSX.
After analysis,
I wrote a test to prevent others from getting into the same problem.
The test is added to cubeb,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of the deadlock)
in the test.

However, the code is not easy enough for those who are not familir with cubeb,
so I wrote a general version to highlight the issue to
everyone who uses AudioUnit in their audio backend.
You can find the code on gist here

// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &amp;lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&amp;gt; Thread B

#include &amp;lt;assert.h&amp;gt;               // for assert
#include &amp;lt;pthread.h&amp;gt;              // for pthread
#include &amp;lt;signal.h&amp;gt;               // for signal
#include &amp;lt;unistd.h&amp;gt;               // for sleep, usleep

#include &amp;quot;AudioStream.h&amp;quot;          // for AudioStream
#include &amp;quot;utils.h&amp;quot;                // for LOG
#include &amp;quot;OwnedCriticalSection.h&amp;quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&amp;#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&amp;lt;OwnedCriticalSection&amp;gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&amp;quot;pending task thread is killed! &amp;quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;amp;&amp;amp; LOG(&amp;quot;Output callback is on thread %llu, holding mutex_AU &amp;quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&amp;#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&amp;quot;[%llu] Force to switch threads &amp;quot;, id);
    usleep(10000);
  }

  LOG(&amp;quot;[%llu] Try getting another mutex: gMutex... &amp;quot;, id);
  locker guard(gMutex);

  LOG(&amp;quot;[%llu] Got mutex finally! &amp;quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&amp;quot;Task thread: %llu, holding gMutex, is created &amp;quot;, id);

  while(!gCalling) {
    LOG(&amp;quot;[%llu] waiting for output callback before running task &amp;quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)... &amp;quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&amp;quot;[%llu] Another AudioUnit is created! &amp;quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&amp;quot;Task thread: %llu is created &amp;quot;, id);
//
//   while(!gCalling) {
//     LOG(&amp;quot;[%llu] waiting for output callback before running task &amp;quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)... &amp;quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&amp;quot;[%llu] Another AudioUnit is created! &amp;quot;, id);
//
//   // Hold the mutex.
//   LOG(&amp;quot;[%llu] Try getting another mutex: gMutex... &amp;quot;, id);
//   locker guard(gMutex);
//
//   LOG(&amp;quot;[%llu] Got mutex finally! &amp;quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&amp;quot;Monitor thread %llu on thread %llu &amp;quot;, sid, id);

  unsigned int sec = 1;
  LOG(&amp;quot;[%llu] sleep %d seconds before checking task for thread %llu &amp;quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&amp;quot;[%llu] Kill the task thread %llu! &amp;quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&amp;#39;t be released,
    // so we need unlock it manually. Notice that we can&amp;#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&amp;quot; [%llu] Task is %sdone  &amp;quot;, id, gTaskDone ? &amp;quot;&amp;quot;: &amp;quot;NOT &amp;quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;amp;subject, NULL, task, NULL);
  pthread_create(&amp;amp;detector, NULL, watchdog, (void *) &amp;amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;amp;&amp;amp; &amp;quot;Callback should be fired!&amp;quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;amp;&amp;amp; &amp;quot;Deadlock detected!&amp;quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;amp;&amp;amp; &amp;quot;Killer is out of control!&amp;quot;);

  return 0;
}



The APIs called to play and stop the audio stream is:
#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &amp;lt;AudioUnit/AudioUnit.h&amp;gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H



#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;CoreAudio/CoreAudio.h&amp;gt;

#include &amp;quot;AudioStream.h&amp;quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;amp;&amp;amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &amp;quot;|&amp;quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&amp;#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&amp;gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&amp;lt;AudioStream*&amp;gt;(aRefCon); // Get arguments
  void* buffer = aData-&amp;gt;mBuffers[0].mData;
  as-&amp;gt;mCallback(buffer, aNumFrames);
  return noErr;
}



The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as Mutex-AU)
shared with AudioUnit.
The Mutex-AU is held inside it’s framework, so you don’t notice it.

Thus, if the callback thread requests another mutex M held by the another
thread, without releasing mutex-AU, then it will cause a deadlock when the
another thread, which holds the mutex M, request to use AudioUnit.



That is,
if we have a thread T, holding the mutex M



and one callback thread which holds the mutex-AU,



The deadlock will occur when the callback thread requests the mutex M
(the callback thread is blocked for waiting the mutex M)



and the thread T requests the mutex-AU to use AudioUnit</summary></entry></feed>
