<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-07-19T16:57:03+08:00</updated><id>http://localhost:4000//</id><title type="html">Peak Up</title><subtitle>everyday surpass myself</subtitle><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><entry><title type="html">Development Notes for Mozilla</title><link href="http://localhost:4000/post/development-notes-for-mozilla" rel="alternate" type="text/html" title="Development Notes for Mozilla" /><published>2017-07-19T00:00:00+08:00</published><updated>2017-07-19T00:00:00+08:00</updated><id>http://localhost:4000/post/development-notes-for-mozilla</id><content type="html" xml:base="http://localhost:4000/post/development-notes-for-mozilla">&lt;p&gt;The following are some of my notes to develop the mozilla products.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.penflip.com/Chun-Min/mozilla-newbie-notes&quot; title=&quot;Mozilla Newbie Notes&quot;&gt;Basic knowledge&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;XPCOM&lt;/li&gt;
      &lt;li&gt;WebIDL&lt;/li&gt;
      &lt;li&gt;Mochitest&lt;/li&gt;
      &lt;li&gt;others&lt;/li&gt;
      &lt;li&gt;&lt;del&gt;Firefox OS&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1S4njAbl4tSFCrJ3cnE30L4PcYeWdvY-1wcghX2mWNOE/edit?usp=sharing&quot; title=&quot;IPDL&quot;&gt;IPDL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1o9qeSucSDAJO94TmZmebxRnGepY7MVy-MeVGqyaIO0s/edit?usp=sharing&quot; title=&quot;Firefox (System) Add-on&quot;&gt;(System) Add-on&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1eDjlmBdBrECQ_vXve0HgzmBilgL8HwHrcFQz9puGGr0/edit?usp=sharing&quot; title=&quot;Message Manager&quot;&gt;Message Manager&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1zxanY8xDioeIrfPyuzx9QDgggO1pC8erqhcL30gL7Wc/edit?usp=sharing&quot; title=&quot;Keyboard Event Dispatch&quot;&gt;Keyboard Event Dispatch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/15iXd4ZXy9Y1uKdXkuFsdoqXAzw7Y4pUFKlDaNiAFkb0/edit?usp=sharing&quot; title=&quot;JPAKE over TLS&quot;&gt;JPAKE over TLS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Firefox" /><category term="Fennec" /><summary type="html">The following are some of my notes to develop the mozilla products.


  Basic knowledge
    
      XPCOM
      WebIDL
      Mochitest
      others
      Firefox OS
    
  
  IPDL
  (System) Add-on
  Message Manager
  Keyboard Event Dispatch
  JPAKE over TLS</summary></entry><entry><title type="html">Hash Table v.s. Mutable Array</title><link href="http://localhost:4000/post/hash-table-v-s-mutable-array" rel="alternate" type="text/html" title="Hash Table v.s. Mutable Array" /><published>2017-07-15T00:00:00+08:00</published><updated>2017-07-15T00:00:00+08:00</updated><id>http://localhost:4000/post/hash-table-v-s-mutable-array</id><content type="html" xml:base="http://localhost:4000/post/hash-table-v-s-mutable-array">&lt;p&gt;It’s common sense that the time complexity of insertion and removal of a
hash table are all both &lt;em&gt;O(1)&lt;/em&gt;, while array takes &lt;em&gt;O(n)&lt;/em&gt; for removal.
However, when the data size(&lt;em&gt;n&lt;/em&gt;) is small, the array will beat the hash table.&lt;/p&gt;

&lt;p&gt;Here is the result from my test&lt;a href=&quot;https://gist.github.com/ChunMinChang/b6b7b534e1ef3683f76d830d72c489a6&quot; title=&quot;Performance: Mutable array v.s. Hashtable&quot;&gt;(gist here)&lt;/a&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;# Performance: Mutable array v.s. Hashtable

Subjects:
- mutable array: ```std::vector```
- hash table: ```std::unordered_map```

## Results

### Insertion time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000  | 10000 |
| ------------------ | ----- | ----- | ----- | ----- | ----- | ----- |
| std::vector        | 0.015 | 0.021 | 0.097 | 0.093 | 0.366 | 0.616 |
| std::unordered_map | 0.034 | 0.081 | 0.202 | 0.503 | 2.425 | 3.482 |


### Removal time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000   | 10000   |
| ------------------ | ----- | ----- | ----- | ----- | ------ | ------- |
| std::vector        | 0.008 | 0.046 | 0.129 | 3.82  | 88.562 | 344.566 |
| std::unordered_map | 0.013 | 0.051 | 0.078 | 0.456 | 2.14   | 3.6     |&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/b6b7b534e1ef3683f76d830d72c489a6.js?file=README.md&quot;&gt; &lt;/script&gt;

&lt;p&gt;By the results, if you are pretty sure the data size is less than &lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;
then you should use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unordered_map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On the other hand, if you need to insert and remove itmes frequently,
and the data size is greater than &lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;,
then you should use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unordered_map&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt;.
If items are inserted frequently but removed rarely, &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; is fine.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">It’s common sense that the time complexity of insertion and removal of a
hash table are all both O(1), while array takes O(n) for removal.
However, when the data size(n) is small, the array will beat the hash table.

Here is the result from my test(gist here)
# Performance: Mutable array v.s. Hashtable

Subjects:
- mutable array: ```std::vector```
- hash table: ```std::unordered_map```

## Results

### Insertion time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000  | 10000 |
| ------------------ | ----- | ----- | ----- | ----- | ----- | ----- |
| std::vector        | 0.015 | 0.021 | 0.097 | 0.093 | 0.366 | 0.616 |
| std::unordered_map | 0.034 | 0.081 | 0.202 | 0.503 | 2.425 | 3.482 |


### Removal time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000   | 10000   |
| ------------------ | ----- | ----- | ----- | ----- | ------ | ------- |
| std::vector        | 0.008 | 0.046 | 0.129 | 3.82  | 88.562 | 344.566 |
| std::unordered_map | 0.013 | 0.051 | 0.078 | 0.456 | 2.14   | 3.6     |


By the results, if you are pretty sure the data size is less than 50
then you should use std::vector instead of std::unordered_map.

On the other hand, if you need to insert and remove itmes frequently,
and the data size is greater than 50,
then you should use std::unordered_map instead of std::vector.
If items are inserted frequently but removed rarely, std::vector is fine.</summary></entry><entry><title type="html">Adding a IPDL into PContent</title><link href="http://localhost:4000/post/adding-a-ipdl-into-pcontent" rel="alternate" type="text/html" title="Adding a IPDL into PContent" /><published>2017-07-11T00:00:00+08:00</published><updated>2017-07-11T00:00:00+08:00</updated><id>http://localhost:4000/post/adding-a-ipdl-into-pcontent</id><content type="html" xml:base="http://localhost:4000/post/adding-a-ipdl-into-pcontent">&lt;p&gt;This is my note for adding a IPDL into PContent.&lt;/p&gt;

&lt;iframe src=&quot;https://docs.google.com/presentation/d/1S4njAbl4tSFCrJ3cnE30L4PcYeWdvY-1wcghX2mWNOE/embed?start=false&amp;amp;loop=false&amp;amp;delayms=3000&quot; frameborder=&quot;0&quot; width=&quot;960&quot; height=&quot;569&quot; allowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;The sample code is &lt;a href=&quot;https://github.com/ChunMinChang/gecko-dev/commit/54686d3fbc1ce7a696b4755060810d8ed8f4d567&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Multiprocess" /><category term="Firefox" /><summary type="html">This is my note for adding a IPDL into PContent.



The sample code is here</summary></entry><entry><title type="html">Pthread mutex with different types</title><link href="http://localhost:4000/post/pthread-mutex-with-different-types" rel="alternate" type="text/html" title="Pthread mutex with different types" /><published>2017-05-06T00:00:00+08:00</published><updated>2017-05-06T00:00:00+08:00</updated><id>http://localhost:4000/post/pthread-mutex-with-different-types</id><content type="html" xml:base="http://localhost:4000/post/pthread-mutex-with-different-types">&lt;p&gt;When I tried to &lt;a href=&quot;deadlock-when-using-audiounit&quot;&gt;produce a deadlock in &lt;em&gt;CoreAudio&lt;/em&gt;&lt;/a&gt; with pthread,
I realized that the &lt;em&gt;mutex&lt;/em&gt; with &lt;strong&gt;NORMAL&lt;/strong&gt; type locked by one pthread
could be unlocked by another pthread.
Normally, this behavior should be &lt;strong&gt;disallowed&lt;/strong&gt;.
It will result in undefined behaviors.
If one pthread could unlock a mutex owned by other thread whenever it wants,
then the mutex will be meaningless,
unless it’s a expected behavior.&lt;/p&gt;

&lt;p&gt;In my case, it’s exactly what I want, 
because I need to break the deadlock to continue the program.
However, in most case, this behavior should be &lt;strong&gt;forbidden&lt;/strong&gt;,
so I do some research about
what the behaviors of mutexes with different types are.&lt;/p&gt;

&lt;p&gt;Here is my conclusion:&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;# pthread

Sample code for demonstrating different behavior
in different pthread type
- *PTHREAD_MUTEX_NORMAL*
  - This type of mutex does **not** detect deadlock
  - A thread attempting to relock this mutex without first unlocking it
    shall deadlock
  - A thread attempting to unlock a mutex locked by a different thread
    results in undefined behavior
  - A thread attempting to unlock an unlocked mutex
    results in undefined behavior
- *PTHREAD_MUTEX_ERRORCHECK*
  - This type of mutex provides error checking
  - A thread attempting to relock this mutex without first unlocking
    it shall return with an error
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_RECURSIVE*
  - A thread attempting to relock this mutex without first unlocking it
    shall succeed in locking the mutex
    - The relocking is allowd only in the **same** thread
    - The relocking deadlock which can occur with mutexes of type
      *PTHREAD_MUTEX_NORMAL* **cannot** occur with this type of mutex
    - Multiple locks of this mutex shall require the same number of unlocks
      to release the mutex before another thread can acquire the mutex
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_DEFAULT*
  - Its default value is set to *PTHREAD_MUTEX_NORMAL*
  - It&amp;#39;s allowed to map its value to other types

## Scenarios and results
We have four scenarios:
1. Lock a locked mutex in same thread
2. Unlock a unlocked mutex
3. (Wait to) Lock a locked mutex owned by another thread (__normal use case__)
4. Unlock a locked mutex owned by another thread

Unlocking a mutex owned by current thread is definitely ok,
so it&amp;#39;s exclusive in our scenarios.

The results of our scenarios in different type is:

|            | 1 | 2 | 3 | 4 |
|------------|---|---|---|---|
| NORMAL     | ! | v | v | v |
| ERRORCHECK |   |   | v |   |
| RECURSIVE  | v |   | v |   |
| DEFAULT    | ! | v | v | v |

- ```!```: It works without any error, but it will be **self-deadlocked**
- ```v```: It works without any error
- empty: It can not works, with an error returned


## TODO
- Sample code for ```pthread_kill``` and ```pthread_detach```


## Note

### pthread_mutex_trylock
The ```pthread_mutex_trylock()``` shall be equivalent
to ```pthread_mutex_lock()```,
except that if the mutex object referenced by mutex is currently locked
(by any thread, including the current thread),
the call shall return immediately.
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/fe46f3760e2230c09675e258ae1cf8eb.js?file=README.md&quot;&gt; &lt;/script&gt;

&lt;p&gt;The test code can be found on &lt;a href=&quot;https://gist.github.com/ChunMinChang/fe46f3760e2230c09675e258ae1cf8eb&quot;&gt;gist here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="Multithread" /><summary type="html">When I tried to produce a deadlock in CoreAudio with pthread,
I realized that the mutex with NORMAL type locked by one pthread
could be unlocked by another pthread.
Normally, this behavior should be disallowed.
It will result in undefined behaviors.
If one pthread could unlock a mutex owned by other thread whenever it wants,
then the mutex will be meaningless,
unless it’s a expected behavior.

In my case, it’s exactly what I want, 
because I need to break the deadlock to continue the program.
However, in most case, this behavior should be forbidden,
so I do some research about
what the behaviors of mutexes with different types are.

Here is my conclusion:

# pthread

Sample code for demonstrating different behavior
in different pthread type
- *PTHREAD_MUTEX_NORMAL*
  - This type of mutex does **not** detect deadlock
  - A thread attempting to relock this mutex without first unlocking it
    shall deadlock
  - A thread attempting to unlock a mutex locked by a different thread
    results in undefined behavior
  - A thread attempting to unlock an unlocked mutex
    results in undefined behavior
- *PTHREAD_MUTEX_ERRORCHECK*
  - This type of mutex provides error checking
  - A thread attempting to relock this mutex without first unlocking
    it shall return with an error
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_RECURSIVE*
  - A thread attempting to relock this mutex without first unlocking it
    shall succeed in locking the mutex
    - The relocking is allowd only in the **same** thread
    - The relocking deadlock which can occur with mutexes of type
      *PTHREAD_MUTEX_NORMAL* **cannot** occur with this type of mutex
    - Multiple locks of this mutex shall require the same number of unlocks
      to release the mutex before another thread can acquire the mutex
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_DEFAULT*
  - Its default value is set to *PTHREAD_MUTEX_NORMAL*
  - It&amp;#39;s allowed to map its value to other types

## Scenarios and results
We have four scenarios:
1. Lock a locked mutex in same thread
2. Unlock a unlocked mutex
3. (Wait to) Lock a locked mutex owned by another thread (__normal use case__)
4. Unlock a locked mutex owned by another thread

Unlocking a mutex owned by current thread is definitely ok,
so it&amp;#39;s exclusive in our scenarios.

The results of our scenarios in different type is:

|            | 1 | 2 | 3 | 4 |
|------------|---|---|---|---|
| NORMAL     | ! | v | v | v |
| ERRORCHECK |   |   | v |   |
| RECURSIVE  | v |   | v |   |
| DEFAULT    | ! | v | v | v |

- ```!```: It works without any error, but it will be **self-deadlocked**
- ```v```: It works without any error
- empty: It can not works, with an error returned


## TODO
- Sample code for ```pthread_kill``` and ```pthread_detach```


## Note

### pthread_mutex_trylock
The ```pthread_mutex_trylock()``` shall be equivalent
to ```pthread_mutex_lock()```,
except that if the mutex object referenced by mutex is currently locked
(by any thread, including the current thread),
the call shall return immediately.



The test code can be found on gist here</summary></entry><entry><title type="html">Deadlock when using AudioUnit</title><link href="http://localhost:4000/post/deadlock-when-using-audiounit" rel="alternate" type="text/html" title="Deadlock when using AudioUnit" /><published>2017-05-05T00:00:00+08:00</published><updated>2017-05-05T00:00:00+08:00</updated><id>http://localhost:4000/post/deadlock-when-using-audiounit</id><content type="html" xml:base="http://localhost:4000/post/deadlock-when-using-audiounit">&lt;p&gt;There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1337805&quot;&gt;bug here&lt;/a&gt;.
It &lt;strong&gt;only happens on OSX&lt;/strong&gt;.
After &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1350511#c1&quot;&gt;analysis&lt;/a&gt;,
I wrote a test to prevent others from getting into the same problem.
The test is added to &lt;a href=&quot;https://github.com/ChunMinChang/cubeb&quot;&gt;cubeb&lt;/a&gt;,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of &lt;a href=&quot;https://github.com/ChunMinChang/cubeb/blob/8939c0d168a27b1d5047779caad46835ca4651b9/test/test_deadlock.cpp#L1-L43&quot;&gt;the deadlock&lt;/a&gt;)
in the test.&lt;/p&gt;

&lt;p&gt;However, the code is not easy enough for those who are not familir with &lt;em&gt;cubeb&lt;/em&gt;,
so I wrote a general version to highlight the issue to
everyone who uses &lt;em&gt;AudioUnit&lt;/em&gt; in their audio backend.
You can find the code on &lt;a href=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9&quot;&gt;gist here&lt;/a&gt;&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &amp;lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&amp;gt; Thread B

#include &amp;lt;assert.h&amp;gt;               // for assert
#include &amp;lt;pthread.h&amp;gt;              // for pthread
#include &amp;lt;signal.h&amp;gt;               // for signal
#include &amp;lt;unistd.h&amp;gt;               // for sleep, usleep

#include &amp;quot;AudioStream.h&amp;quot;          // for AudioStream
#include &amp;quot;utils.h&amp;quot;                // for LOG
#include &amp;quot;OwnedCriticalSection.h&amp;quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&amp;#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&amp;lt;OwnedCriticalSection&amp;gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&amp;quot;pending task thread is killed!\n&amp;quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;amp;&amp;amp; LOG(&amp;quot;Output callback is on thread %llu, holding mutex_AU\n&amp;quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&amp;#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&amp;quot;[%llu] Force to switch threads\n&amp;quot;, id);
    usleep(10000);
  }

  LOG(&amp;quot;[%llu] Try getting another mutex: gMutex...\n&amp;quot;, id);
  locker guard(gMutex);

  LOG(&amp;quot;[%llu] Got mutex finally!\n&amp;quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&amp;quot;Task thread: %llu, holding gMutex, is created\n&amp;quot;, id);

  while(!gCalling) {
    LOG(&amp;quot;[%llu] waiting for output callback before running task\n&amp;quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&amp;quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&amp;quot;[%llu] Another AudioUnit is created!\n&amp;quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&amp;quot;Task thread: %llu is created\n&amp;quot;, id);
//
//   while(!gCalling) {
//     LOG(&amp;quot;[%llu] waiting for output callback before running task\n&amp;quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&amp;quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&amp;quot;[%llu] Another AudioUnit is created!\n&amp;quot;, id);
//
//   // Hold the mutex.
//   LOG(&amp;quot;[%llu] Try getting another mutex: gMutex...\n&amp;quot;, id);
//   locker guard(gMutex);
//
//   LOG(&amp;quot;[%llu] Got mutex finally!\n&amp;quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&amp;quot;Monitor thread %llu on thread %llu\n&amp;quot;, sid, id);

  unsigned int sec = 1;
  LOG(&amp;quot;[%llu] sleep %d seconds before checking task for thread %llu\n&amp;quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&amp;quot;[%llu] Kill the task thread %llu!\n&amp;quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&amp;#39;t be released,
    // so we need unlock it manually. Notice that we can&amp;#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&amp;quot;\n[%llu] Task is %sdone\n\n&amp;quot;, id, gTaskDone ? &amp;quot;&amp;quot;: &amp;quot;NOT &amp;quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;amp;subject, NULL, task, NULL);
  pthread_create(&amp;amp;detector, NULL, watchdog, (void *) &amp;amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;amp;&amp;amp; &amp;quot;Callback should be fired!&amp;quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;amp;&amp;amp; &amp;quot;Deadlock detected!&amp;quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;amp;&amp;amp; &amp;quot;Killer is out of control!&amp;quot;);

  return 0;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=test_deadlock.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;The APIs called to play and stop the audio stream is:&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &amp;lt;AudioUnit/AudioUnit.h&amp;gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;CoreAudio/CoreAudio.h&amp;gt;

#include &amp;quot;AudioStream.h&amp;quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;amp;&amp;amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &amp;quot;|&amp;quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&amp;#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&amp;gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&amp;lt;AudioStream*&amp;gt;(aRefCon); // Get arguments
  void* buffer = aData-&amp;gt;mBuffers[0].mData;
  as-&amp;gt;mCallback(buffer, aNumFrames);
  return noErr;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as &lt;em&gt;Mutex-AU&lt;/em&gt;)
shared with &lt;em&gt;AudioUnit&lt;/em&gt;.
The &lt;em&gt;Mutex-AU&lt;/em&gt; is held inside it’s framework, so you don’t notice it.&lt;/p&gt;

&lt;p&gt;Thus, if the callback thread requests another &lt;em&gt;mutex M&lt;/em&gt; held by the another
thread, without releasing &lt;em&gt;mutex-AU&lt;/em&gt;, then it will cause a deadlock when the
another thread, which holds the &lt;em&gt;mutex M&lt;/em&gt;, request to use AudioUnit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That is,
if we have a &lt;em&gt;thread T&lt;/em&gt;, holding the &lt;em&gt;mutex M&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and one &lt;em&gt;callback thread&lt;/em&gt; which holds the &lt;em&gt;mutex-AU&lt;/em&gt;,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The deadlock will occur when the &lt;em&gt;callback thread&lt;/em&gt; requests the &lt;em&gt;mutex M&lt;/em&gt;
(the callback thread is blocked for waiting the &lt;em&gt;mutex M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and the &lt;em&gt;thread T&lt;/em&gt; requests the &lt;em&gt;mutex-AU&lt;/em&gt; to use AudioUnit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Media" /><category term="CoreAudio" /><category term="Multithread" /><summary type="html">There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the bug here.
It only happens on OSX.
After analysis,
I wrote a test to prevent others from getting into the same problem.
The test is added to cubeb,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of the deadlock)
in the test.

However, the code is not easy enough for those who are not familir with cubeb,
so I wrote a general version to highlight the issue to
everyone who uses AudioUnit in their audio backend.
You can find the code on gist here

// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &amp;lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&amp;gt; Thread B

#include &amp;lt;assert.h&amp;gt;               // for assert
#include &amp;lt;pthread.h&amp;gt;              // for pthread
#include &amp;lt;signal.h&amp;gt;               // for signal
#include &amp;lt;unistd.h&amp;gt;               // for sleep, usleep

#include &amp;quot;AudioStream.h&amp;quot;          // for AudioStream
#include &amp;quot;utils.h&amp;quot;                // for LOG
#include &amp;quot;OwnedCriticalSection.h&amp;quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&amp;#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&amp;lt;OwnedCriticalSection&amp;gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&amp;quot;pending task thread is killed! &amp;quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;amp;&amp;amp; LOG(&amp;quot;Output callback is on thread %llu, holding mutex_AU &amp;quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&amp;#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&amp;quot;[%llu] Force to switch threads &amp;quot;, id);
    usleep(10000);
  }

  LOG(&amp;quot;[%llu] Try getting another mutex: gMutex... &amp;quot;, id);
  locker guard(gMutex);

  LOG(&amp;quot;[%llu] Got mutex finally! &amp;quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&amp;quot;Task thread: %llu, holding gMutex, is created &amp;quot;, id);

  while(!gCalling) {
    LOG(&amp;quot;[%llu] waiting for output callback before running task &amp;quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)... &amp;quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&amp;quot;[%llu] Another AudioUnit is created! &amp;quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&amp;quot;Task thread: %llu is created &amp;quot;, id);
//
//   while(!gCalling) {
//     LOG(&amp;quot;[%llu] waiting for output callback before running task &amp;quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)... &amp;quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&amp;quot;[%llu] Another AudioUnit is created! &amp;quot;, id);
//
//   // Hold the mutex.
//   LOG(&amp;quot;[%llu] Try getting another mutex: gMutex... &amp;quot;, id);
//   locker guard(gMutex);
//
//   LOG(&amp;quot;[%llu] Got mutex finally! &amp;quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&amp;quot;Monitor thread %llu on thread %llu &amp;quot;, sid, id);

  unsigned int sec = 1;
  LOG(&amp;quot;[%llu] sleep %d seconds before checking task for thread %llu &amp;quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&amp;quot;[%llu] Kill the task thread %llu! &amp;quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&amp;#39;t be released,
    // so we need unlock it manually. Notice that we can&amp;#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&amp;quot; [%llu] Task is %sdone  &amp;quot;, id, gTaskDone ? &amp;quot;&amp;quot;: &amp;quot;NOT &amp;quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;amp;subject, NULL, task, NULL);
  pthread_create(&amp;amp;detector, NULL, watchdog, (void *) &amp;amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;amp;&amp;amp; &amp;quot;Callback should be fired!&amp;quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;amp;&amp;amp; &amp;quot;Deadlock detected!&amp;quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;amp;&amp;amp; &amp;quot;Killer is out of control!&amp;quot;);

  return 0;
}



The APIs called to play and stop the audio stream is:
#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &amp;lt;AudioUnit/AudioUnit.h&amp;gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H



#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;CoreAudio/CoreAudio.h&amp;gt;

#include &amp;quot;AudioStream.h&amp;quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;amp;&amp;amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &amp;quot;|&amp;quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&amp;#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&amp;gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&amp;lt;AudioStream*&amp;gt;(aRefCon); // Get arguments
  void* buffer = aData-&amp;gt;mBuffers[0].mData;
  as-&amp;gt;mCallback(buffer, aNumFrames);
  return noErr;
}



The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as Mutex-AU)
shared with AudioUnit.
The Mutex-AU is held inside it’s framework, so you don’t notice it.

Thus, if the callback thread requests another mutex M held by the another
thread, without releasing mutex-AU, then it will cause a deadlock when the
another thread, which holds the mutex M, request to use AudioUnit.



That is,
if we have a thread T, holding the mutex M



and one callback thread which holds the mutex-AU,



The deadlock will occur when the callback thread requests the mutex M
(the callback thread is blocked for waiting the mutex M)



and the thread T requests the mutex-AU to use AudioUnit</summary></entry><entry><title type="html">How to simulate a C++ class in C</title><link href="http://localhost:4000/post/how-to-simulate-a-c-class-in-c" rel="alternate" type="text/html" title="How to simulate a C++ class in C" /><published>2017-04-25T00:00:00+08:00</published><updated>2017-04-25T00:00:00+08:00</updated><id>http://localhost:4000/post/how-to-simulate-a-c-class-in-c</id><content type="html" xml:base="http://localhost:4000/post/how-to-simulate-a-c-class-in-c">&lt;h1 id=&quot;how-to-simulate-a-c-class-in-c&quot;&gt;How to simulate a C++ class in C&lt;/h1&gt;

&lt;p&gt;After learning &lt;em&gt;C++&lt;/em&gt;, I am curious about
how could I bring the &lt;em&gt;object-oriented&lt;/em&gt; style to &lt;em&gt;C&lt;/em&gt;.
Could we simulate a &lt;em&gt;C++&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; in C?&lt;/p&gt;

&lt;p&gt;To find the answer,
I implement a simple &lt;em&gt;linked list&lt;/em&gt; with &lt;em&gt;object-oriented&lt;/em&gt; style in plain &lt;em&gt;C&lt;/em&gt;.
The key is to use &lt;em&gt;function pointer&lt;/em&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; to
simulate a &lt;em&gt;C++&lt;/em&gt; member function.
you can find my code &lt;a href=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e&quot; title=&quot;Class in C for linked-list implementation&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To compare, I also implement a &lt;a href=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473&quot; title=&quot;Linked-list in C++&quot;&gt;&lt;em&gt;linked list&lt;/em&gt; in &lt;em&gt;C++&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;class-in-c&quot;&gt;Class in C&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef LIST_H
#define LIST_H

#include &amp;lt;stddef.h&amp;gt; // for size_t

struct Node {
  void* data; // Any data type can be stored in this node
  struct Node* next;
};

typedef void (*Callback)(struct Node* node);
struct List {
  struct Node* head;
  struct Node* cursor;

  void (* const destroy)(struct List* self);
  void (* const append)(struct List* self, void* data, size_t size);
  void (* const prepend)(struct List* self, void* data, size_t size);
  void (* const traverse)(struct List* self, Callback func);
};

extern const struct ListClass {
  struct List (*new)();
} /*ListProxy*/ List;

#endif // LIST_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=list.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;assert.h&amp;gt; // for assert
// #include &amp;lt;stddef.h&amp;gt; // for NULL, size_t, they are already included in list.h
#include &amp;lt;stdlib.h&amp;gt; // for calloc, free
#include &amp;lt;string.h&amp;gt; // for memcpy

// Using &amp;quot;static&amp;quot; prevents these functions from being exposed outside.

static void
destroy(struct List* self)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ;) {
    struct Node* next = cur-&amp;gt;next;
    free(cur-&amp;gt;data);
    free(cur);
    cur = next;
  }
  self-&amp;gt;head = self-&amp;gt;cursor = NULL;
}

static void
append(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = NULL;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  if (!self-&amp;gt;head) { // The list is empty.
    assert(!self-&amp;gt;cursor); // cursor = head = NULL now.
    self-&amp;gt;head = n;
  } else {
    assert(self-&amp;gt;cursor);
    self-&amp;gt;cursor-&amp;gt;next = n;
  }
  self-&amp;gt;cursor = n;
}

static void
prepend(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = self-&amp;gt;head;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  self-&amp;gt;head = n;
  if(!self-&amp;gt;cursor) { // The list is empty before inserting value.
    self-&amp;gt;cursor = n;
  }
}

static void
traverse(struct List* self, Callback func)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ; cur = cur-&amp;gt;next) {
    func(cur);
  }
}

static struct List
new()
{
  return (struct List) {
    .head = NULL,
    .cursor = NULL,
    .destroy = (void*) &amp;amp;destroy,
    .append = (void*) &amp;amp;append,
    .prepend = (void*) &amp;amp;prepend,
    .traverse = (void*) &amp;amp;traverse
  };
}

const struct ListClass /*ListProxy*/ List = {
  .new = &amp;amp;new,
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=list.c&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;stdbool.h&amp;gt;  // for bool
#include &amp;lt;stdio.h&amp;gt;    // for printf

#define VA_ARGS(...) , ##__VA_ARGS__
#define CALL(obj, method, ...) ((obj).method(&amp;amp;(obj) VA_ARGS(__VA_ARGS__)))

void print(struct Node* node, bool is_float)
{
  if (!node) {
    return;
  }
  is_float ? printf(&amp;quot;%f&amp;quot;, *(float*)node-&amp;gt;data) :
             printf(&amp;quot;%d&amp;quot;, *(int*)node-&amp;gt;data);
  printf(&amp;quot;%s&amp;quot;, (node-&amp;gt;next) ? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot;\n&amp;quot;);
}

void print_int(struct Node* node)
{
  print(node, false);
}

void print_float(struct Node* node)
{
  print(node, true);
}

int main()
{
  int data_int[6] = { 11, 22, 33, 44, 55, 66 };
  float data_float[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  struct List l = /*ListProxy*/List.new();
  l.prepend(&amp;amp;l, &amp;amp;data_int[0], sizeof(data_int[0]));
  l.append(&amp;amp;l, &amp;amp;data_int[1], sizeof(data_int[1]));
  l.append(&amp;amp;l, &amp;amp;data_int[2], sizeof(data_int[2]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[3], sizeof(data_int[3]));
  l.append(&amp;amp;l, &amp;amp;data_int[4], sizeof(data_int[4]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[5], sizeof(data_int[5]));
  l.traverse(&amp;amp;l, print_int);
  l.destroy(&amp;amp;l);

  CALL(l, prepend,  &amp;amp;data_float[0], sizeof(data_float[0]));
  CALL(l, append,   &amp;amp;data_float[1], sizeof(data_float[1]));
  CALL(l, append,   &amp;amp;data_float[2], sizeof(data_float[2]));
  CALL(l, prepend,  &amp;amp;data_float[3], sizeof(data_float[3]));
  CALL(l, append,   &amp;amp;data_float[4], sizeof(data_float[4]));
  CALL(l, prepend,  &amp;amp;data_float[5], sizeof(data_float[5]));
  CALL(l, traverse, print_float);
  CALL(l, destroy);

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=test.c&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;c-version&quot;&gt;C++ version&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef LIST_H
#define LIST_H

#include &amp;lt;assert.h&amp;gt; // for assert
#include &amp;lt;memory&amp;gt;   // for std::unique_ptr

template&amp;lt;typename T&amp;gt;
class List
{
public:
  struct Node // All it&amp;#39;s members are public by default.
  {
    Node(T aData, Node* aNext)
      : mData(aData)
      , mNext(aNext)
    {}

    ~Node() {}

    T mData;
    Node* mNext;
  };

  List();
  ~List();

  void Append(T aData);
  void Prepend(T aData);

  typedef void (*Callback)(Node* aNode);
  void Traverse(Callback aCallback);

private:
  // No need to use smart pointer in low-level data structure.
  // It&amp;#39;s more efficient for managing memory on our own.
  Node* mCursor;
  Node* mHead;
};

// nullptr is introduced in C++11.
template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List()
  : mCursor(nullptr)
  , mHead(nullptr)
{
}

template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
  for (mCursor = mHead ; mCursor != nullptr ;) {
    std::unique_ptr&amp;lt;Node&amp;gt; autoRelease(mCursor);
    // Update mCursor here instead of afterthought in for-loop,
    // in case mCursor is already released.
    mCursor = mCursor-&amp;gt;mNext;
    // The memory chuck pointed by old mCursor will be destroyed
    // upon leaving the &amp;#39;}&amp;#39;.
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Append(T aData)
{
  Node* n = new Node(aData, nullptr);
  if (!mHead) { // the list is empty.
    assert(!mCursor);
    mHead = n;
  } else {
    assert(mCursor);
    mCursor-&amp;gt;mNext = n;
  }
  mCursor = n;
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Prepend(T aData)
{
  Node* n = new Node(aData, mHead);
  mHead = n;
  if (!mCursor) { // The list is empty before inserting value.
    mCursor = n;
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Traverse(Callback aCallback)
{
  for (Node* cur = mHead ; cur != nullptr ; cur = cur-&amp;gt;mNext) {
    aCallback(cur);
  }
}

#endif // LIST_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473.js?file=list.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
void Print(T aData, bool aBreakline)
{
  std::cout &amp;lt;&amp;lt; aData &amp;lt;&amp;lt; ((aBreakline)? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot;\n&amp;quot;);
}

void PrintInt(List&amp;lt;int&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

void PrintFloat(List&amp;lt;float&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

int main()
{
  int dataInt[6] = { 11, 22, 33, 44, 55, 66 };
  float dataFloat[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  List&amp;lt;int&amp;gt; li;
  li.Prepend(dataInt[0]);
  li.Append(dataInt[1]);
  li.Append(dataInt[2]);
  li.Prepend(dataInt[3]);
  li.Append(dataInt[4]);
  li.Prepend(dataInt[5]);
  li.Traverse(PrintInt);

  List&amp;lt;float&amp;gt; lf;
  lf.Prepend(dataFloat[0]);
  lf.Append(dataFloat[1]);
  lf.Append(dataFloat[2]);
  lf.Prepend(dataFloat[3]);
  lf.Append(dataFloat[4]);
  lf.Prepend(dataFloat[5]);
  lf.Traverse(PrintFloat);

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473.js?file=test.cpp&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;comparison&quot;&gt;Comparison&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;The C version needs to call &lt;code class=&quot;highlighter-rouge&quot;&gt;destroy&lt;/code&gt; explicitly,
while the C++ version will automatically run deconstructor &lt;code class=&quot;highlighter-rouge&quot;&gt;~List()&lt;/code&gt;
to release the memory, or use smart pointers
like &lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt; to help memory management.
    &lt;ul&gt;
      &lt;li&gt;To release &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo* n = new Foo(...)&lt;/code&gt;, we need to use &lt;code class=&quot;highlighter-rouge&quot;&gt;delete n&lt;/code&gt;
instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;n-&amp;gt;~Foo()&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;Calling a destructor releases the resources owned by the object,
but it does not release the memory allocated to the object itself.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;We need to pass self pointer to the &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; structure
for calling functions to access list’s data,
while we don’t need to do that in C++ version
because class object can get all data inside itself in its implementation.&lt;/li&gt;
  &lt;li&gt;To allow storing different data type in the list,
the C++ version use &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;void*&lt;/code&gt; in the C version.
    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;void* data&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t size&lt;/code&gt;
is regarded as memory chunk beyond types,
pointed by &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; bytes,
so we can store different types data in &lt;strong&gt;runtime&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;While &lt;code class=&quot;highlighter-rouge&quot;&gt;template&amp;lt;typename T&amp;gt;&lt;/code&gt; let us to declare a variable
with type &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; in &lt;strong&gt;compile time&lt;/strong&gt;,
so &lt;em&gt;gcc/g++&lt;/em&gt; can help us for debugging if there is any error.
        &lt;ul&gt;
          &lt;li&gt;function with &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt; cannot be separated in &lt;code class=&quot;highlighter-rouge&quot;&gt;.cpp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;.h&lt;/code&gt;
because compiler needs to see both the template definition
and the specific types/whatever used to &lt;strong&gt;fill in&lt;/strong&gt; the template.
Please read &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl&quot; title=&quot;Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file&quot;&gt;this&lt;/a&gt; for more details.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Replace &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt; is always a pointer type. &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;(0) could cause ambiguity
when we have functions: &lt;code class=&quot;highlighter-rouge&quot;&gt;void f(int)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;void f(foo *)&lt;/code&gt;,
and we call &lt;code class=&quot;highlighter-rouge&quot;&gt;f(NULL)&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">How to simulate a C++ class in C

After learning C++, I am curious about
how could I bring the object-oriented style to C.
Could we simulate a C++ class by struct in C?

To find the answer,
I implement a simple linked list with object-oriented style in plain C.
The key is to use function pointer in struct to
simulate a C++ member function.
you can find my code here

To compare, I also implement a linked list in C++.

Class in C
#ifndef LIST_H
#define LIST_H

#include &amp;lt;stddef.h&amp;gt; // for size_t

struct Node {
  void* data; // Any data type can be stored in this node
  struct Node* next;
};

typedef void (*Callback)(struct Node* node);
struct List {
  struct Node* head;
  struct Node* cursor;

  void (* const destroy)(struct List* self);
  void (* const append)(struct List* self, void* data, size_t size);
  void (* const prepend)(struct List* self, void* data, size_t size);
  void (* const traverse)(struct List* self, Callback func);
};

extern const struct ListClass {
  struct List (*new)();
} /*ListProxy*/ List;

#endif // LIST_H


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;assert.h&amp;gt; // for assert
// #include &amp;lt;stddef.h&amp;gt; // for NULL, size_t, they are already included in list.h
#include &amp;lt;stdlib.h&amp;gt; // for calloc, free
#include &amp;lt;string.h&amp;gt; // for memcpy

// Using &amp;quot;static&amp;quot; prevents these functions from being exposed outside.

static void
destroy(struct List* self)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ;) {
    struct Node* next = cur-&amp;gt;next;
    free(cur-&amp;gt;data);
    free(cur);
    cur = next;
  }
  self-&amp;gt;head = self-&amp;gt;cursor = NULL;
}

static void
append(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = NULL;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  if (!self-&amp;gt;head) { // The list is empty.
    assert(!self-&amp;gt;cursor); // cursor = head = NULL now.
    self-&amp;gt;head = n;
  } else {
    assert(self-&amp;gt;cursor);
    self-&amp;gt;cursor-&amp;gt;next = n;
  }
  self-&amp;gt;cursor = n;
}

static void
prepend(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = self-&amp;gt;head;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  self-&amp;gt;head = n;
  if(!self-&amp;gt;cursor) { // The list is empty before inserting value.
    self-&amp;gt;cursor = n;
  }
}

static void
traverse(struct List* self, Callback func)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ; cur = cur-&amp;gt;next) {
    func(cur);
  }
}

static struct List
new()
{
  return (struct List) {
    .head = NULL,
    .cursor = NULL,
    .destroy = (void*) &amp;amp;destroy,
    .append = (void*) &amp;amp;append,
    .prepend = (void*) &amp;amp;prepend,
    .traverse = (void*) &amp;amp;traverse
  };
}

const struct ListClass /*ListProxy*/ List = {
  .new = &amp;amp;new,
};


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;stdbool.h&amp;gt;  // for bool
#include &amp;lt;stdio.h&amp;gt;    // for printf

#define VA_ARGS(...) , ##__VA_ARGS__
#define CALL(obj, method, ...) ((obj).method(&amp;amp;(obj) VA_ARGS(__VA_ARGS__)))

void print(struct Node* node, bool is_float)
{
  if (!node) {
    return;
  }
  is_float ? printf(&amp;quot;%f&amp;quot;, *(float*)node-&amp;gt;data) :
             printf(&amp;quot;%d&amp;quot;, *(int*)node-&amp;gt;data);
  printf(&amp;quot;%s&amp;quot;, (node-&amp;gt;next) ? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot; &amp;quot;);
}

void print_int(struct Node* node)
{
  print(node, false);
}

void print_float(struct Node* node)
{
  print(node, true);
}

int main()
{
  int data_int[6] = { 11, 22, 33, 44, 55, 66 };
  float data_float[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  struct List l = /*ListProxy*/List.new();
  l.prepend(&amp;amp;l, &amp;amp;data_int[0], sizeof(data_int[0]));
  l.append(&amp;amp;l, &amp;amp;data_int[1], sizeof(data_int[1]));
  l.append(&amp;amp;l, &amp;amp;data_int[2], sizeof(data_int[2]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[3], sizeof(data_int[3]));
  l.append(&amp;amp;l, &amp;amp;data_int[4], sizeof(data_int[4]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[5], sizeof(data_int[5]));
  l.traverse(&amp;amp;l, print_int);
  l.destroy(&amp;amp;l);

  CALL(l, prepend,  &amp;amp;data_float[0], sizeof(data_float[0]));
  CALL(l, append,   &amp;amp;data_float[1], sizeof(data_float[1]));
  CALL(l, append,   &amp;amp;data_float[2], sizeof(data_float[2]));
  CALL(l, prepend,  &amp;amp;data_float[3], sizeof(data_float[3]));
  CALL(l, append,   &amp;amp;data_float[4], sizeof(data_float[4]));
  CALL(l, prepend,  &amp;amp;data_float[5], sizeof(data_float[5]));
  CALL(l, traverse, print_float);
  CALL(l, destroy);

  return 0;
}


C++ version
#ifndef LIST_H
#define LIST_H

#include &amp;lt;assert.h&amp;gt; // for assert
#include &amp;lt;memory&amp;gt;   // for std::unique_ptr

template&amp;lt;typename T&amp;gt;
class List
{
public:
  struct Node // All it&amp;#39;s members are public by default.
  {
    Node(T aData, Node* aNext)
      : mData(aData)
      , mNext(aNext)
    {}

    ~Node() {}

    T mData;
    Node* mNext;
  };

  List();
  ~List();

  void Append(T aData);
  void Prepend(T aData);

  typedef void (*Callback)(Node* aNode);
  void Traverse(Callback aCallback);

private:
  // No need to use smart pointer in low-level data structure.
  // It&amp;#39;s more efficient for managing memory on our own.
  Node* mCursor;
  Node* mHead;
};

// nullptr is introduced in C++11.
template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List()
  : mCursor(nullptr)
  , mHead(nullptr)
{
}

template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
  for (mCursor = mHead ; mCursor != nullptr ;) {
    std::unique_ptr&amp;lt;Node&amp;gt; autoRelease(mCursor);
    // Update mCursor here instead of afterthought in for-loop,
    // in case mCursor is already released.
    mCursor = mCursor-&amp;gt;mNext;
    // The memory chuck pointed by old mCursor will be destroyed
    // upon leaving the &amp;#39;}&amp;#39;.
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Append(T aData)
{
  Node* n = new Node(aData, nullptr);
  if (!mHead) { // the list is empty.
    assert(!mCursor);
    mHead = n;
  } else {
    assert(mCursor);
    mCursor-&amp;gt;mNext = n;
  }
  mCursor = n;
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Prepend(T aData)
{
  Node* n = new Node(aData, mHead);
  mHead = n;
  if (!mCursor) { // The list is empty before inserting value.
    mCursor = n;
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Traverse(Callback aCallback)
{
  for (Node* cur = mHead ; cur != nullptr ; cur = cur-&amp;gt;mNext) {
    aCallback(cur);
  }
}

#endif // LIST_H


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
void Print(T aData, bool aBreakline)
{
  std::cout &amp;lt;&amp;lt; aData &amp;lt;&amp;lt; ((aBreakline)? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot; &amp;quot;);
}

void PrintInt(List&amp;lt;int&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

void PrintFloat(List&amp;lt;float&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

int main()
{
  int dataInt[6] = { 11, 22, 33, 44, 55, 66 };
  float dataFloat[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  List&amp;lt;int&amp;gt; li;
  li.Prepend(dataInt[0]);
  li.Append(dataInt[1]);
  li.Append(dataInt[2]);
  li.Prepend(dataInt[3]);
  li.Append(dataInt[4]);
  li.Prepend(dataInt[5]);
  li.Traverse(PrintInt);

  List&amp;lt;float&amp;gt; lf;
  lf.Prepend(dataFloat[0]);
  lf.Append(dataFloat[1]);
  lf.Append(dataFloat[2]);
  lf.Prepend(dataFloat[3]);
  lf.Append(dataFloat[4]);
  lf.Prepend(dataFloat[5]);
  lf.Traverse(PrintFloat);

  return 0;
}


Comparison

  The C version needs to call destroy explicitly,
while the C++ version will automatically run deconstructor ~List()
to release the memory, or use smart pointers
like unique_ptr to help memory management.
    
      To release Foo* n = new Foo(...), we need to use delete n
instead of n-&amp;gt;~Foo()
        
          Calling a destructor releases the resources owned by the object,
but it does not release the memory allocated to the object itself.
        
      
    
  
  We need to pass self pointer to the List structure
for calling functions to access list’s data,
while we don’t need to do that in C++ version
because class object can get all data inside itself in its implementation.
  To allow storing different data type in the list,
the C++ version use template instead of void* in the C version.
    
      The void* data with size_t size
is regarded as memory chunk beyond types,
pointed by data with size bytes,
so we can store different types data in runtime.
      While template&amp;lt;typename T&amp;gt; let us to declare a variable
with type T in compile time,
so gcc/g++ can help us for debugging if there is any error.
        
          function with template cannot be separated in .cpp and .h
because compiler needs to see both the template definition
and the specific types/whatever used to fill in the template.
Please read this for more details.
        
      
    
  
  Replace NULL with nullptr
    
      nullptr is always a pointer type. NULL(0) could cause ambiguity
when we have functions: void f(int), void f(foo *),
and we call f(NULL).</summary></entry><entry><title type="html">How to avoid duplicate symbols when compiling</title><link href="http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling" rel="alternate" type="text/html" title="How to avoid duplicate symbols when compiling" /><published>2017-04-08T00:00:00+08:00</published><updated>2017-04-08T00:00:00+08:00</updated><id>http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling</id><content type="html" xml:base="http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling">&lt;h1 id=&quot;how-to-avoid-duplicatesymbols-when-compiling&quot;&gt;How to avoid duplicate symbols when compiling&lt;/h1&gt;

&lt;p&gt;The error: &lt;code class=&quot;highlighter-rouge&quot;&gt;duplicate symbol for architecture x86_64&lt;/code&gt; will be prompted
if the following &lt;a href=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276&quot; title=&quot;gist&quot;&gt;files&lt;/a&gt; are compiled.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;makefile&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;CXX=g++
CFLAGS=-Wall
EXEC=run

all: bye.o hello.o
	$(CXX) $(CFLAGS) main.cpp bye.o hello.o -o $(EXEC)

bye.o: bye.cpp
	$(CXX) -c $(CFLAGS) bye.cpp

hello.o: hello.cpp
	$(CXX) -c $(CFLAGS) hello.cpp

clean:
	rm $(EXEC) *.o
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=makefile&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;main.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;hello.h&amp;quot;

int main()
{
  SayHello();
  SayBye();
  return 0;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=main.cpp&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;utils.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef UTILS_H
#define UTILS_H

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}

#endif /* UTILS_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=utils.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;hello.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef HELLO_H
#define HELLO_H

void SayHello();

#endif /* HELLO_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=hello.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;hello.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;hello.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayHello()
{
  LOG(&amp;quot;Hello&amp;quot;);
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=hello.cpp&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;bye.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef BYE_H
#define BYE_H

void SayBye();

#endif /* BYE_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=bye.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;bye.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayBye()
{
  LOG(&amp;quot;Goodbye&amp;quot;);
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=bye.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;You will see the &lt;code class=&quot;highlighter-rouge&quot;&gt;duplicate symbol for architecture x86_64&lt;/code&gt; error
when you compile those files.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
g++ -c -Wall bye.cpp
g++ -c -Wall hello.cpp
g++ -Wall main.cpp bye.o hello.o -o run
duplicate symbol __Z3LOGNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE in:
    bye.o
    hello.o
ld: 1 duplicate symbol for architecture x86_64
clang: error: linker command failed with exit code 1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use -v to see invocation&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
make: &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; [all] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The reason is that we include the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;utils.h&lt;/code&gt;)
into different files(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.cpp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.cpp&lt;/code&gt;),
and compile those files into different libraries(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.o&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.o&lt;/code&gt;),
so the functions in the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt;)
duplicate in those different libraries.&lt;/p&gt;

&lt;p&gt;Thus, when we try using those different libraries(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.o&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.o&lt;/code&gt;)
at the same time, there are duplicated symbols for functions(&lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt;)
included from the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;utils.h&lt;/code&gt;).
The program has no idea about which one it should call
among those duplicated symbols.&lt;/p&gt;

&lt;h2 id=&quot;solution-1-using-macros-instead-of-functions&quot;&gt;Solution 1: Using macros instead of functions&lt;/h2&gt;
&lt;p&gt;The macro is only textual substitution that expanded by the preprocessor,
so there is no symbol generated.&lt;/p&gt;

&lt;p&gt;You can replace function &lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt; by&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define LOG(s) (std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then the &lt;code class=&quot;highlighter-rouge&quot;&gt;SayBye()&lt;/code&gt; will be expanded into:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SayBye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Goodbye&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can run: &lt;code class=&quot;highlighter-rouge&quot;&gt;$ g++ -E &amp;lt;file_name&amp;gt;.cpp&lt;/code&gt; to watch
and confirm the preprocessor’s output.&lt;/p&gt;

&lt;h2 id=&quot;solution-2-make-functions-inline&quot;&gt;Solution 2: Make functions &lt;strong&gt;inline&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;It works almost same as macro.
Inline functions are actual functions
whose copy of the function body are injected directly into
each place the function is called.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The insertion occurs only if
the compiler’s cost/benefit analysis shows it to be profitable.
Same as the macros, inline expansion eliminates
the overhead associated with function calls.&lt;/p&gt;

&lt;p&gt;Inline functions are parsed by the compiler,
whereas macros are expanded by the preprocessor.
The preprocessor macros are just substitution patterns in code
before the compilation,
so there is no &lt;strong&gt;type-checking&lt;/strong&gt; at that time.
While inline functions are actual functions, so compiler can keep an eye on
type-checking issues to help debugging.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://chunminchang.gitbooks.io/cplusplus-learning-note/content/Appendix/preprocessor_macros_vs_inline_functions.html#inline-functions&quot; title=&quot;Inline functions&quot;&gt;here&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&quot;solution-3-using-static-to-make-functions-local-in-each-file&quot;&gt;Solution 3: Using &lt;strong&gt;static&lt;/strong&gt; to make functions local in each file&lt;/h2&gt;
&lt;p&gt;Since their states are &lt;strong&gt;not&lt;/strong&gt; sharable,
they should &lt;strong&gt;not&lt;/strong&gt; visible across each other.
Thus, the generated symbols are also local in each file.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">How to avoid duplicate symbols when compiling

The error: duplicate symbol for architecture x86_64 will be prompted
if the following files are compiled.


  makefile

CXX=g++
CFLAGS=-Wall
EXEC=run

all: bye.o hello.o
	$(CXX) $(CFLAGS) main.cpp bye.o hello.o -o $(EXEC)

bye.o: bye.cpp
	$(CXX) -c $(CFLAGS) bye.cpp

hello.o: hello.cpp
	$(CXX) -c $(CFLAGS) hello.cpp

clean:
	rm $(EXEC) *.o




  main.cpp

#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;hello.h&amp;quot;

int main()
{
  SayHello();
  SayBye();
  return 0;
}




  utils.h

#ifndef UTILS_H
#define UTILS_H

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}

#endif /* UTILS_H */




  hello.h

#ifndef HELLO_H
#define HELLO_H

void SayHello();

#endif /* HELLO_H */




  hello.cpp

#include &amp;quot;hello.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayHello()
{
  LOG(&amp;quot;Hello&amp;quot;);
}




  bye.h

#ifndef BYE_H
#define BYE_H

void SayBye();

#endif /* BYE_H */




  bye.cpp

#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayBye()
{
  LOG(&amp;quot;Goodbye&amp;quot;);
}



You will see the duplicate symbol for architecture x86_64 error
when you compile those files.
$ make
g++ -c -Wall bye.cpp
g++ -c -Wall hello.cpp
g++ -Wall main.cpp bye.o hello.o -o run
duplicate symbol __Z3LOGNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE in:
    bye.o
    hello.o
ld: 1 duplicate symbol for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [all] Error 1



The reason is that we include the shared header(utils.h)
into different files(bye.cpp and hello.cpp),
and compile those files into different libraries(bye.o and hello.o),
so the functions in the shared header(LOG)
duplicate in those different libraries.

Thus, when we try using those different libraries(bye.o and hello.o)
at the same time, there are duplicated symbols for functions(LOG)
included from the shared header(utils.h).
The program has no idea about which one it should call
among those duplicated symbols.

Solution 1: Using macros instead of functions
The macro is only textual substitution that expanded by the preprocessor,
so there is no symbol generated.

You can replace function LOG by
#define LOG(s) (std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl)



Then the SayBye() will be expanded into:
void SayBye()
{
  (std::cout &amp;lt;&amp;lt; &quot;Goodbye&quot; &amp;lt;&amp;lt; std::endl);
}



You can run: $ g++ -E &amp;lt;file_name&amp;gt;.cpp to watch
and confirm the preprocessor’s output.

Solution 2: Make functions inline
It works almost same as macro.
Inline functions are actual functions
whose copy of the function body are injected directly into
each place the function is called.

inline void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}



The insertion occurs only if
the compiler’s cost/benefit analysis shows it to be profitable.
Same as the macros, inline expansion eliminates
the overhead associated with function calls.

Inline functions are parsed by the compiler,
whereas macros are expanded by the preprocessor.
The preprocessor macros are just substitution patterns in code
before the compilation,
so there is no type-checking at that time.
While inline functions are actual functions, so compiler can keep an eye on
type-checking issues to help debugging.

See here for more details.

Solution 3: Using static to make functions local in each file
Since their states are not sharable,
they should not visible across each other.
Thus, the generated symbols are also local in each file.

static void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}</summary></entry><entry><title type="html">Running multiple Firefox at the same time</title><link href="http://localhost:4000/post/running-multiple-firefox-at-the-same-time" rel="alternate" type="text/html" title="Running multiple Firefox at the same time" /><published>2017-03-30T00:00:00+08:00</published><updated>2017-03-30T00:00:00+08:00</updated><id>http://localhost:4000/post/running-multiple-firefox-at-the-same-time</id><content type="html" xml:base="http://localhost:4000/post/running-multiple-firefox-at-the-same-time">&lt;h1 id=&quot;running-multiple-firefox-at-the-same-time&quot;&gt;Running multiple Firefox at the same time&lt;/h1&gt;

&lt;p&gt;I have two firefox: Firefox(normal version) and Firefox Developer Edition.
Today morning, I deleted the Firefox Developer Edition by &lt;em&gt;AppCleaner&lt;/em&gt;
and re-installed it, then something weird happened.&lt;/p&gt;

&lt;p&gt;When I opened the new Firefox Developer Edition
then launched my unchanged Firefox, the Firefox cannot be opened
and it showed an error: &lt;strong&gt;A copy of Firefox is already open.
Only one copy of Firefox an be opened at a time.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/a-copy-of-firefox-is-alreay-open.png&quot; alt=&quot;&quot; title=&quot;A copy of Firefox is already open&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AFAIK, the multiple Firefox instances are able to run at the same time,
if they use &lt;strong&gt;different profiles&lt;/strong&gt;.
Therefore, I opened &lt;code class=&quot;highlighter-rouge&quot;&gt;about:profiles&lt;/code&gt; on Firefox to check it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/firefox-about-profiles-wrong.png&quot; alt=&quot;&quot; title=&quot;Firefox - about:profiles(incorrect)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;From above, the setting was incorrect.
It should use &lt;em&gt;Profile: default&lt;/em&gt; instead of &lt;em&gt;Profile: dev-edition-default&lt;/em&gt;.
That’s why I cannot open Firefox and FirefoxDeveloperEdition at the same time.&lt;/p&gt;

&lt;p&gt;To fix the problem, I simply click &lt;em&gt;Set a default profile&lt;/em&gt;
under &lt;em&gt;Profile: default&lt;/em&gt;, then closed it, and relaunched it to check the setting.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/firefox-about-profiles-right.png&quot; alt=&quot;&quot; title=&quot;Firefox - about:profiles(correct)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I also checked the FirefoxDeveloperEdition’s setting
to make sure everything is fine.
&lt;img src=&quot;../images/posts/firefoxdeveloperedition-about-profiles.png&quot; alt=&quot;&quot; title=&quot;FirefoxDeveloperEdition - about:profiles&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I wrote this to remember how I fix it,
in case the same problem happens again.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Firefox" /><summary type="html">Running multiple Firefox at the same time

I have two firefox: Firefox(normal version) and Firefox Developer Edition.
Today morning, I deleted the Firefox Developer Edition by AppCleaner
and re-installed it, then something weird happened.

When I opened the new Firefox Developer Edition
then launched my unchanged Firefox, the Firefox cannot be opened
and it showed an error: A copy of Firefox is already open.
Only one copy of Firefox an be opened at a time.



AFAIK, the multiple Firefox instances are able to run at the same time,
if they use different profiles.
Therefore, I opened about:profiles on Firefox to check it.



From above, the setting was incorrect.
It should use Profile: default instead of Profile: dev-edition-default.
That’s why I cannot open Firefox and FirefoxDeveloperEdition at the same time.

To fix the problem, I simply click Set a default profile
under Profile: default, then closed it, and relaunched it to check the setting.



I also checked the FirefoxDeveloperEdition’s setting
to make sure everything is fine.


I wrote this to remember how I fix it,
in case the same problem happens again.</summary></entry><entry><title type="html">Requiring Android build-tools for Fennec</title><link href="http://localhost:4000/post/requiring-android-build-tools-for-fennec" rel="alternate" type="text/html" title="Requiring Android build-tools for Fennec" /><published>2017-03-22T00:00:00+08:00</published><updated>2017-03-22T00:00:00+08:00</updated><id>http://localhost:4000/post/requiring-android-build-tools-for-fennec</id><content type="html" xml:base="http://localhost:4000/post/requiring-android-build-tools-for-fennec">&lt;h1 id=&quot;requiring-android-build-tools-for-fennec&quot;&gt;Requiring Android build-tools for Fennec&lt;/h1&gt;

&lt;p&gt;To build fennec, I run &lt;code class=&quot;highlighter-rouge&quot;&gt;$./mach bootstrap&lt;/code&gt; under my &lt;em&gt;gecko-dev&lt;/em&gt; repo
and select &lt;em&gt;Firefox for Android&lt;/em&gt; to install all stuff for development.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Please choose the version of Firefox you want to build:
1. Firefox for Desktop Artifact Mode
2. Firefox for Desktop
3. Firefox for Android Artifact Mode
4. Firefox for Android

Note on Artifact Mode:
...
...

Your choice: 4

Looks like you have Homebrew installed. We will install all required packages via Homebrew.

...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, I create/modify the &lt;em&gt;mozconfig&lt;/em&gt;(or &lt;em&gt;.mozconfig&lt;/em&gt;) under my &lt;em&gt;gecko-dev&lt;/em&gt; repo:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Build Firefox for Android:
ac_add_options --enable-application=mobile/android
ac_add_options --target=arm-linux-androideabi

# With the following Android SDK and NDK:
ac_add_options --with-android-sdk=&quot;/Users/cchang/.mozbuild/android-sdk-macosx&quot;
ac_add_options --with-android-ndk=&quot;/Users/cchang/.mozbuild/android-ndk-r11c&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;However, there are still error shown when I build by &lt;code class=&quot;highlighter-rouge&quot;&gt;./mach build&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
...
 0:09.78 DEBUG: configure:10912: checking if app-specific confvars.sh exists
 0:09.78 DEBUG: configure:11077: checking for Android SDK platform version 23
 0:09.78 DEBUG: configure:11085: checking for Android build-tools
 0:09.78 DEBUG: configure: error: You must install the Android build-tools version 23.0.3.  Try |mach bootstrap|.  (Looked for /Users/cchang/.mozbuild/android-sdk-macosx/build-tools/23.0.3)
 0:09.78 ERROR: old-configure failed
 0:09.82 *** Fix above errors and then restart with               &quot;/Applications/Xcode.app/Contents/Developer/usr/bin/make -f client.mk build&quot;
 0:09.82 make: *** [configure] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To solve this, I check whether &lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/cchang/.mozbuild/android-sdk-macosx/build-tools/23.0.3&lt;/code&gt; exists.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls /Users/cchang/.mozbuild/android-sdk-macosx/
SDK Readme.txt	extras		platforms		tools
add-ons		platform-tools	temp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;There is really no &lt;code class=&quot;highlighter-rouge&quot;&gt;build-tools&lt;/code&gt;, so I need to install it by my own.&lt;/p&gt;

&lt;p&gt;I open the &lt;em&gt;SDK Readme.txt&lt;/em&gt; to know what I could do:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /Users/cchang/.mozbuild/android-sdk-macosx/
$ vim SDK\ Readme.txt
...
...
To start the SDK Manager, please execute the program &quot;android&quot;.

From the command-line you can also directly trigger an update by
executing:
  tools/android update sdk --no-ui

Tip: use --help to see the various command-line options.
...
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From above, we could run &lt;code class=&quot;highlighter-rouge&quot;&gt;$ ./tools/android&lt;/code&gt; to install what we need:
&lt;img src=&quot;../images/posts/android-sdk-manager.png&quot; alt=&quot;Android SDK Manager&quot; title=&quot;Android SDK Manager&quot; /&gt;
After the selected items are installed, we can successfully build the fennec!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
...
61:33.64 Overall system resources - Wall time: 3687s; CPU: 97%; Read bytes: 3304162816; Write bytes: 6230259712; Read time: 45476; Write time: 36725
61:33.64 Swap in/out (MB): 4092/2
61:34.40 /usr/local/bin/terminal-notifier -title Mozilla Build System -group mozbuild -message Build complete
61:34.69 We know it took a while, but your build finally finished successfully!
To view resource usage of the build, run |mach resource-usage|.
For more information on what to do now, see https://developer.mozilla.org/docs/Developer_Guide/So_You_Just_Built_Firefox
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Fennec" /><summary type="html">Requiring Android build-tools for Fennec

To build fennec, I run $./mach bootstrap under my gecko-dev repo
and select Firefox for Android to install all stuff for development.

Please choose the version of Firefox you want to build:
1. Firefox for Desktop Artifact Mode
2. Firefox for Desktop
3. Firefox for Android Artifact Mode
4. Firefox for Android

Note on Artifact Mode:
...
...

Your choice: 4

Looks like you have Homebrew installed. We will install all required packages via Homebrew.

...



Next, I create/modify the mozconfig(or .mozconfig) under my gecko-dev repo:
# Build Firefox for Android:
ac_add_options --enable-application=mobile/android
ac_add_options --target=arm-linux-androideabi

# With the following Android SDK and NDK:
ac_add_options --with-android-sdk=&quot;/Users/cchang/.mozbuild/android-sdk-macosx&quot;
ac_add_options --with-android-ndk=&quot;/Users/cchang/.mozbuild/android-ndk-r11c&quot;



However, there are still error shown when I build by ./mach build:
...
...
 0:09.78 DEBUG: configure:10912: checking if app-specific confvars.sh exists
 0:09.78 DEBUG: configure:11077: checking for Android SDK platform version 23
 0:09.78 DEBUG: configure:11085: checking for Android build-tools
 0:09.78 DEBUG: configure: error: You must install the Android build-tools version 23.0.3.  Try |mach bootstrap|.  (Looked for /Users/cchang/.mozbuild/android-sdk-macosx/build-tools/23.0.3)
 0:09.78 ERROR: old-configure failed
 0:09.82 *** Fix above errors and then restart with               &quot;/Applications/Xcode.app/Contents/Developer/usr/bin/make -f client.mk build&quot;
 0:09.82 make: *** [configure] Error 1



To solve this, I check whether /Users/cchang/.mozbuild/android-sdk-macosx/build-tools/23.0.3 exists.
$ ls /Users/cchang/.mozbuild/android-sdk-macosx/
SDK Readme.txt	extras		platforms		tools
add-ons		platform-tools	temp


There is really no build-tools, so I need to install it by my own.

I open the SDK Readme.txt to know what I could do:
$ cd /Users/cchang/.mozbuild/android-sdk-macosx/
$ vim SDK\ Readme.txt
...
...
To start the SDK Manager, please execute the program &quot;android&quot;.

From the command-line you can also directly trigger an update by
executing:
  tools/android update sdk --no-ui

Tip: use --help to see the various command-line options.
...
...



From above, we could run $ ./tools/android to install what we need:

After the selected items are installed, we can successfully build the fennec!

...
...
61:33.64 Overall system resources - Wall time: 3687s; CPU: 97%; Read bytes: 3304162816; Write bytes: 6230259712; Read time: 45476; Write time: 36725
61:33.64 Swap in/out (MB): 4092/2
61:34.40 /usr/local/bin/terminal-notifier -title Mozilla Build System -group mozbuild -message Build complete
61:34.69 We know it took a while, but your build finally finished successfully!
To view resource usage of the build, run |mach resource-usage|.
For more information on what to do now, see https://developer.mozilla.org/docs/Developer_Guide/So_You_Just_Built_Firefox</summary></entry><entry><title type="html">Lunar New Year</title><link href="http://localhost:4000/post/lunar-new-year" rel="alternate" type="text/html" title="Lunar New Year" /><published>2017-01-28T00:00:00+08:00</published><updated>2017-01-28T00:00:00+08:00</updated><id>http://localhost:4000/post/lunar-new-year</id><content type="html" xml:base="http://localhost:4000/post/lunar-new-year">&lt;h1 id=&quot;新年寄語&quot;&gt;新年寄語&lt;/h1&gt;

&lt;p&gt;今年終於把部落格架起來了，所以不免俗的來回顧過去和立定目標好了。
大學之後就很久沒寫關於生活的事情了，可能是人老了生活單純許多，沒有那麼多話好說了。
這幾年變化比較大的，大概是開始工作了吧。工作兩年了，最大的心得是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;人生最重要的是時間&lt;/li&gt;
  &lt;li&gt;環境影響成長&lt;/li&gt;
  &lt;li&gt;性格決定命運&lt;/li&gt;
&lt;/ul&gt;

&lt;!--read more--&gt;

&lt;h2 id=&quot;人生最重要的是時間&quot;&gt;人生最重要的是時間  &lt;/h2&gt;
&lt;p&gt;工作以來，最慶幸的改變是修正了臨時抱佛腳的個性。
長期的規劃需要經年努力的積累，而積累需要的就是時間。
實現理想的過程中，金錢只是用來換取時間的籌碼，買別人時間來省下自己的時間。
誰能最有效利用時間換取生理需求，誰就剩下更多的籌碼來實現理想。
出社會後留給自己的時間少了，才感嘆以往對於時間的虛度。
把握當下地專注自眼前的人事物，才是善用時間的生活方式。  &lt;/p&gt;

&lt;h2 id=&quot;環境影響成長&quot;&gt;環境影響成長&lt;/h2&gt;
&lt;p&gt; 當初對這份工作的期待，似乎只有「國際化」這個模糊的概念有沾到一點邊吧。
能跟全世界的人一起工作是一件很酷的事情。
夥伴們大都很有理想也兼具實力，最重要的是他們都一直不斷地精進自己。
身處這樣的環境讓我可以發現到自己需要加強的地方，也能感受到那種一起向前的氛圍，
進而內化成提醒自己每天都要進步的動力。
而最意外的收穫是多益程度從500+變成900+，雖然拿多益當標準有點弱，
但這是我從小到大第一次覺得到我英文還有救哈哈。
合作的同事幾乎都是外國人，所以每天都是用英文在溝通，不知不覺就進步了。
日常生活上，我也為了提升自己的英文能力，養成每日閱聽英文新聞的習慣。
活了這麼久才感受到環境(context)對人的重要性，要學好英文，首先要進入/創造一個適合學英文的環境。
就像許多人直接去國外打工或留學，生活周遭是全英文環境，學習速度自然就變快了許多。
不只是英文，其他事也一樣。如果周遭的人事物可以提供你快速成長的環境，那你的能力才能有效提升。
科學研究也指出，運動選手如果和比自己優秀的選手組隊，通常會比個人參賽表現出更亮眼的成績。
這就是環境對人的重要性，要變強的不二法門，就是去充滿強者的環境，這樣才能偷學。&lt;/p&gt;

&lt;h2 id=&quot;性格決定命運&quot;&gt;性格決定命運&lt;/h2&gt;
&lt;p&gt; 另一個值得高興的就是能認識各種神人。
各路大神各有千秋，很多大神不一定有頂尖的智商，但共通的是大神們都有鋼鐵般的意志力不斷地超越自己。
鐵打的實力絕不僅止是靠熟讀課本上的理論來養成，而是靠無數實戰經驗累積才能煉成。
人未必是出類拔萃的，但一定是獨一無二的。
出生和成長環境造就我們不同的天份和性格，我們無法成為別人，只能創造更好的自己。
人生就是在創造自己的過程。   在職涯的發展中，我認為最重要的是要養成堅毅的意志力(grit)。
意志力是年復一年對未來願景的堅持，是失敗後繼續堅持的動力。
人生是一場馬拉松，失敗或成功都只是一時的狀態，重要的是在這個過程中不斷的淬煉自己。&lt;/p&gt;

&lt;h2 id=&quot;回顧與未來&quot;&gt;回顧與未來&lt;/h2&gt;
&lt;p&gt; 工程師這個職業類別其實很晚才出現在我的考慮範圍內，
是在找了幾個朋友一起研讀自己覺得興趣的科目，
寫一些有趣的題目才發現：「喔，原來寫code似乎滿有趣的嘛。」
諷刺的是，做這件事情的起頭是不想讀研究所，因為不知道讀了要幹嘛。
研究所不想念還是念了，想去一般替代役結果還是服了研發替代替，
但我都沒有後悔啦(上成功嶺第一天就慶幸還好我研替…)。
雖然不知道我會當所謂的「工程師」多久，但這些計算思維應該會慢慢內化成一種思考方式，然後跟著我一輩子。
 其實我一直覺得用職業來分類人很奇怪，只會限制人的發展性。
反正我們都是人嘛，只在做不同的事罷了。
想做的事太多，時間太少，能把握的只有讓自己一天比一天進步。
明年的目標是重新研讀Computer Science的基礎知識，多貢獻一些開源專案，
讓自己的程式可以跑在更多地方，開發更多有用的服務。
還有，太久沒講台語也太久沒彈吉他，所以明年要讓台語輪轉一點，然後再做幾首台語歌吧！&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Life" /><category term="Goal" /><summary type="html">新年寄語

今年終於把部落格架起來了，所以不免俗的來回顧過去和立定目標好了。
大學之後就很久沒寫關於生活的事情了，可能是人老了生活單純許多，沒有那麼多話好說了。
這幾年變化比較大的，大概是開始工作了吧。工作兩年了，最大的心得是：


  人生最重要的是時間
  環境影響成長
  性格決定命運</summary></entry></feed>
