<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-05-06T12:09:45+08:00</updated><id>http://localhost:4000//</id><title type="html">Peak Up</title><subtitle>everyday surpass myself</subtitle><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><entry><title type="html">Pthread mutex with different types</title><link href="http://localhost:4000/post/pthread-mutex-with-different-types" rel="alternate" type="text/html" title="Pthread mutex with different types" /><published>2017-05-06T00:00:00+08:00</published><updated>2017-05-06T00:00:00+08:00</updated><id>http://localhost:4000/post/pthread-mutex-with-different-types</id><content type="html" xml:base="http://localhost:4000/post/pthread-mutex-with-different-types">&lt;p&gt;When I tried to &lt;a href=&quot;deadlock-when-using-audiounit&quot;&gt;produce a deadlock in &lt;em&gt;CoreAudio&lt;/em&gt;&lt;/a&gt; with pthread,
I realized that the &lt;em&gt;mutex&lt;/em&gt; with &lt;strong&gt;NORMAL&lt;/strong&gt; type locked by one pthread
could be unlocked by another pthread.
Normally, this behavior should be &lt;strong&gt;disallowed&lt;/strong&gt;.
It will result in undefined behaviors.
If one pthread could unlock a mutex owned by other thread whenever it wants,
then the mutex will be meaningless,
unless it’s a expected behavior.&lt;/p&gt;

&lt;p&gt;In my case, it’s exactly what I want, 
because I need to break the deadlock to continue the program.
However, in most case, this behavior should be &lt;strong&gt;forbidden&lt;/strong&gt;,
so I do some research about
what the behaviors of mutexes with different types are.&lt;/p&gt;

&lt;p&gt;Here is my conclusion:&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;# pthread

Sample code for demonstrating different behavior
in different pthread type
- *PTHREAD_MUTEX_NORMAL*
  - This type of mutex does **not** detect deadlock
  - A thread attempting to relock this mutex without first unlocking it
    shall deadlock
  - A thread attempting to unlock a mutex locked by a different thread
    results in undefined behavior
  - A thread attempting to unlock an unlocked mutex
    results in undefined behavior
- *PTHREAD_MUTEX_ERRORCHECK*
  - This type of mutex provides error checking
  - A thread attempting to relock this mutex without first unlocking
    it shall return with an error
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_RECURSIVE*
  - A thread attempting to relock this mutex without first unlocking it
    shall succeed in locking the mutex
    - The relocking is allowd only in the **same** thread
    - The relocking deadlock which can occur with mutexes of type
      *PTHREAD_MUTEX_NORMAL* **cannot** occur with this type of mutex
    - Multiple locks of this mutex shall require the same number of unlocks
      to release the mutex before another thread can acquire the mutex
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_DEFAULT*
  - Its default value is set to *PTHREAD_MUTEX_NORMAL*
  - It&amp;#39;s allowed to map its value to other types

## Scenarios and results
We have four scenarios:
1. Lock a locked mutex in same thread
2. Unlock a unlocked mutex
3. (Wait to) Lock a locked mutex owned by another thread (__normal use case__)
4. Unlock a locked mutex owned by another thread

Unlocking a mutex owned by current thread is definitely ok,
so it&amp;#39;s exclusive in our scenarios.

The results of our scenarios in different type is:

|            | 1 | 2 | 3 | 4 |
|------------|---|---|---|---|
| NORMAL     | ! | v | v | v |
| ERRORCHECK |   |   | v |   |
| RECURSIVE  | v |   | v |   |
| DEFAULT    | ! | v | v | v |

- ```!```: It works without any error, but it will be **self-deadlocked**
- ```v```: It works without any error
- empty: It can not works, with an error returned


## TODO
- Sample code for ```pthread_kill``` and ```pthread_detach```


## Note

### pthread_mutex_trylock
The ```pthread_mutex_trylock()``` shall be equivalent
to ```pthread_mutex_lock()```,
except that if the mutex object referenced by mutex is currently locked
(by any thread, including the current thread),
the call shall return immediately.
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/fe46f3760e2230c09675e258ae1cf8eb.js?file=README.md&quot;&gt; &lt;/script&gt;

&lt;p&gt;The test code can be found on &lt;a href=&quot;https://gist.github.com/ChunMinChang/fe46f3760e2230c09675e258ae1cf8eb&quot;&gt;gist here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="Multithread" /><summary type="html">When I tried to produce a deadlock in CoreAudio with pthread,
I realized that the mutex with NORMAL type locked by one pthread
could be unlocked by another pthread.
Normally, this behavior should be disallowed.
It will result in undefined behaviors.
If one pthread could unlock a mutex owned by other thread whenever it wants,
then the mutex will be meaningless,
unless it’s a expected behavior.

In my case, it’s exactly what I want, 
because I need to break the deadlock to continue the program.
However, in most case, this behavior should be forbidden,
so I do some research about
what the behaviors of mutexes with different types are.

Here is my conclusion:

# pthread

Sample code for demonstrating different behavior
in different pthread type
- *PTHREAD_MUTEX_NORMAL*
  - This type of mutex does **not** detect deadlock
  - A thread attempting to relock this mutex without first unlocking it
    shall deadlock
  - A thread attempting to unlock a mutex locked by a different thread
    results in undefined behavior
  - A thread attempting to unlock an unlocked mutex
    results in undefined behavior
- *PTHREAD_MUTEX_ERRORCHECK*
  - This type of mutex provides error checking
  - A thread attempting to relock this mutex without first unlocking
    it shall return with an error
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_RECURSIVE*
  - A thread attempting to relock this mutex without first unlocking it
    shall succeed in locking the mutex
    - The relocking is allowd only in the **same** thread
    - The relocking deadlock which can occur with mutexes of type
      *PTHREAD_MUTEX_NORMAL* **cannot** occur with this type of mutex
    - Multiple locks of this mutex shall require the same number of unlocks
      to release the mutex before another thread can acquire the mutex
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_DEFAULT*
  - Its default value is set to *PTHREAD_MUTEX_NORMAL*
  - It&amp;#39;s allowed to map its value to other types

## Scenarios and results
We have four scenarios:
1. Lock a locked mutex in same thread
2. Unlock a unlocked mutex
3. (Wait to) Lock a locked mutex owned by another thread (__normal use case__)
4. Unlock a locked mutex owned by another thread

Unlocking a mutex owned by current thread is definitely ok,
so it&amp;#39;s exclusive in our scenarios.

The results of our scenarios in different type is:

|            | 1 | 2 | 3 | 4 |
|------------|---|---|---|---|
| NORMAL     | ! | v | v | v |
| ERRORCHECK |   |   | v |   |
| RECURSIVE  | v |   | v |   |
| DEFAULT    | ! | v | v | v |

- ```!```: It works without any error, but it will be **self-deadlocked**
- ```v```: It works without any error
- empty: It can not works, with an error returned


## TODO
- Sample code for ```pthread_kill``` and ```pthread_detach```


## Note

### pthread_mutex_trylock
The ```pthread_mutex_trylock()``` shall be equivalent
to ```pthread_mutex_lock()```,
except that if the mutex object referenced by mutex is currently locked
(by any thread, including the current thread),
the call shall return immediately.



The test code can be found on gist here</summary></entry><entry><title type="html">Deadlock when using AudioUnit</title><link href="http://localhost:4000/post/deadlock-when-using-audiounit" rel="alternate" type="text/html" title="Deadlock when using AudioUnit" /><published>2017-05-05T00:00:00+08:00</published><updated>2017-05-05T00:00:00+08:00</updated><id>http://localhost:4000/post/deadlock-when-using-audiounit</id><content type="html" xml:base="http://localhost:4000/post/deadlock-when-using-audiounit">&lt;p&gt;There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1337805&quot;&gt;bug here&lt;/a&gt;.
It &lt;strong&gt;only happens on OSX&lt;/strong&gt;.
After &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1350511#c1&quot;&gt;analysis&lt;/a&gt;,
I wrote a test to prevent others from getting into the same problem.
The test is added to &lt;a href=&quot;https://github.com/ChunMinChang/cubeb&quot;&gt;cubeb&lt;/a&gt;,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of &lt;a href=&quot;https://github.com/ChunMinChang/cubeb/blob/8939c0d168a27b1d5047779caad46835ca4651b9/test/test_deadlock.cpp#L1-L43&quot;&gt;the deadlock&lt;/a&gt;)
in the test.&lt;/p&gt;

&lt;p&gt;However, the code is not easy enough for those who are not familir with &lt;em&gt;cubeb&lt;/em&gt;,
so I wrote a general version to highlight the issue to
everyone who uses &lt;em&gt;AudioUnit&lt;/em&gt; in their audio backend.
You can find the code on &lt;a href=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9&quot;&gt;gist here&lt;/a&gt;&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &amp;lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&amp;gt; Thread B

#include &amp;lt;assert.h&amp;gt;               // for assert
#include &amp;lt;pthread.h&amp;gt;              // for pthread
#include &amp;lt;signal.h&amp;gt;               // for signal
#include &amp;lt;unistd.h&amp;gt;               // for sleep, usleep

#include &amp;quot;AudioStream.h&amp;quot;          // for AudioStream
#include &amp;quot;utils.h&amp;quot;                // for LOG
#include &amp;quot;OwnedCriticalSection.h&amp;quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&amp;#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&amp;lt;OwnedCriticalSection&amp;gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&amp;quot;pending task thread is killed!\n&amp;quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;amp;&amp;amp; LOG(&amp;quot;Output callback is on thread %llu, holding mutex_AU\n&amp;quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&amp;#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&amp;quot;[%llu] Force to switch threads\n&amp;quot;, id);
    usleep(10000);
  }

  LOG(&amp;quot;[%llu] Try getting another mutex: gMutex...\n&amp;quot;, id);
  locker guard(gMutex);

  LOG(&amp;quot;[%llu] Got mutex finally!\n&amp;quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&amp;quot;Task thread: %llu, holding gMutex, is created\n&amp;quot;, id);

  while(!gCalling) {
    LOG(&amp;quot;[%llu] waiting for output callback before running task\n&amp;quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&amp;quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&amp;quot;[%llu] Another AudioUnit is created!\n&amp;quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&amp;quot;Task thread: %llu is created\n&amp;quot;, id);
//
//   while(!gCalling) {
//     LOG(&amp;quot;[%llu] waiting for output callback before running task\n&amp;quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&amp;quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&amp;quot;[%llu] Another AudioUnit is created!\n&amp;quot;, id);
//
//   // Hold the mutex.
//   LOG(&amp;quot;[%llu] Try getting another mutex: gMutex...\n&amp;quot;, id);
//   locker guard(gMutex);
//
//   LOG(&amp;quot;[%llu] Got mutex finally!\n&amp;quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&amp;quot;Monitor thread %llu on thread %llu\n&amp;quot;, sid, id);

  unsigned int sec = 1;
  LOG(&amp;quot;[%llu] sleep %d seconds before checking task for thread %llu\n&amp;quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&amp;quot;[%llu] Kill the task thread %llu!\n&amp;quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&amp;#39;t be released,
    // so we need unlock it manually. Notice that we can&amp;#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&amp;quot;\n[%llu] Task is %sdone\n\n&amp;quot;, id, gTaskDone ? &amp;quot;&amp;quot;: &amp;quot;NOT &amp;quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;amp;subject, NULL, task, NULL);
  pthread_create(&amp;amp;detector, NULL, watchdog, (void *) &amp;amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;amp;&amp;amp; &amp;quot;Callback should be fired!&amp;quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;amp;&amp;amp; &amp;quot;Deadlock detected!&amp;quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;amp;&amp;amp; &amp;quot;Killer is out of control!&amp;quot;);

  return 0;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=test_deadlock.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;The APIs called to play and stop the audio stream is:&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &amp;lt;AudioUnit/AudioUnit.h&amp;gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;CoreAudio/CoreAudio.h&amp;gt;

#include &amp;quot;AudioStream.h&amp;quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;amp;&amp;amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &amp;quot;|&amp;quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&amp;#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&amp;gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&amp;lt;AudioStream*&amp;gt;(aRefCon); // Get arguments
  void* buffer = aData-&amp;gt;mBuffers[0].mData;
  as-&amp;gt;mCallback(buffer, aNumFrames);
  return noErr;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as &lt;em&gt;Mutex-AU&lt;/em&gt;)
shared with &lt;em&gt;AudioUnit&lt;/em&gt;.
The &lt;em&gt;Mutex-AU&lt;/em&gt; is held inside it’s framework, so you don’t notice it.&lt;/p&gt;

&lt;p&gt;Thus, if the callback thread requests another &lt;em&gt;mutex M&lt;/em&gt; held by the another
thread, without releasing &lt;em&gt;mutex-AU&lt;/em&gt;, then it will cause a deadlock when the
another thread, which holds the &lt;em&gt;mutex M&lt;/em&gt;, request to use AudioUnit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That is,
if we have a &lt;em&gt;thread T&lt;/em&gt;, holding the &lt;em&gt;mutex M&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and one &lt;em&gt;callback thread&lt;/em&gt; which holds the &lt;em&gt;mutex-AU&lt;/em&gt;,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The deadlock will occur when the &lt;em&gt;callback thread&lt;/em&gt; requests the &lt;em&gt;mutex M&lt;/em&gt;
(the callback thread is blocked for waiting the &lt;em&gt;mutex M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and the &lt;em&gt;thread T&lt;/em&gt; requests the &lt;em&gt;mutex-AU&lt;/em&gt; to use AudioUnit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Media" /><category term="CoreAudio" /><category term="Multithread" /><summary type="html">There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the bug here.
It only happens on OSX.
After analysis,
I wrote a test to prevent others from getting into the same problem.
The test is added to cubeb,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of the deadlock)
in the test.

However, the code is not easy enough for those who are not familir with cubeb,
so I wrote a general version to highlight the issue to
everyone who uses AudioUnit in their audio backend.
You can find the code on gist here

// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &amp;lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&amp;gt; Thread B

#include &amp;lt;assert.h&amp;gt;               // for assert
#include &amp;lt;pthread.h&amp;gt;              // for pthread
#include &amp;lt;signal.h&amp;gt;               // for signal
#include &amp;lt;unistd.h&amp;gt;               // for sleep, usleep

#include &amp;quot;AudioStream.h&amp;quot;          // for AudioStream
#include &amp;quot;utils.h&amp;quot;                // for LOG
#include &amp;quot;OwnedCriticalSection.h&amp;quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&amp;#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&amp;lt;OwnedCriticalSection&amp;gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&amp;quot;pending task thread is killed! &amp;quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;amp;&amp;amp; LOG(&amp;quot;Output callback is on thread %llu, holding mutex_AU &amp;quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&amp;#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&amp;quot;[%llu] Force to switch threads &amp;quot;, id);
    usleep(10000);
  }

  LOG(&amp;quot;[%llu] Try getting another mutex: gMutex... &amp;quot;, id);
  locker guard(gMutex);

  LOG(&amp;quot;[%llu] Got mutex finally! &amp;quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&amp;quot;Task thread: %llu, holding gMutex, is created &amp;quot;, id);

  while(!gCalling) {
    LOG(&amp;quot;[%llu] waiting for output callback before running task &amp;quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)... &amp;quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&amp;quot;[%llu] Another AudioUnit is created! &amp;quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&amp;quot;Task thread: %llu is created &amp;quot;, id);
//
//   while(!gCalling) {
//     LOG(&amp;quot;[%llu] waiting for output callback before running task &amp;quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)... &amp;quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&amp;quot;[%llu] Another AudioUnit is created! &amp;quot;, id);
//
//   // Hold the mutex.
//   LOG(&amp;quot;[%llu] Try getting another mutex: gMutex... &amp;quot;, id);
//   locker guard(gMutex);
//
//   LOG(&amp;quot;[%llu] Got mutex finally! &amp;quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&amp;quot;Monitor thread %llu on thread %llu &amp;quot;, sid, id);

  unsigned int sec = 1;
  LOG(&amp;quot;[%llu] sleep %d seconds before checking task for thread %llu &amp;quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&amp;quot;[%llu] Kill the task thread %llu! &amp;quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&amp;#39;t be released,
    // so we need unlock it manually. Notice that we can&amp;#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&amp;quot; [%llu] Task is %sdone  &amp;quot;, id, gTaskDone ? &amp;quot;&amp;quot;: &amp;quot;NOT &amp;quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;amp;subject, NULL, task, NULL);
  pthread_create(&amp;amp;detector, NULL, watchdog, (void *) &amp;amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;amp;&amp;amp; &amp;quot;Callback should be fired!&amp;quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;amp;&amp;amp; &amp;quot;Deadlock detected!&amp;quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;amp;&amp;amp; &amp;quot;Killer is out of control!&amp;quot;);

  return 0;
}



The APIs called to play and stop the audio stream is:
#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &amp;lt;AudioUnit/AudioUnit.h&amp;gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H



#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;CoreAudio/CoreAudio.h&amp;gt;

#include &amp;quot;AudioStream.h&amp;quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;amp;&amp;amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &amp;quot;|&amp;quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&amp;#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&amp;gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&amp;lt;AudioStream*&amp;gt;(aRefCon); // Get arguments
  void* buffer = aData-&amp;gt;mBuffers[0].mData;
  as-&amp;gt;mCallback(buffer, aNumFrames);
  return noErr;
}



The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as Mutex-AU)
shared with AudioUnit.
The Mutex-AU is held inside it’s framework, so you don’t notice it.

Thus, if the callback thread requests another mutex M held by the another
thread, without releasing mutex-AU, then it will cause a deadlock when the
another thread, which holds the mutex M, request to use AudioUnit.



That is,
if we have a thread T, holding the mutex M



and one callback thread which holds the mutex-AU,



The deadlock will occur when the callback thread requests the mutex M
(the callback thread is blocked for waiting the mutex M)



and the thread T requests the mutex-AU to use AudioUnit</summary></entry><entry><title type="html">How to simulate a C++ class in C</title><link href="http://localhost:4000/post/how-to-simulate-a-c-class-in-c" rel="alternate" type="text/html" title="How to simulate a C++ class in C" /><published>2017-04-25T00:00:00+08:00</published><updated>2017-04-25T00:00:00+08:00</updated><id>http://localhost:4000/post/how-to-simulate-a-c-class-in-c</id><content type="html" xml:base="http://localhost:4000/post/how-to-simulate-a-c-class-in-c">&lt;h1 id=&quot;how-to-simulate-a-c-class-in-c&quot;&gt;How to simulate a C++ class in C&lt;/h1&gt;

&lt;p&gt;After learning &lt;em&gt;C++&lt;/em&gt;, I am curious about
how could I bring the &lt;em&gt;object-oriented&lt;/em&gt; style to &lt;em&gt;C&lt;/em&gt;.
Could we simulate a &lt;em&gt;C++&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; in C?&lt;/p&gt;

&lt;p&gt;To find the answer,
I implement a simple &lt;em&gt;linked list&lt;/em&gt; with &lt;em&gt;object-oriented&lt;/em&gt; style in plain &lt;em&gt;C&lt;/em&gt;.
The key is to use &lt;em&gt;function pointer&lt;/em&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; to
simulate a &lt;em&gt;C++&lt;/em&gt; member function.
you can find my code &lt;a href=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e&quot; title=&quot;Class in C for linked-list implementation&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To compare, I also implement a &lt;a href=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473&quot; title=&quot;Linked-list in C++&quot;&gt;&lt;em&gt;linked list&lt;/em&gt; in &lt;em&gt;C++&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;class-in-c&quot;&gt;Class in C&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef LIST_H
#define LIST_H

#include &amp;lt;stddef.h&amp;gt; // for size_t

struct Node {
  void* data; // Any data type can be stored in this node
  struct Node* next;
};

typedef void (*Callback)(struct Node* node);
struct List {
  struct Node* head;
  struct Node* cursor;

  void (* const destroy)(struct List* self);
  void (* const append)(struct List* self, void* data, size_t size);
  void (* const prepend)(struct List* self, void* data, size_t size);
  void (* const traverse)(struct List* self, Callback func);
};

extern const struct ListClass {
  struct List (*new)();
} /*ListProxy*/ List;

#endif // LIST_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=list.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;assert.h&amp;gt; // for assert
// #include &amp;lt;stddef.h&amp;gt; // for NULL, size_t, they are already included in list.h
#include &amp;lt;stdlib.h&amp;gt; // for calloc, free
#include &amp;lt;string.h&amp;gt; // for memcpy

// Using &amp;quot;static&amp;quot; prevents these functions from being exposed outside.

static void
destroy(struct List* self)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ;) {
    struct Node* next = cur-&amp;gt;next;
    free(cur-&amp;gt;data);
    free(cur);
    cur = next;
  }
  self-&amp;gt;head = self-&amp;gt;cursor = NULL;
}

static void
append(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = NULL;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  if (!self-&amp;gt;head) { // The list is empty.
    assert(!self-&amp;gt;cursor); // cursor = head = NULL now.
    self-&amp;gt;head = n;
  } else {
    assert(self-&amp;gt;cursor);
    self-&amp;gt;cursor-&amp;gt;next = n;
  }
  self-&amp;gt;cursor = n;
}

static void
prepend(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = self-&amp;gt;head;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  self-&amp;gt;head = n;
  if(!self-&amp;gt;cursor) { // The list is empty before inserting value.
    self-&amp;gt;cursor = n;
  }
}

static void
traverse(struct List* self, Callback func)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ; cur = cur-&amp;gt;next) {
    func(cur);
  }
}

static struct List
new()
{
  return (struct List) {
    .head = NULL,
    .cursor = NULL,
    .destroy = (void*) &amp;amp;destroy,
    .append = (void*) &amp;amp;append,
    .prepend = (void*) &amp;amp;prepend,
    .traverse = (void*) &amp;amp;traverse
  };
}

const struct ListClass /*ListProxy*/ List = {
  .new = &amp;amp;new,
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=list.c&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;stdbool.h&amp;gt;  // for bool
#include &amp;lt;stdio.h&amp;gt;    // for printf

#define VA_ARGS(...) , ##__VA_ARGS__
#define CALL(obj, method, ...) ((obj).method(&amp;amp;(obj) VA_ARGS(__VA_ARGS__)))

void print(struct Node* node, bool is_float)
{
  if (!node) {
    return;
  }
  is_float ? printf(&amp;quot;%f&amp;quot;, *(float*)node-&amp;gt;data) :
             printf(&amp;quot;%d&amp;quot;, *(int*)node-&amp;gt;data);
  printf(&amp;quot;%s&amp;quot;, (node-&amp;gt;next) ? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot;\n&amp;quot;);
}

void print_int(struct Node* node)
{
  print(node, false);
}

void print_float(struct Node* node)
{
  print(node, true);
}

int main()
{
  int data_int[6] = { 11, 22, 33, 44, 55, 66 };
  float data_float[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  struct List l = /*ListProxy*/List.new();
  l.prepend(&amp;amp;l, &amp;amp;data_int[0], sizeof(data_int[0]));
  l.append(&amp;amp;l, &amp;amp;data_int[1], sizeof(data_int[1]));
  l.append(&amp;amp;l, &amp;amp;data_int[2], sizeof(data_int[2]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[3], sizeof(data_int[3]));
  l.append(&amp;amp;l, &amp;amp;data_int[4], sizeof(data_int[4]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[5], sizeof(data_int[5]));
  l.traverse(&amp;amp;l, print_int);
  l.destroy(&amp;amp;l);

  CALL(l, prepend,  &amp;amp;data_float[0], sizeof(data_float[0]));
  CALL(l, append,   &amp;amp;data_float[1], sizeof(data_float[1]));
  CALL(l, append,   &amp;amp;data_float[2], sizeof(data_float[2]));
  CALL(l, prepend,  &amp;amp;data_float[3], sizeof(data_float[3]));
  CALL(l, append,   &amp;amp;data_float[4], sizeof(data_float[4]));
  CALL(l, prepend,  &amp;amp;data_float[5], sizeof(data_float[5]));
  CALL(l, traverse, print_float);
  CALL(l, destroy);

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=test.c&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;c-version&quot;&gt;C++ version&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef LIST_H
#define LIST_H

#include &amp;lt;assert.h&amp;gt; // for assert
#include &amp;lt;memory&amp;gt;   // for std::unique_ptr

template&amp;lt;typename T&amp;gt;
class List
{
public:
  struct Node // All it&amp;#39;s members are public by default.
  {
    Node(T aData, Node* aNext)
      : mData(aData)
      , mNext(aNext)
    {}

    ~Node() {}

    T mData;
    Node* mNext;
  };

  List();
  ~List();

  void Append(T aData);
  void Prepend(T aData);

  typedef void (*Callback)(Node* aNode);
  void Traverse(Callback aCallback);

private:
  // No need to use smart pointer in low-level data structure.
  // It&amp;#39;s more efficient for managing memory on our own.
  Node* mCursor;
  Node* mHead;
};

// nullptr is introduced in C++11.
template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List()
  : mCursor(nullptr)
  , mHead(nullptr)
{
}

template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
  for (mCursor = mHead ; mCursor != nullptr ;) {
    std::unique_ptr&amp;lt;Node&amp;gt; autoRelease(mCursor);
    // Update mCursor here instead of afterthought in for-loop,
    // in case mCursor is already released.
    mCursor = mCursor-&amp;gt;mNext;
    // The memory chuck pointed by old mCursor will be destroyed
    // upon leaving the &amp;#39;}&amp;#39;.
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Append(T aData)
{
  Node* n = new Node(aData, nullptr);
  if (!mHead) { // the list is empty.
    assert(!mCursor);
    mHead = n;
  } else {
    assert(mCursor);
    mCursor-&amp;gt;mNext = n;
  }
  mCursor = n;
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Prepend(T aData)
{
  Node* n = new Node(aData, mHead);
  mHead = n;
  if (!mCursor) { // The list is empty before inserting value.
    mCursor = n;
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Traverse(Callback aCallback)
{
  for (Node* cur = mHead ; cur != nullptr ; cur = cur-&amp;gt;mNext) {
    aCallback(cur);
  }
}

#endif // LIST_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473.js?file=list.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
void Print(T aData, bool aBreakline)
{
  std::cout &amp;lt;&amp;lt; aData &amp;lt;&amp;lt; ((aBreakline)? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot;\n&amp;quot;);
}

void PrintInt(List&amp;lt;int&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

void PrintFloat(List&amp;lt;float&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

int main()
{
  int dataInt[6] = { 11, 22, 33, 44, 55, 66 };
  float dataFloat[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  List&amp;lt;int&amp;gt; li;
  li.Prepend(dataInt[0]);
  li.Append(dataInt[1]);
  li.Append(dataInt[2]);
  li.Prepend(dataInt[3]);
  li.Append(dataInt[4]);
  li.Prepend(dataInt[5]);
  li.Traverse(PrintInt);

  List&amp;lt;float&amp;gt; lf;
  lf.Prepend(dataFloat[0]);
  lf.Append(dataFloat[1]);
  lf.Append(dataFloat[2]);
  lf.Prepend(dataFloat[3]);
  lf.Append(dataFloat[4]);
  lf.Prepend(dataFloat[5]);
  lf.Traverse(PrintFloat);

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473.js?file=test.cpp&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;comparison&quot;&gt;Comparison&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;The C version needs to call &lt;code class=&quot;highlighter-rouge&quot;&gt;destroy&lt;/code&gt; explicitly,
while the C++ version will automatically run deconstructor &lt;code class=&quot;highlighter-rouge&quot;&gt;~List()&lt;/code&gt;
to release the memory, or use smart pointers
like &lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt; to help memory management.
    &lt;ul&gt;
      &lt;li&gt;To release &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo* n = new Foo(...)&lt;/code&gt;, we need to use &lt;code class=&quot;highlighter-rouge&quot;&gt;delete n&lt;/code&gt;
instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;n-&amp;gt;~Foo()&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;Calling a destructor releases the resources owned by the object,
but it does not release the memory allocated to the object itself.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;We need to pass self pointer to the &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; structure
for calling functions to access list’s data,
while we don’t need to do that in C++ version
because class object can get all data inside itself in its implementation.&lt;/li&gt;
  &lt;li&gt;To allow storing different data type in the list,
the C++ version use &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;void*&lt;/code&gt; in the C version.
    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;void* data&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t size&lt;/code&gt;
is regarded as memory chunk beyond types,
pointed by &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; bytes,
so we can store different types data in &lt;strong&gt;runtime&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;While &lt;code class=&quot;highlighter-rouge&quot;&gt;template&amp;lt;typename T&amp;gt;&lt;/code&gt; let us to declare a variable
with type &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; in &lt;strong&gt;compile time&lt;/strong&gt;,
so &lt;em&gt;gcc/g++&lt;/em&gt; can help us for debugging if there is any error.
        &lt;ul&gt;
          &lt;li&gt;function with &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt; cannot be separated in &lt;code class=&quot;highlighter-rouge&quot;&gt;.cpp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;.h&lt;/code&gt;
because compiler needs to see both the template definition
and the specific types/whatever used to &lt;strong&gt;fill in&lt;/strong&gt; the template.
Please read &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl&quot; title=&quot;Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file&quot;&gt;this&lt;/a&gt; for more details.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Replace &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt; is always a pointer type. &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;(0) could cause ambiguity
when we have functions: &lt;code class=&quot;highlighter-rouge&quot;&gt;void f(int)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;void f(foo *)&lt;/code&gt;,
and we call &lt;code class=&quot;highlighter-rouge&quot;&gt;f(NULL)&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">How to simulate a C++ class in C

After learning C++, I am curious about
how could I bring the object-oriented style to C.
Could we simulate a C++ class by struct in C?

To find the answer,
I implement a simple linked list with object-oriented style in plain C.
The key is to use function pointer in struct to
simulate a C++ member function.
you can find my code here

To compare, I also implement a linked list in C++.

Class in C
#ifndef LIST_H
#define LIST_H

#include &amp;lt;stddef.h&amp;gt; // for size_t

struct Node {
  void* data; // Any data type can be stored in this node
  struct Node* next;
};

typedef void (*Callback)(struct Node* node);
struct List {
  struct Node* head;
  struct Node* cursor;

  void (* const destroy)(struct List* self);
  void (* const append)(struct List* self, void* data, size_t size);
  void (* const prepend)(struct List* self, void* data, size_t size);
  void (* const traverse)(struct List* self, Callback func);
};

extern const struct ListClass {
  struct List (*new)();
} /*ListProxy*/ List;

#endif // LIST_H


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;assert.h&amp;gt; // for assert
// #include &amp;lt;stddef.h&amp;gt; // for NULL, size_t, they are already included in list.h
#include &amp;lt;stdlib.h&amp;gt; // for calloc, free
#include &amp;lt;string.h&amp;gt; // for memcpy

// Using &amp;quot;static&amp;quot; prevents these functions from being exposed outside.

static void
destroy(struct List* self)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ;) {
    struct Node* next = cur-&amp;gt;next;
    free(cur-&amp;gt;data);
    free(cur);
    cur = next;
  }
  self-&amp;gt;head = self-&amp;gt;cursor = NULL;
}

static void
append(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = NULL;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  if (!self-&amp;gt;head) { // The list is empty.
    assert(!self-&amp;gt;cursor); // cursor = head = NULL now.
    self-&amp;gt;head = n;
  } else {
    assert(self-&amp;gt;cursor);
    self-&amp;gt;cursor-&amp;gt;next = n;
  }
  self-&amp;gt;cursor = n;
}

static void
prepend(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = self-&amp;gt;head;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  self-&amp;gt;head = n;
  if(!self-&amp;gt;cursor) { // The list is empty before inserting value.
    self-&amp;gt;cursor = n;
  }
}

static void
traverse(struct List* self, Callback func)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ; cur = cur-&amp;gt;next) {
    func(cur);
  }
}

static struct List
new()
{
  return (struct List) {
    .head = NULL,
    .cursor = NULL,
    .destroy = (void*) &amp;amp;destroy,
    .append = (void*) &amp;amp;append,
    .prepend = (void*) &amp;amp;prepend,
    .traverse = (void*) &amp;amp;traverse
  };
}

const struct ListClass /*ListProxy*/ List = {
  .new = &amp;amp;new,
};


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;stdbool.h&amp;gt;  // for bool
#include &amp;lt;stdio.h&amp;gt;    // for printf

#define VA_ARGS(...) , ##__VA_ARGS__
#define CALL(obj, method, ...) ((obj).method(&amp;amp;(obj) VA_ARGS(__VA_ARGS__)))

void print(struct Node* node, bool is_float)
{
  if (!node) {
    return;
  }
  is_float ? printf(&amp;quot;%f&amp;quot;, *(float*)node-&amp;gt;data) :
             printf(&amp;quot;%d&amp;quot;, *(int*)node-&amp;gt;data);
  printf(&amp;quot;%s&amp;quot;, (node-&amp;gt;next) ? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot; &amp;quot;);
}

void print_int(struct Node* node)
{
  print(node, false);
}

void print_float(struct Node* node)
{
  print(node, true);
}

int main()
{
  int data_int[6] = { 11, 22, 33, 44, 55, 66 };
  float data_float[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  struct List l = /*ListProxy*/List.new();
  l.prepend(&amp;amp;l, &amp;amp;data_int[0], sizeof(data_int[0]));
  l.append(&amp;amp;l, &amp;amp;data_int[1], sizeof(data_int[1]));
  l.append(&amp;amp;l, &amp;amp;data_int[2], sizeof(data_int[2]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[3], sizeof(data_int[3]));
  l.append(&amp;amp;l, &amp;amp;data_int[4], sizeof(data_int[4]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[5], sizeof(data_int[5]));
  l.traverse(&amp;amp;l, print_int);
  l.destroy(&amp;amp;l);

  CALL(l, prepend,  &amp;amp;data_float[0], sizeof(data_float[0]));
  CALL(l, append,   &amp;amp;data_float[1], sizeof(data_float[1]));
  CALL(l, append,   &amp;amp;data_float[2], sizeof(data_float[2]));
  CALL(l, prepend,  &amp;amp;data_float[3], sizeof(data_float[3]));
  CALL(l, append,   &amp;amp;data_float[4], sizeof(data_float[4]));
  CALL(l, prepend,  &amp;amp;data_float[5], sizeof(data_float[5]));
  CALL(l, traverse, print_float);
  CALL(l, destroy);

  return 0;
}


C++ version
#ifndef LIST_H
#define LIST_H

#include &amp;lt;assert.h&amp;gt; // for assert
#include &amp;lt;memory&amp;gt;   // for std::unique_ptr

template&amp;lt;typename T&amp;gt;
class List
{
public:
  struct Node // All it&amp;#39;s members are public by default.
  {
    Node(T aData, Node* aNext)
      : mData(aData)
      , mNext(aNext)
    {}

    ~Node() {}

    T mData;
    Node* mNext;
  };

  List();
  ~List();

  void Append(T aData);
  void Prepend(T aData);

  typedef void (*Callback)(Node* aNode);
  void Traverse(Callback aCallback);

private:
  // No need to use smart pointer in low-level data structure.
  // It&amp;#39;s more efficient for managing memory on our own.
  Node* mCursor;
  Node* mHead;
};

// nullptr is introduced in C++11.
template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List()
  : mCursor(nullptr)
  , mHead(nullptr)
{
}

template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
  for (mCursor = mHead ; mCursor != nullptr ;) {
    std::unique_ptr&amp;lt;Node&amp;gt; autoRelease(mCursor);
    // Update mCursor here instead of afterthought in for-loop,
    // in case mCursor is already released.
    mCursor = mCursor-&amp;gt;mNext;
    // The memory chuck pointed by old mCursor will be destroyed
    // upon leaving the &amp;#39;}&amp;#39;.
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Append(T aData)
{
  Node* n = new Node(aData, nullptr);
  if (!mHead) { // the list is empty.
    assert(!mCursor);
    mHead = n;
  } else {
    assert(mCursor);
    mCursor-&amp;gt;mNext = n;
  }
  mCursor = n;
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Prepend(T aData)
{
  Node* n = new Node(aData, mHead);
  mHead = n;
  if (!mCursor) { // The list is empty before inserting value.
    mCursor = n;
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Traverse(Callback aCallback)
{
  for (Node* cur = mHead ; cur != nullptr ; cur = cur-&amp;gt;mNext) {
    aCallback(cur);
  }
}

#endif // LIST_H


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
void Print(T aData, bool aBreakline)
{
  std::cout &amp;lt;&amp;lt; aData &amp;lt;&amp;lt; ((aBreakline)? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot; &amp;quot;);
}

void PrintInt(List&amp;lt;int&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

void PrintFloat(List&amp;lt;float&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

int main()
{
  int dataInt[6] = { 11, 22, 33, 44, 55, 66 };
  float dataFloat[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  List&amp;lt;int&amp;gt; li;
  li.Prepend(dataInt[0]);
  li.Append(dataInt[1]);
  li.Append(dataInt[2]);
  li.Prepend(dataInt[3]);
  li.Append(dataInt[4]);
  li.Prepend(dataInt[5]);
  li.Traverse(PrintInt);

  List&amp;lt;float&amp;gt; lf;
  lf.Prepend(dataFloat[0]);
  lf.Append(dataFloat[1]);
  lf.Append(dataFloat[2]);
  lf.Prepend(dataFloat[3]);
  lf.Append(dataFloat[4]);
  lf.Prepend(dataFloat[5]);
  lf.Traverse(PrintFloat);

  return 0;
}


Comparison

  The C version needs to call destroy explicitly,
while the C++ version will automatically run deconstructor ~List()
to release the memory, or use smart pointers
like unique_ptr to help memory management.
    
      To release Foo* n = new Foo(...), we need to use delete n
instead of n-&amp;gt;~Foo()
        
          Calling a destructor releases the resources owned by the object,
but it does not release the memory allocated to the object itself.
        
      
    
  
  We need to pass self pointer to the List structure
for calling functions to access list’s data,
while we don’t need to do that in C++ version
because class object can get all data inside itself in its implementation.
  To allow storing different data type in the list,
the C++ version use template instead of void* in the C version.
    
      The void* data with size_t size
is regarded as memory chunk beyond types,
pointed by data with size bytes,
so we can store different types data in runtime.
      While template&amp;lt;typename T&amp;gt; let us to declare a variable
with type T in compile time,
so gcc/g++ can help us for debugging if there is any error.
        
          function with template cannot be separated in .cpp and .h
because compiler needs to see both the template definition
and the specific types/whatever used to fill in the template.
Please read this for more details.
        
      
    
  
  Replace NULL with nullptr
    
      nullptr is always a pointer type. NULL(0) could cause ambiguity
when we have functions: void f(int), void f(foo *),
and we call f(NULL).</summary></entry><entry><title type="html">How to avoid duplicate symbols when compiling</title><link href="http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling" rel="alternate" type="text/html" title="How to avoid duplicate symbols when compiling" /><published>2017-04-08T00:00:00+08:00</published><updated>2017-04-08T00:00:00+08:00</updated><id>http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling</id><content type="html" xml:base="http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling">&lt;h1 id=&quot;how-to-avoid-duplicatesymbols-when-compiling&quot;&gt;How to avoid duplicate symbols when compiling&lt;/h1&gt;

&lt;p&gt;The error: &lt;code class=&quot;highlighter-rouge&quot;&gt;duplicate symbol for architecture x86_64&lt;/code&gt; will be prompted
if the following &lt;a href=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276&quot; title=&quot;gist&quot;&gt;files&lt;/a&gt; are compiled.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;makefile&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;CXX=g++
CFLAGS=-Wall
EXEC=run

all: bye.o hello.o
	$(CXX) $(CFLAGS) main.cpp bye.o hello.o -o $(EXEC)

bye.o: bye.cpp
	$(CXX) -c $(CFLAGS) bye.cpp

hello.o: hello.cpp
	$(CXX) -c $(CFLAGS) hello.cpp

clean:
	rm $(EXEC) *.o
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=makefile&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;main.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;hello.h&amp;quot;

int main()
{
  SayHello();
  SayBye();
  return 0;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=main.cpp&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;utils.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef UTILS_H
#define UTILS_H

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}

#endif /* UTILS_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=utils.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;hello.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef HELLO_H
#define HELLO_H

void SayHello();

#endif /* HELLO_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=hello.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;hello.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;hello.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayHello()
{
  LOG(&amp;quot;Hello&amp;quot;);
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=hello.cpp&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;bye.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef BYE_H
#define BYE_H

void SayBye();

#endif /* BYE_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=bye.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;bye.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayBye()
{
  LOG(&amp;quot;Goodbye&amp;quot;);
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=bye.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;You will see the &lt;code class=&quot;highlighter-rouge&quot;&gt;duplicate symbol for architecture x86_64&lt;/code&gt; error
when you compile those files.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
g++ -c -Wall bye.cpp
g++ -c -Wall hello.cpp
g++ -Wall main.cpp bye.o hello.o -o run
duplicate symbol __Z3LOGNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE in:
    bye.o
    hello.o
ld: 1 duplicate symbol for architecture x86_64
clang: error: linker command failed with exit code 1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use -v to see invocation&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
make: &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; [all] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The reason is that we include the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;utils.h&lt;/code&gt;)
into different files(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.cpp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.cpp&lt;/code&gt;),
and compile those files into different libraries(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.o&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.o&lt;/code&gt;),
so the functions in the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt;)
duplicate in those different libraries.&lt;/p&gt;

&lt;p&gt;Thus, when we try using those different libraries(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.o&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.o&lt;/code&gt;)
at the same time, there are duplicated symbols for functions(&lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt;)
included from the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;utils.h&lt;/code&gt;).
The program has no idea about which one it should call
among those duplicated symbols.&lt;/p&gt;

&lt;h2 id=&quot;solution-1-using-macros-instead-of-functions&quot;&gt;Solution 1: Using macros instead of functions&lt;/h2&gt;
&lt;p&gt;The macro is only textual substitution that expanded by the preprocessor,
so there is no symbol generated.&lt;/p&gt;

&lt;p&gt;You can replace function &lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt; by&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define LOG(s) (std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then the &lt;code class=&quot;highlighter-rouge&quot;&gt;SayBye()&lt;/code&gt; will be expanded into:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SayBye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Goodbye&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can run: &lt;code class=&quot;highlighter-rouge&quot;&gt;$ g++ -E &amp;lt;file_name&amp;gt;.cpp&lt;/code&gt; to watch
and confirm the preprocessor’s output.&lt;/p&gt;

&lt;h2 id=&quot;solution-2-make-functions-inline&quot;&gt;Solution 2: Make functions &lt;strong&gt;inline&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;It works almost same as macro.
Inline functions are actual functions
whose copy of the function body are injected directly into
each place the function is called.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The insertion occurs only if
the compiler’s cost/benefit analysis shows it to be profitable.
Same as the macros, inline expansion eliminates
the overhead associated with function calls.&lt;/p&gt;

&lt;p&gt;Inline functions are parsed by the compiler,
whereas macros are expanded by the preprocessor.
The preprocessor macros are just substitution patterns in code
before the compilation,
so there is no &lt;strong&gt;type-checking&lt;/strong&gt; at that time.
While inline functions are actual functions, so compiler can keep an eye on
type-checking issues to help debugging.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://chunminchang.gitbooks.io/cplusplus-learning-note/content/Appendix/preprocessor_macros_vs_inline_functions.html#inline-functions&quot; title=&quot;Inline functions&quot;&gt;here&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&quot;solution-3-using-static-to-make-functions-local-in-each-file&quot;&gt;Solution 3: Using &lt;strong&gt;static&lt;/strong&gt; to make functions local in each file&lt;/h2&gt;
&lt;p&gt;Since their states are &lt;strong&gt;not&lt;/strong&gt; sharable,
they should &lt;strong&gt;not&lt;/strong&gt; visible across each other.
Thus, the generated symbols are also local in each file.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">How to avoid duplicate symbols when compiling

The error: duplicate symbol for architecture x86_64 will be prompted
if the following files are compiled.


  makefile

CXX=g++
CFLAGS=-Wall
EXEC=run

all: bye.o hello.o
	$(CXX) $(CFLAGS) main.cpp bye.o hello.o -o $(EXEC)

bye.o: bye.cpp
	$(CXX) -c $(CFLAGS) bye.cpp

hello.o: hello.cpp
	$(CXX) -c $(CFLAGS) hello.cpp

clean:
	rm $(EXEC) *.o




  main.cpp

#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;hello.h&amp;quot;

int main()
{
  SayHello();
  SayBye();
  return 0;
}




  utils.h

#ifndef UTILS_H
#define UTILS_H

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}

#endif /* UTILS_H */




  hello.h

#ifndef HELLO_H
#define HELLO_H

void SayHello();

#endif /* HELLO_H */




  hello.cpp

#include &amp;quot;hello.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayHello()
{
  LOG(&amp;quot;Hello&amp;quot;);
}




  bye.h

#ifndef BYE_H
#define BYE_H

void SayBye();

#endif /* BYE_H */




  bye.cpp

#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayBye()
{
  LOG(&amp;quot;Goodbye&amp;quot;);
}



You will see the duplicate symbol for architecture x86_64 error
when you compile those files.
$ make
g++ -c -Wall bye.cpp
g++ -c -Wall hello.cpp
g++ -Wall main.cpp bye.o hello.o -o run
duplicate symbol __Z3LOGNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE in:
    bye.o
    hello.o
ld: 1 duplicate symbol for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [all] Error 1



The reason is that we include the shared header(utils.h)
into different files(bye.cpp and hello.cpp),
and compile those files into different libraries(bye.o and hello.o),
so the functions in the shared header(LOG)
duplicate in those different libraries.

Thus, when we try using those different libraries(bye.o and hello.o)
at the same time, there are duplicated symbols for functions(LOG)
included from the shared header(utils.h).
The program has no idea about which one it should call
among those duplicated symbols.

Solution 1: Using macros instead of functions
The macro is only textual substitution that expanded by the preprocessor,
so there is no symbol generated.

You can replace function LOG by
#define LOG(s) (std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl)



Then the SayBye() will be expanded into:
void SayBye()
{
  (std::cout &amp;lt;&amp;lt; &quot;Goodbye&quot; &amp;lt;&amp;lt; std::endl);
}



You can run: $ g++ -E &amp;lt;file_name&amp;gt;.cpp to watch
and confirm the preprocessor’s output.

Solution 2: Make functions inline
It works almost same as macro.
Inline functions are actual functions
whose copy of the function body are injected directly into
each place the function is called.

inline void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}



The insertion occurs only if
the compiler’s cost/benefit analysis shows it to be profitable.
Same as the macros, inline expansion eliminates
the overhead associated with function calls.

Inline functions are parsed by the compiler,
whereas macros are expanded by the preprocessor.
The preprocessor macros are just substitution patterns in code
before the compilation,
so there is no type-checking at that time.
While inline functions are actual functions, so compiler can keep an eye on
type-checking issues to help debugging.

See here for more details.

Solution 3: Using static to make functions local in each file
Since their states are not sharable,
they should not visible across each other.
Thus, the generated symbols are also local in each file.

static void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}</summary></entry><entry><title type="html">Running multiple Firefox at the same time</title><link href="http://localhost:4000/post/running-multiple-firefox-at-the-same-time" rel="alternate" type="text/html" title="Running multiple Firefox at the same time" /><published>2017-03-30T00:00:00+08:00</published><updated>2017-03-30T00:00:00+08:00</updated><id>http://localhost:4000/post/running-multiple-firefox-at-the-same-time</id><content type="html" xml:base="http://localhost:4000/post/running-multiple-firefox-at-the-same-time">&lt;h1 id=&quot;running-multiple-firefox-at-the-same-time&quot;&gt;Running multiple Firefox at the same time&lt;/h1&gt;

&lt;p&gt;I have two firefox: Firefox(normal version) and Firefox Developer Edition.
Today morning, I deleted the Firefox Developer Edition by &lt;em&gt;AppCleaner&lt;/em&gt;
and re-installed it, then something weird happened.&lt;/p&gt;

&lt;p&gt;When I opened the new Firefox Developer Edition
then launched my unchanged Firefox, the Firefox cannot be opened
and it showed an error: &lt;strong&gt;A copy of Firefox is already open.
Only one copy of Firefox an be opened at a time.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/a-copy-of-firefox-is-alreay-open.png&quot; alt=&quot;&quot; title=&quot;A copy of Firefox is already open&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AFAIK, the multiple Firefox instances are able to run at the same time,
if they use &lt;strong&gt;different profiles&lt;/strong&gt;.
Therefore, I opened &lt;code class=&quot;highlighter-rouge&quot;&gt;about:profiles&lt;/code&gt; on Firefox to check it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/firefox-about-profiles-wrong.png&quot; alt=&quot;&quot; title=&quot;Firefox - about:profiles(incorrect)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;From above, the setting was incorrect.
It should use &lt;em&gt;Profile: default&lt;/em&gt; instead of &lt;em&gt;Profile: dev-edition-default&lt;/em&gt;.
That’s why I cannot open Firefox and FirefoxDeveloperEdition at the same time.&lt;/p&gt;

&lt;p&gt;To fix the problem, I simply click &lt;em&gt;Set a default profile&lt;/em&gt;
under &lt;em&gt;Profile: default&lt;/em&gt;, then closed it, and relaunched it to check the setting.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/firefox-about-profiles-right.png&quot; alt=&quot;&quot; title=&quot;Firefox - about:profiles(correct)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I also checked the FirefoxDeveloperEdition’s setting
to make sure everything is fine.
&lt;img src=&quot;../images/posts/firefoxdeveloperedition-about-profiles.png&quot; alt=&quot;&quot; title=&quot;FirefoxDeveloperEdition - about:profiles&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I wrote this to remember how I fix it,
in case the same problem happens again.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Firefox" /><summary type="html">Running multiple Firefox at the same time

I have two firefox: Firefox(normal version) and Firefox Developer Edition.
Today morning, I deleted the Firefox Developer Edition by AppCleaner
and re-installed it, then something weird happened.

When I opened the new Firefox Developer Edition
then launched my unchanged Firefox, the Firefox cannot be opened
and it showed an error: A copy of Firefox is already open.
Only one copy of Firefox an be opened at a time.



AFAIK, the multiple Firefox instances are able to run at the same time,
if they use different profiles.
Therefore, I opened about:profiles on Firefox to check it.



From above, the setting was incorrect.
It should use Profile: default instead of Profile: dev-edition-default.
That’s why I cannot open Firefox and FirefoxDeveloperEdition at the same time.

To fix the problem, I simply click Set a default profile
under Profile: default, then closed it, and relaunched it to check the setting.



I also checked the FirefoxDeveloperEdition’s setting
to make sure everything is fine.


I wrote this to remember how I fix it,
in case the same problem happens again.</summary></entry><entry><title type="html">Requiring Android build-tools for Fennec</title><link href="http://localhost:4000/post/requiring-android-build-tools-for-fennec" rel="alternate" type="text/html" title="Requiring Android build-tools for Fennec" /><published>2017-03-22T00:00:00+08:00</published><updated>2017-03-22T00:00:00+08:00</updated><id>http://localhost:4000/post/requiring-android-build-tools-for-fennec</id><content type="html" xml:base="http://localhost:4000/post/requiring-android-build-tools-for-fennec">&lt;h1 id=&quot;requiring-android-build-tools-for-fennec&quot;&gt;Requiring Android build-tools for Fennec&lt;/h1&gt;

&lt;p&gt;To build fennec, I run &lt;code class=&quot;highlighter-rouge&quot;&gt;$./mach bootstrap&lt;/code&gt; under my &lt;em&gt;gecko-dev&lt;/em&gt; repo
and select &lt;em&gt;Firefox for Android&lt;/em&gt; to install all stuff for development.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Please choose the version of Firefox you want to build:
1. Firefox for Desktop Artifact Mode
2. Firefox for Desktop
3. Firefox for Android Artifact Mode
4. Firefox for Android

Note on Artifact Mode:
...
...

Your choice: 4

Looks like you have Homebrew installed. We will install all required packages via Homebrew.

...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, I create/modify the &lt;em&gt;mozconfig&lt;/em&gt;(or &lt;em&gt;.mozconfig&lt;/em&gt;) under my &lt;em&gt;gecko-dev&lt;/em&gt; repo:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Build Firefox for Android:
ac_add_options --enable-application=mobile/android
ac_add_options --target=arm-linux-androideabi

# With the following Android SDK and NDK:
ac_add_options --with-android-sdk=&quot;/Users/cchang/.mozbuild/android-sdk-macosx&quot;
ac_add_options --with-android-ndk=&quot;/Users/cchang/.mozbuild/android-ndk-r11c&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;However, there are still error shown when I build by &lt;code class=&quot;highlighter-rouge&quot;&gt;./mach build&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
...
 0:09.78 DEBUG: configure:10912: checking if app-specific confvars.sh exists
 0:09.78 DEBUG: configure:11077: checking for Android SDK platform version 23
 0:09.78 DEBUG: configure:11085: checking for Android build-tools
 0:09.78 DEBUG: configure: error: You must install the Android build-tools version 23.0.3.  Try |mach bootstrap|.  (Looked for /Users/cchang/.mozbuild/android-sdk-macosx/build-tools/23.0.3)
 0:09.78 ERROR: old-configure failed
 0:09.82 *** Fix above errors and then restart with               &quot;/Applications/Xcode.app/Contents/Developer/usr/bin/make -f client.mk build&quot;
 0:09.82 make: *** [configure] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To solve this, I check whether &lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/cchang/.mozbuild/android-sdk-macosx/build-tools/23.0.3&lt;/code&gt; exists.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls /Users/cchang/.mozbuild/android-sdk-macosx/
SDK Readme.txt	extras		platforms		tools
add-ons		platform-tools	temp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;There is really no &lt;code class=&quot;highlighter-rouge&quot;&gt;build-tools&lt;/code&gt;, so I need to install it by my own.&lt;/p&gt;

&lt;p&gt;I open the &lt;em&gt;SDK Readme.txt&lt;/em&gt; to know what I could do:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /Users/cchang/.mozbuild/android-sdk-macosx/
$ vim SDK\ Readme.txt
...
...
To start the SDK Manager, please execute the program &quot;android&quot;.

From the command-line you can also directly trigger an update by
executing:
  tools/android update sdk --no-ui

Tip: use --help to see the various command-line options.
...
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From above, we could run &lt;code class=&quot;highlighter-rouge&quot;&gt;$ ./tools/android&lt;/code&gt; to install what we need:
&lt;img src=&quot;../images/posts/android-sdk-manager.png&quot; alt=&quot;Android SDK Manager&quot; title=&quot;Android SDK Manager&quot; /&gt;
After the selected items are installed, we can successfully build the fennec!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
...
61:33.64 Overall system resources - Wall time: 3687s; CPU: 97%; Read bytes: 3304162816; Write bytes: 6230259712; Read time: 45476; Write time: 36725
61:33.64 Swap in/out (MB): 4092/2
61:34.40 /usr/local/bin/terminal-notifier -title Mozilla Build System -group mozbuild -message Build complete
61:34.69 We know it took a while, but your build finally finished successfully!
To view resource usage of the build, run |mach resource-usage|.
For more information on what to do now, see https://developer.mozilla.org/docs/Developer_Guide/So_You_Just_Built_Firefox
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Fennec" /><summary type="html">Requiring Android build-tools for Fennec

To build fennec, I run $./mach bootstrap under my gecko-dev repo
and select Firefox for Android to install all stuff for development.

Please choose the version of Firefox you want to build:
1. Firefox for Desktop Artifact Mode
2. Firefox for Desktop
3. Firefox for Android Artifact Mode
4. Firefox for Android

Note on Artifact Mode:
...
...

Your choice: 4

Looks like you have Homebrew installed. We will install all required packages via Homebrew.

...



Next, I create/modify the mozconfig(or .mozconfig) under my gecko-dev repo:
# Build Firefox for Android:
ac_add_options --enable-application=mobile/android
ac_add_options --target=arm-linux-androideabi

# With the following Android SDK and NDK:
ac_add_options --with-android-sdk=&quot;/Users/cchang/.mozbuild/android-sdk-macosx&quot;
ac_add_options --with-android-ndk=&quot;/Users/cchang/.mozbuild/android-ndk-r11c&quot;



However, there are still error shown when I build by ./mach build:
...
...
 0:09.78 DEBUG: configure:10912: checking if app-specific confvars.sh exists
 0:09.78 DEBUG: configure:11077: checking for Android SDK platform version 23
 0:09.78 DEBUG: configure:11085: checking for Android build-tools
 0:09.78 DEBUG: configure: error: You must install the Android build-tools version 23.0.3.  Try |mach bootstrap|.  (Looked for /Users/cchang/.mozbuild/android-sdk-macosx/build-tools/23.0.3)
 0:09.78 ERROR: old-configure failed
 0:09.82 *** Fix above errors and then restart with               &quot;/Applications/Xcode.app/Contents/Developer/usr/bin/make -f client.mk build&quot;
 0:09.82 make: *** [configure] Error 1



To solve this, I check whether /Users/cchang/.mozbuild/android-sdk-macosx/build-tools/23.0.3 exists.
$ ls /Users/cchang/.mozbuild/android-sdk-macosx/
SDK Readme.txt	extras		platforms		tools
add-ons		platform-tools	temp


There is really no build-tools, so I need to install it by my own.

I open the SDK Readme.txt to know what I could do:
$ cd /Users/cchang/.mozbuild/android-sdk-macosx/
$ vim SDK\ Readme.txt
...
...
To start the SDK Manager, please execute the program &quot;android&quot;.

From the command-line you can also directly trigger an update by
executing:
  tools/android update sdk --no-ui

Tip: use --help to see the various command-line options.
...
...



From above, we could run $ ./tools/android to install what we need:

After the selected items are installed, we can successfully build the fennec!

...
...
61:33.64 Overall system resources - Wall time: 3687s; CPU: 97%; Read bytes: 3304162816; Write bytes: 6230259712; Read time: 45476; Write time: 36725
61:33.64 Swap in/out (MB): 4092/2
61:34.40 /usr/local/bin/terminal-notifier -title Mozilla Build System -group mozbuild -message Build complete
61:34.69 We know it took a while, but your build finally finished successfully!
To view resource usage of the build, run |mach resource-usage|.
For more information on what to do now, see https://developer.mozilla.org/docs/Developer_Guide/So_You_Just_Built_Firefox</summary></entry><entry><title type="html">Lunar New Year</title><link href="http://localhost:4000/post/lunar-new-year" rel="alternate" type="text/html" title="Lunar New Year" /><published>2017-01-28T00:00:00+08:00</published><updated>2017-01-28T00:00:00+08:00</updated><id>http://localhost:4000/post/lunar-new-year</id><content type="html" xml:base="http://localhost:4000/post/lunar-new-year">&lt;h1 id=&quot;新年寄語&quot;&gt;新年寄語&lt;/h1&gt;

&lt;p&gt;今年終於把部落格架起來了，所以不免俗的來回顧過去和立定目標好了。
大學之後就很久沒寫關於生活的事情了，可能是人老了生活單純許多，沒有那麼多話好說了。
這幾年變化比較大的，大概是開始工作了吧。工作兩年了，最大的心得是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;人生最重要的是時間&lt;/li&gt;
  &lt;li&gt;環境影響成長&lt;/li&gt;
  &lt;li&gt;性格決定命運&lt;/li&gt;
&lt;/ul&gt;

&lt;!--read more--&gt;

&lt;h2 id=&quot;人生最重要的是時間&quot;&gt;人生最重要的是時間  &lt;/h2&gt;
&lt;p&gt;工作以來，最慶幸的改變是修正了臨時抱佛腳的個性。
長期的規劃需要經年努力的積累，而積累需要的就是時間。
實現理想的過程中，金錢只是用來換取時間的籌碼，買別人時間來省下自己的時間。
誰能最有效利用時間換取生理需求，誰就剩下更多的籌碼來實現理想。
出社會後留給自己的時間少了，才感嘆以往對於時間的虛度。
把握當下地專注自眼前的人事物，才是善用時間的生活方式。  &lt;/p&gt;

&lt;h2 id=&quot;環境影響成長&quot;&gt;環境影響成長&lt;/h2&gt;
&lt;p&gt; 當初對這份工作的期待，似乎只有「國際化」這個模糊的概念有沾到一點邊吧。
能跟全世界的人一起工作是一件很酷的事情。
夥伴們大都很有理想也兼具實力，最重要的是他們都一直不斷地精進自己。
身處這樣的環境讓我可以發現到自己需要加強的地方，也能感受到那種一起向前的氛圍，
進而內化成提醒自己每天都要進步的動力。
而最意外的收穫是多益程度從500+變成900+，雖然拿多益當標準有點弱，
但這是我從小到大第一次覺得到我英文還有救哈哈。
合作的同事幾乎都是外國人，所以每天都是用英文在溝通，不知不覺就進步了。
日常生活上，我也為了提升自己的英文能力，養成每日閱聽英文新聞的習慣。
活了這麼久才感受到環境(context)對人的重要性，要學好英文，首先要進入/創造一個適合學英文的環境。
就像許多人直接去國外打工或留學，生活周遭是全英文環境，學習速度自然就變快了許多。
不只是英文，其他事也一樣。如果周遭的人事物可以提供你快速成長的環境，那你的能力才能有效提升。
科學研究也指出，運動選手如果和比自己優秀的選手組隊，通常會比個人參賽表現出更亮眼的成績。
這就是環境對人的重要性，要變強的不二法門，就是去充滿強者的環境，這樣才能偷學。&lt;/p&gt;

&lt;h2 id=&quot;性格決定命運&quot;&gt;性格決定命運&lt;/h2&gt;
&lt;p&gt; 另一個值得高興的就是能認識各種神人。
各路大神各有千秋，很多大神不一定有頂尖的智商，但共通的是大神們都有鋼鐵般的意志力不斷地超越自己。
鐵打的實力絕不僅止是靠熟讀課本上的理論來養成，而是靠無數實戰經驗累積才能煉成。
人未必是出類拔萃的，但一定是獨一無二的。
出生和成長環境造就我們不同的天份和性格，我們無法成為別人，只能創造更好的自己。
人生就是在創造自己的過程。   在職涯的發展中，我認為最重要的是要養成堅毅的意志力(grit)。
意志力是年復一年對未來願景的堅持，是失敗後繼續堅持的動力。
人生是一場馬拉松，失敗或成功都只是一時的狀態，重要的是在這個過程中不斷的淬煉自己。&lt;/p&gt;

&lt;h2 id=&quot;回顧與未來&quot;&gt;回顧與未來&lt;/h2&gt;
&lt;p&gt; 工程師這個職業類別其實很晚才出現在我的考慮範圍內，
是在找了幾個朋友一起研讀自己覺得興趣的科目，
寫一些有趣的題目才發現：「喔，原來寫code似乎滿有趣的嘛。」
諷刺的是，做這件事情的起頭是不想讀研究所，因為不知道讀了要幹嘛。
研究所不想念還是念了，想去一般替代役結果還是服了研發替代替，
但我都沒有後悔啦(上成功嶺第一天就慶幸還好我研替…)。
雖然不知道我會當所謂的「工程師」多久，但這些計算思維應該會慢慢內化成一種思考方式，然後跟著我一輩子。
 其實我一直覺得用職業來分類人很奇怪，只會限制人的發展性。
反正我們都是人嘛，只在做不同的事罷了。
想做的事太多，時間太少，能把握的只有讓自己一天比一天進步。
明年的目標是重新研讀Computer Science的基礎知識，多貢獻一些開源專案，
讓自己的程式可以跑在更多地方，開發更多有用的服務。
還有，太久沒講台語也太久沒彈吉他，所以明年要讓台語輪轉一點，然後再做幾首台語歌吧！&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Life" /><category term="Goal" /><category term="New Year" /><summary type="html">新年寄語

今年終於把部落格架起來了，所以不免俗的來回顧過去和立定目標好了。
大學之後就很久沒寫關於生活的事情了，可能是人老了生活單純許多，沒有那麼多話好說了。
這幾年變化比較大的，大概是開始工作了吧。工作兩年了，最大的心得是：


  人生最重要的是時間
  環境影響成長
  性格決定命運</summary></entry><entry><title type="html">Merge Sort</title><link href="http://localhost:4000/post/merge-sort" rel="alternate" type="text/html" title="Merge Sort" /><published>2017-01-05T00:00:00+08:00</published><updated>2017-01-05T00:00:00+08:00</updated><id>http://localhost:4000/post/merge-sort</id><content type="html" xml:base="http://localhost:4000/post/merge-sort">&lt;h1 id=&quot;merge-sort&quot;&gt;Merge Sort&lt;/h1&gt;

&lt;p&gt;This post series is synchronized with my book &lt;a href=&quot;https://www.gitbook.com/book/chunminchang/codeplay/details&quot; title=&quot;CodePlay&quot;&gt;CodePlay&lt;/a&gt;
and this post could be read &lt;a href=&quot;https://chunminchang.gitbooks.io/codeplay/content/sorting/merge_sort.html&quot; title=&quot;Merge Sort&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;idea&quot;&gt;Idea&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Merge sort&lt;/em&gt; is an efficient algorithm that
applies the concepts of &lt;a href=&quot;https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm&quot; title=&quot;Divide and conquer algorithm&quot;&gt;&lt;em&gt;divide and conquer&lt;/em&gt;&lt;/a&gt; to sort the list.&lt;/p&gt;

&lt;p&gt;The key idea of &lt;a href=&quot;https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm&quot; title=&quot;Divide and conquer algorithm&quot;&gt;&lt;em&gt;divide and conquer&lt;/em&gt;&lt;/a&gt; is to recursively break down the problems
into two or more sub-problems and they are same or related to the original problem,
until these divided sub-problems are simple enough to solve directly.
Then, the solutions of the original problem can be combined and derived
by the solutions of all the sub-problems.&lt;/p&gt;

&lt;h3 id=&quot;divide-and-conquer&quot;&gt;Divide and conquer&lt;/h3&gt;
&lt;p&gt;The calculation of &lt;a href=&quot;https://en.wikipedia.org/wiki/Fibonacci_number&quot; title=&quot;Fibonacci number&quot;&gt;&lt;em&gt;Fibonacci number&lt;/em&gt;&lt;/a&gt;, &lt;script type=&quot;math/tex&quot;&gt;F(n) = F(n-1) + F(n-2)&lt;/script&gt;,
is one example.
To calculate &lt;script type=&quot;math/tex&quot;&gt;F(n)&lt;/script&gt;, it needs to find &lt;script type=&quot;math/tex&quot;&gt;F(n-1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F(n-2)&lt;/script&gt;.
Similarly, to calculate &lt;script type=&quot;math/tex&quot;&gt;F(n-1)&lt;/script&gt;, it needs to &lt;script type=&quot;math/tex&quot;&gt;F(n-2)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F(n-3)&lt;/script&gt;.
The sub-problems for calculating &lt;script type=&quot;math/tex&quot;&gt;F(n-1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F(n-2)&lt;/script&gt; have same form
as the one for &lt;script type=&quot;math/tex&quot;&gt;F(n)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Recursively, we will need to get &lt;script type=&quot;math/tex&quot;&gt;F(n-1)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;F(n-2)&lt;/script&gt;, …, &lt;script type=&quot;math/tex&quot;&gt;F(2)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;F(1)&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;F(1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F(2)&lt;/script&gt; are easy enough to solve directly. They are both &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;.
Thus, &lt;script type=&quot;math/tex&quot;&gt;F(3) = F(2) + F(1) = 2&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;F(4) = F(3) + F(2) = 3&lt;/script&gt;, … and then &lt;script type=&quot;math/tex&quot;&gt;F(n)&lt;/script&gt;
can be computed.&lt;/p&gt;

&lt;h3 id=&quot;dividing-the-sorting-problem&quot;&gt;Dividing the sorting-problem&lt;/h3&gt;
&lt;p&gt;Let’s apply this concept to the sorting problem.
If we want to sort the list &lt;script type=&quot;math/tex&quot;&gt;L = [6, 3, 7, 1, 9, 2, 5]&lt;/script&gt;,
the sub-lists &lt;script type=&quot;math/tex&quot;&gt;[6, 3, 7, 1], [9, 2, 5]&lt;/script&gt; must also be sorted,
so we can narrow down our problem scope for handling the sub-lists.
Next, &lt;script type=&quot;math/tex&quot;&gt;[6, 3, 7, 1]&lt;/script&gt; can be divided to &lt;script type=&quot;math/tex&quot;&gt;[6, 3], [7, 1]&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;[6, 3]&lt;/script&gt; also can be split into &lt;script type=&quot;math/tex&quot;&gt;[6]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;[3]&lt;/script&gt;.
Finally, &lt;script type=&quot;math/tex&quot;&gt;[6], [3]&lt;/script&gt; are not dividable
so we stop breaking down the list.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       [6, 3, 7, 1, 9, 2, 5]
         /               \
   [6, 3, 7, 1]       [9, 2, 5]
    /        \          /     \
 [6, 3]    [7, 1]    [9, 2]  [5]
 /    \    /    \    /    \
[6]  [3]  [7]  [1]  [9]  [2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the same way, the whole list can be divided into
&lt;script type=&quot;math/tex&quot;&gt;[6], [3], [7], [1], [9], [2], [5]&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;conquering-the-sub-problems&quot;&gt;Conquering the sub-problems&lt;/h3&gt;
&lt;p&gt;After there is only one element left,
the subproblem is solved by nature since it’s already sorted.&lt;/p&gt;

&lt;p&gt;However, the problem becomes&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;how do we combine these sorted chunks into a sorted list&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We need a method that can merge two sorted lists,
&lt;script type=&quot;math/tex&quot;&gt;L_1[1...X]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_2[1...Y]&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;X, Y \geq 1&lt;/script&gt;,
into a bigger sorted list &lt;script type=&quot;math/tex&quot;&gt;L[1...(X+Y)]&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;combining-all-the-results-of-sub-sorting-problem&quot;&gt;Combining all the results of sub-sorting-problem&lt;/h3&gt;

&lt;p&gt;Suppose we have two sorted lists &lt;script type=&quot;math/tex&quot;&gt;A = [3, 6, 10, 23]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = [2, 7, 50, 55]&lt;/script&gt;.
We provide two ways to merge them into a sorted list.&lt;/p&gt;

&lt;h4 id=&quot;picking-the-smallest-elements-one-by-one&quot;&gt;Picking the smallest elements one by one&lt;/h4&gt;
&lt;p&gt;The simplest method is to pick the smallest elements iteratively
by searching both lists from the minimal to maximal.&lt;/p&gt;

&lt;p&gt;We only need to compare the left most elements of both lists
and pick the smaller one since &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; are already sorted.&lt;/p&gt;

&lt;p&gt;The following example demonstrate the process of this idea:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- search index

A = [(3), 6, 10, 23]
B = [(2), 7, 50, 55]
L = []                            // &amp;lt;- 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In the first round, &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; is picked since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
2 &lt; 3 %]]&gt;&lt;/script&gt;
and going to be put into another list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                                  // You can think the left most element
                                  // is shifted one by one
A = [(3), 6, 10, 23]              // [3, 6, 10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2]                           // &amp;lt;- 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; is picked, we move the index of &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;7&lt;/script&gt;.
Next, &lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt; is picked since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
3 &lt; 7 %]]&gt;&lt;/script&gt; and going to be put into &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = [3, (6), 10, 23]              // [6, 10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2, 3]                        // &amp;lt;- 6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After &lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt; is picked, we move the index of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;6&lt;/script&gt;.
Next, &lt;script type=&quot;math/tex&quot;&gt;6&lt;/script&gt; is picked since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
6 &lt; 7 %]]&gt;&lt;/script&gt; and going to be put into &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = [3, 6, (10), 23]              // [10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2, 3, 6]                     // &amp;lt;- 7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After &lt;script type=&quot;math/tex&quot;&gt;6&lt;/script&gt; is picked, we move the index of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;6&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt;.
Next, &lt;script type=&quot;math/tex&quot;&gt;7&lt;/script&gt; is picked since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
7 &lt; 10 %]]&gt;&lt;/script&gt; and going to be put into &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = [3, 6, (10), 23]              // [10, 23]
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7]                  // &amp;lt;- 10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After &lt;script type=&quot;math/tex&quot;&gt;7&lt;/script&gt; is picked, we move the index of &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;7&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;50&lt;/script&gt;.
Next, &lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt; is picked since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
10 &lt; 50 %]]&gt;&lt;/script&gt; and going to be put into &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = [3, 6, 10, (23)]              // [23]
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7, 10]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After &lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt; is picked, we move the index of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt;.
Next, &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt; is picked since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
23 &lt; 50 %]]&gt;&lt;/script&gt; and going to be put into &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = [3, 6, 10, 23]                // []
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7, 10, 23]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt; is picked, there is no need to compare again
since the &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt; is the last element in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A = [3, 6, 10, 23]                // []
B = [2, 7, 50, 55]                // []
L = [2, 3, 6, 7, 10, 23, 50, 55]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, we can append all the rest elements
from &lt;script type=&quot;math/tex&quot;&gt;50&lt;/script&gt; to the end of &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; into the &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.
Finally, we get a sort list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;swapping-the-elements-one-by-one&quot;&gt;Swapping the elements one by one&lt;/h4&gt;

&lt;p&gt;Another idea to merge the two sorted lists
&lt;script type=&quot;math/tex&quot;&gt;A = [3, 6, 10, 23]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = [2, 7, 50, 55]&lt;/script&gt;,
is to couple them together into a list &lt;script type=&quot;math/tex&quot;&gt;L = A \cup B&lt;/script&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- element who will be moved
L = [3, 6, 10, 23, | (2), 7, 50, 55]

// The '|' doesn't exist! It's only a notation for better explanation.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and then move the minimal element of the later list(&lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;)
to the right position of the former list(&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;).&lt;/p&gt;

&lt;p&gt;The way for finding right the position is to compare the elements one by one
from the end of the former list(&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;) to its head.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- element who will be moved
L = [3, 6, 10, (2), 23, | 7, 50, 55]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In our example, the &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; is swapped with &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt; since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
2 &lt; 23 %]]&gt;&lt;/script&gt;.
Then we keep comparing &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- element who will be moved
L = [3, 6, (2), 10, 23, | 7, 50, 55]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Similarly, the &lt;script type=&quot;math/tex&quot;&gt;2, 10&lt;/script&gt; are swapped since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
2 &lt; 10 %]]&gt;&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- element who will be moved
L = [3, (2), 6,  10, 23, | 7, 50, 55]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, the &lt;script type=&quot;math/tex&quot;&gt;2, 6&lt;/script&gt; are swapped since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
2 &lt; 6 %]]&gt;&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- element who will be moved
L = [(2), 3, 6,  10, 23, | 7, 50, 55]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, the &lt;script type=&quot;math/tex&quot;&gt;2, 3&lt;/script&gt; are swapped since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
2 &lt; 3 %]]&gt;&lt;/script&gt;.
After this round, there is nothing to compare,
so the &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; is moved to its right position.
Now &lt;script type=&quot;math/tex&quot;&gt;A = [2, 3, 6, 10, 23]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = [7, 50, 55]&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;In the same way, we can do this process again with &lt;script type=&quot;math/tex&quot;&gt;7&lt;/script&gt;.
It’s the minimal element of the later list &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; now.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- element who will be moved
L = [2, 3, 6, 10, 23, | (7), 50, 55]
L = [2, 3, 6, 10, (7), 23, | 50, 55]
L = [2, 3, 6, (7), 10, 23, | 50, 55]

L = [2, 3, 6, 7, 10, 23, | 50, 55]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After this round, &lt;script type=&quot;math/tex&quot;&gt;A = [2, 3, 6, 7, 10, 23]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = [50, 55]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Then do it again with with &lt;script type=&quot;math/tex&quot;&gt;50&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- element who will be moved
L = [2, 3, 6,  7, 10, 23, | (50), 55]

L = [2, 3, 6,  7, 10, 23, 50, | 55]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;However, &lt;script type=&quot;math/tex&quot;&gt;50&lt;/script&gt; doesn’t move because &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
23 &lt; 50 %]]&gt;&lt;/script&gt;.
We just need to append &lt;script type=&quot;math/tex&quot;&gt;50&lt;/script&gt; to the end of the former list &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.
After this round, &lt;script type=&quot;math/tex&quot;&gt;A = [2, 3, 6, 7, 10, 23, 50]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = [55]&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() &amp;lt;- element who will be moved
L = [2, 3, 6,  7, 10, 23, 50, | (55)]

L = [2, 3, 6,  7, 10, 23, 50, 55]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It’s same to &lt;script type=&quot;math/tex&quot;&gt;55&lt;/script&gt;.
It doesn’t need to be moved since &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
50 &lt; 55 %]]&gt;&lt;/script&gt;,
so just append it to the &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.
Finally, &lt;script type=&quot;math/tex&quot;&gt;A = [2, 3, 6, 7, 10, 23, 50, 55]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = []&lt;/script&gt; is empty now.
Now we have a sorted list &lt;script type=&quot;math/tex&quot;&gt;L = A \cup B = A&lt;/script&gt;!&lt;/p&gt;

&lt;h4 id=&quot;which-merge-method-is-better&quot;&gt;Which merge method is better&lt;/h4&gt;

&lt;p&gt;The first method use &lt;strong&gt;extra space&lt;/strong&gt; to store the sorted results,
rather than the second in-place solution.
On the other hand, the second method needs &lt;strong&gt;more swapping executions&lt;/strong&gt;
and its a linear operation.
For better performance, we take the first method as our approach here.&lt;/p&gt;

&lt;p&gt;Actually, there is a way to save the extra space
and it works as fast as the first method above.
However, it’s complicated.
I will write another post for illustrating it.
Please refer &lt;em&gt;In-place merge sort&lt;/em&gt; in &lt;a href=&quot;https://github.com/liuxinyu95/AlgoXY/releases/download/v0.618033/elementary-algorithms.pdf&quot; title=&quot;Elementary Algorithms&quot;&gt;Elementary Algorithms&lt;/a&gt;
to read it.&lt;/p&gt;

&lt;h2 id=&quot;algorithm&quot;&gt;Algorithm&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{MergeSort($L$):} \\
&amp; \space \space \space \space \text{mergeSort($L, 1, \vert L \vert$)}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{mergeSort($L, l, r$):} \\
&amp; \space \space \space \space \text{if $l &lt; r$:} \\
&amp; \space \space \space \space \space \space \space \space m \leftarrow \lfloor \frac{l+r}{2} \rfloor \\
&amp; \space \space \space \space \space \space \space \space \text{mergeSort($L, l, m$)} \\
&amp; \space \space \space \space \space \space \space \space \text{mergeSort($L, m+1, r$)} \\
&amp; \space \space \space \space \space \space \space \space \text{merge($L, l, m, r$)} \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{merge($L, l, m, r$):} \\
&amp; \space \space \space \space L^\prime \leftarrow [] \\
&amp; \space \space \space \space i \leftarrow l, j \leftarrow m+1, k \leftarrow l \\
&amp; \space \space \space \space \text{while $i \leq m$ and $j \leq r$:} \\
&amp; \space \space \space \space \space \space \space \space \text{if $L[i] &lt; L[j]$}: \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[i] \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space i \leftarrow i + 1 \\
&amp; \space \space \space \space \space \space \space \space \text{else}: \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[j] \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space j \leftarrow j + 1 \\
&amp; \space \space \space \space \space \space \space \space k \leftarrow k + 1 \\
&amp; \space \space \space \space \text{while $i \leq m$:} \\
&amp; \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[i] \\
&amp; \space \space \space \space \space \space \space \space i \leftarrow i + 1 \\
&amp; \space \space \space \space \space \space \space \space k \leftarrow k + 1 \\
&amp; \space \space \space \space \text{while $j \leq r$:} \\
&amp; \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[j] \\
&amp; \space \space \space \space \space \space \space \space j \leftarrow j + 1 \\
&amp; \space \space \space \space \space \space \space \space k \leftarrow k + 1 \\
&amp; \space \space \space \space \text{for $i \leftarrow l$ to $r$:} \\
&amp; \space \space \space \space \space \space \space \space L[i] \leftarrow L^\prime[i] \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;/h3&gt;

&lt;h4 id=&quot;correctness-of-merge&quot;&gt;Correctness of &lt;em&gt;Merge&lt;/em&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  List L

        &amp;lt;------   sorted   ------&amp;gt; &amp;lt;------   sorted  -------&amp;gt;
        &amp;lt;- merged -&amp;gt; &amp;lt;---  A  ---&amp;gt; &amp;lt;- merged -&amp;gt; &amp;lt;---  B  ---&amp;gt;
  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----
   ... | l | ...... | i | ... | m | m+1 | .... | j | ... | r | ...
  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----
                      ^                          ^
                head of sublist A          head of sublist B

  List L'

   &amp;lt;--   merged  --&amp;gt; &amp;lt;---   empty   ---&amp;gt;
  +---+-------+-----+---+-------+-------+
  | 1 |  ...  | k-1 | k | ..... | r-l+1 |
  +---+-------+-----+---+-------+-------+
                      ^
                head of empty area of list L'

  L[l...m]    : the sorted sublists for merging with L[m+1...r]
  L[m+1...r]  : the sorted sublists for merging with L[l...m]
  A, B        : the sublists containing elements that have NOT been merged yet
  L'[1...k-1] : the merged list from L[l...i-1] and L[m+1...j-1]

  i: The index of the first element in L[l...m] that has NOT been merged yet
  j: The index of the first element in L[m+1...r] that has NOT been merged yet
  k: The index of next merged element copied from L[i] or L[j]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Loop Invariant&lt;/strong&gt;:
At the beginning of the while-loop, the following conditions hold:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sublists &lt;script type=&quot;math/tex&quot;&gt;L[i...m]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[j...r]&lt;/script&gt; are sorted&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L^\prime&lt;/script&gt; holds the elements from sublists &lt;script type=&quot;math/tex&quot;&gt;L[l...i-1]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[m+1...j-1]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;All elements in &lt;script type=&quot;math/tex&quot;&gt;L^\prime[1...k-1]&lt;/script&gt; is less or equal than
sublists &lt;script type=&quot;math/tex&quot;&gt;L[i...m]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[j...r]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L^\prime&lt;/script&gt; are sorted.
Formally, &lt;script type=&quot;math/tex&quot;&gt;\forall i \in [l + 1, r], L^\prime[i - 1] \leq L^\prime[i]&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then we use loop-invariants to prove:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Initialization: At the very beginning when &lt;script type=&quot;math/tex&quot;&gt;k = 1, i = l, j = m+1&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;the input &lt;script type=&quot;math/tex&quot;&gt;L[l...m], L[m+1...r]&lt;/script&gt; are sorted so &lt;em&gt;1&lt;/em&gt; holds&lt;/li&gt;
      &lt;li&gt;the list &lt;script type=&quot;math/tex&quot;&gt;L^\prime&lt;/script&gt; is empty so &lt;em&gt;2, 3, 4&lt;/em&gt; hold&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Maintenance: Consider the iteration &lt;script type=&quot;math/tex&quot;&gt;k = x&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;1&lt;/em&gt; is preserved since there is no change in &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;2&lt;/em&gt; is preserved because
        &lt;ul&gt;
          &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
j &gt; r \lor (i \leq m \land L[i] &lt; L[j]) %]]&gt;&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L^\prime[k] \leftarrow L[i]&lt;/script&gt;
            &lt;ul&gt;
              &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;k \leftarrow k+1, i \leftarrow i+1&lt;/script&gt;&lt;/li&gt;
              &lt;li&gt;&lt;em&gt;3&lt;/em&gt; is preserved because &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
L[k-1] = L[i-1] &lt; L[j] \leq L[j+1] \leq ... \leq L[r] %]]&gt;&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;L[k-1] = L[i-1] \leq L[i] \leq ... \leq L[m]&lt;/script&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Otherwise, &lt;script type=&quot;math/tex&quot;&gt;L^\prime[k] \leftarrow L[j]&lt;/script&gt;
            &lt;ul&gt;
              &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;k \leftarrow k+1, j \leftarrow j+1&lt;/script&gt;&lt;/li&gt;
              &lt;li&gt;&lt;em&gt;3&lt;/em&gt; is preserved because &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
L[k-1] = L[j-1] &lt; L[j] \leq L[j+1] \leq ... \leq L[r] %]]&gt;&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;L[k-1] = L[j-1] \leq L[i] \leq L[i+1] \leq ... \leq L[m]&lt;/script&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;The previous appended element must be smaller than
the current selected minimal element or &lt;em&gt;1&lt;/em&gt; is false&lt;/li&gt;
      &lt;li&gt;By &lt;em&gt;3&lt;/em&gt;, the next selected minimal element will be larger than current one&lt;/li&gt;
      &lt;li&gt;So &lt;em&gt;4&lt;/em&gt; is also preserved&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Termination
    &lt;ul&gt;
      &lt;li&gt;By &lt;strong&gt;2&lt;/strong&gt;, &lt;script type=&quot;math/tex&quot;&gt;L^\prime&lt;/script&gt; consists of the elements in &lt;script type=&quot;math/tex&quot;&gt;L[l...r]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;By &lt;strong&gt;4&lt;/strong&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[l...r] = L^\prime[l...r]&lt;/script&gt; are sorted&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;correctness-of-merge-sort&quot;&gt;Correctness of &lt;em&gt;Merge Sort&lt;/em&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; elements,
the &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; can be sorted
by applying the above the &lt;em&gt;MergeSort&lt;/em&gt; with &lt;script type=&quot;math/tex&quot;&gt;l = 1, r = N&lt;/script&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Base step: When &lt;script type=&quot;math/tex&quot;&gt;N = 1&lt;/script&gt;, it’s trivial.&lt;/li&gt;
  &lt;li&gt;Induction Hypothesis:
Suppose this assumption holds when list has &lt;script type=&quot;math/tex&quot;&gt;N = 1, 2, ..., k&lt;/script&gt; elements&lt;/li&gt;
  &lt;li&gt;Induction Step: When &lt;script type=&quot;math/tex&quot;&gt;N = k + 1&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;the list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; is divide to &lt;script type=&quot;math/tex&quot;&gt;L[1...m]&lt;/script&gt;(&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; elements)
and &lt;script type=&quot;math/tex&quot;&gt;L[m+1...N]&lt;/script&gt;(&lt;script type=&quot;math/tex&quot;&gt;N - m&lt;/script&gt; elements)&lt;/li&gt;
      &lt;li&gt;so &lt;script type=&quot;math/tex&quot;&gt;m = \lfloor \frac{1+(k+1)}{2} \rfloor = \lfloor \frac{k}{2} \rfloor + 1 \leq k&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;and &lt;script type=&quot;math/tex&quot;&gt;1 \leq m \implies 0 \leq m-1 \implies k \leq k-1+m \implies \\
  k+1 \leq k+m \implies (k+1)-m \leq k \implies N-m \leq k&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;By our hypothesis, &lt;script type=&quot;math/tex&quot;&gt;L[1...m]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[m+1...N]&lt;/script&gt; can be sorted&lt;/li&gt;
      &lt;li&gt;By the proved correctness of &lt;em&gt;merge&lt;/em&gt; above,
the merged &lt;script type=&quot;math/tex&quot;&gt;L[1...m]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[m+1...N]&lt;/script&gt; is also sorted,
so the proof is done&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;complexity&quot;&gt;Complexity&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ^    +------------------------------------------------------+   Merge
  |    |                           N                          |   Complexity
  |    +------------------------------------------------------+
  |                 |                              |
  |                 v                              v
  |    +------------------------+    +------------------------+
  |    |           N/2          |    |           N/2          |   2 * O(N/2)
  |    +------------------------+    +------------------------+
  |         |              |              |              |
            v              v              v              v
  K    +---------+    +---------+    +---------+    +---------+
       |   N/4   |    |   N/4   |    |   N/4   |    |   N/4   |   4 * O(N/4)
  |    +---------+    +---------+    +---------+    +---------+
  |      |     |        |     |        |     |        |     |
  |      v     v        v     v        v     v        v     v
  |
  |                        .  .  .  .  .  .                       2^i * O(N/(2^i))
  |
  |    +---+  +---+  +---+                                +---+
  |    | 1 |  | 1 |  | 1 |  .  .  .  .  .  .  .  .  .  .  | 1 |   N * O(1)
  v    +---+  +---+  +---+                                +---+

  N: the number of list elements.
  K: K layers from N to 1.
     N/2^k = 1 =&amp;gt; N = 2^K =&amp;gt; K = log_2(N)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above figure is the &lt;strong&gt;recursion tree&lt;/strong&gt; of &lt;em&gt;merge sort&lt;/em&gt;.
The list containing &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; elements is recursively divided to sort
until there is only one elements.
Suppose that there is &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; times of division, therefore,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\frac{ N }{ 2^K }   &amp;= 1 \\
\implies          N &amp;= 2^K \\
\implies          K &amp;= \log_{ 2 }N
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;On the other hand, the time complexity
depends on the performance of &lt;em&gt;merge&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;T_{merge}(N)&lt;/script&gt;.
The used &lt;em&gt;merge&lt;/em&gt; here is the basic version.
It iteratively picks the minimal elements from both sublists
then copied to another list &lt;script type=&quot;math/tex&quot;&gt;L^\prime&lt;/script&gt;.
After all the elements in one sublist are all selected,
we move the rest elements in the other sublist to list &lt;script type=&quot;math/tex&quot;&gt;L^\prime&lt;/script&gt;.
Finally, we assigned &lt;script type=&quot;math/tex&quot;&gt;L[i] \leftarrow L^\prime[i]&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\forall i \in [1, N]&lt;/script&gt;.
Thus, &lt;script type=&quot;math/tex&quot;&gt;T_{merge}(N)&lt;/script&gt; can be defined as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T_{merge}(N) = c \cdot N&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is a constant reflecting the basic operations
like comparisons or assignments for merging routine.&lt;/p&gt;

&lt;h3 id=&quot;by-the-recursion-tree&quot;&gt;By the recursion tree&lt;/h3&gt;

&lt;p&gt;From the above figure, the total time for the &lt;em&gt;merge sort&lt;/em&gt; is
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
\overbrace{
2 \cdot c \cdot \frac{N}{2} +
4 \cdot c \cdot \frac{N}{4} +
8 \cdot c \cdot \frac{N}{8} +
... +
N \cdot c \cdot 1
}^{K}
&amp;= K \cdot c \cdot N \\
&amp;= c \cdot N \cdot \log_{ 2 }N
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Thus, the time complexity is &lt;script type=&quot;math/tex&quot;&gt;\mathcal{O}(N \log N)&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;by-telescoping&quot;&gt;By telescoping&lt;/h3&gt;

&lt;p&gt;Formally, since the &lt;em&gt;merge sort&lt;/em&gt; repeatedly breaks down the &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;-elements list
into two &lt;script type=&quot;math/tex&quot;&gt;\frac{N}{2}&lt;/script&gt;-elements sublists,
the amount of time that &lt;em&gt;merge sort&lt;/em&gt;, &lt;script type=&quot;math/tex&quot;&gt;T_{sort}(N)&lt;/script&gt;,
can be written as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
T_{sort}(N)
&amp;= T_{sort}(\frac{N}{2}) + T_{sort}(\frac{N}{2}) + T_{merge}(N) \\
&amp;= 2 \cdot T_{sort}(\frac{N}{2}) + T_{merge}(N) \\
&amp;= 2 \cdot T_{sort}(\frac{N}{2}) + c \cdot N
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
T_{sort}(N)
&amp;= 2 \cdot T_{sort}(\frac{N}{2}) + c \cdot N \\
&amp;= 2 \cdot (2 \cdot T_{sort}(\frac{N}{4}) + c \cdot \frac{N}{2}) + c \cdot N \\
&amp;= 2^2 \cdot T_{sort}(\frac{N}{4}) + 2 \cdot c \cdot N \\
&amp;= 2^2 \cdot (2 \cdot T_{sort}(\frac{N}{8}) + c \cdot \frac{N}{4}) + 2 \cdot c \cdot N \\
&amp;= 2^3 \cdot T_{sort}(\frac{N}{4}) + 3 \cdot c \cdot N \\
&amp;= ... \\
&amp;= 2^K \cdot T_{sort}(\frac{N}{2^K}) + K \cdot c \cdot N \\
&amp;= N \cdot T_{sort}(1) + K \cdot c \cdot N \\
&amp;= N \cdot 1 + K \cdot c \cdot N \\
&amp;= N + c \cdot N \cdot \log_{ 2 }N
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, the time complexity is &lt;script type=&quot;math/tex&quot;&gt;\mathcal{O}(N \log N)&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;See the files on &lt;a href=&quot;https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb&quot; title=&quot;Sorting&quot;&gt;gist here&lt;/a&gt;.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;algorithm&amp;gt;  // for std::min, std::swap
#include &amp;lt;cassert&amp;gt;
#include &amp;lt;cstring&amp;gt;    // for memcpy
#include &amp;quot;sorting.h&amp;quot;

/*
 * Merge sort: O(n * log(n))
 */
// Basic merge: O(n)
// The following is the most straightforward way to merge two sorted array.
// However, it allocates extra memory for sorted results in every recursion.
void merge(int list[],
           const unsigned int left,
           const unsigned int division,
           const unsigned int right)
{
  assert(left &amp;lt;= right);
  //      |&amp;lt;-- sorted --&amp;gt;|&amp;lt;-- sorted --&amp;gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  unsigned int i = left;
  unsigned int j = division + 1;
  const unsigned int size = right - left + 1;
  int array[size];

  // When left &amp;lt;= i &amp;lt;= div and div + 1 &amp;lt;= j &amp;lt;= right:
  // Compare list[i] and list[j], if list[i] &amp;lt; list[j], then copy list[i] into
  // the new array and let i = i + 1. Otherwise, copy list[j] into the new array
  // and let j = j + 1. If i &amp;gt; div, it means list[left...div] is all compared
  // and already copied, so we just need to put the rest list[j...right] into
  // the array. In the same way, if j &amp;gt; right, then put the rest list[i...div]
  // into the array.
  unsigned int k = 0;
  for (k = 0 ; k &amp;lt; size; ++k) {
    array[k] = (j &amp;gt; right || (i &amp;lt;= division &amp;amp;&amp;amp; list[i] &amp;lt; list[j])) ? list[i++] : list[j++];
  }

  // while (i &amp;lt;= division &amp;amp;&amp;amp; j &amp;lt;= right) {
  //   array[k++] = (list[i] &amp;lt; list[j]) ? list[i++] : list[j++];
  //   // if (list[i] &amp;lt; list[j]) {
  //   //   array[k] = list[i];
  //   //   ++i;
  //   // } else {
  //   //   array[k] = list[j];
  //   //   ++j;
  //   // }
  //   // ++k;
  // }
  //
  // // In this case, j &amp;gt; right, so we put the rest list[i...div] into the array.
  // while (i &amp;lt;= division) {
  //   array[k++] = list[i++];
  //   // array[k] = list[i];
  //   // ++i;
  //   // ++k;
  // }
  //
  // // in this case, i &amp;gt; div, so we put the rest list[j...right] into the array.
  // while (j &amp;lt;= right) {
  //   array[k++] = list[j++];
  //   // array[k] = list[j];
  //   // ++j;
  //   // ++k;
  // }

  assert(k == size);
  assert(i == division + 1);
  assert(j == right + 1);

  // Overwrite list[left...right] by the new sorted array.
  for (k = 0 ; k &amp;lt; size ; ++k) {
    list[left + k] = array[k];
  }
  assert(left + k == right + 1);
}

// Append ∞ as the last sentinel element to the both ordered arrays for merging.
void mergeWithSentinel(int list[], unsigned int left, unsigned int division, unsigned int right)
{
  assert(left &amp;lt;= right);
  //      |&amp;lt;-- sorted --&amp;gt;|&amp;lt;-- sorted --&amp;gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  //      |&amp;lt;---  A&amp;#39;  ---&amp;gt;|&amp;lt;---  B&amp;#39;  ---&amp;gt;|

  // Allocate list A = A&amp;#39; ∪ [INFINITY] and list B = B&amp;#39; ∪ [INFINITY]
  const static int INFINITY = ((unsigned int)(-1) &amp;gt;&amp;gt; 1);
  const unsigned int sizeA = division - left + 2; // (division - left + 1) + 1
  const unsigned int sizeB = right - division + 1; // (right - (division + 1) + 1) + 1
  int *A = new int[sizeA]; // 1 is for [ INFINITY ]
  int *B = new int[sizeB];
  // Copy elements from list[left...division] to A&amp;#39;[0...(sizeA - 2)].
  memcpy((void*)A, (void*)(list + left), sizeof(int) * (sizeA - 1));
  // Copy elements from list[(division + 1)...right] to B&amp;#39;[0...(sizeB - 2)].
  memcpy((void*)B, (void*)(list + division + 1), sizeof(int) * (sizeB - 1));
  // Set the last elements of A and B to INFINITY.
  A[sizeA - 1] = B[sizeB - 1] = INFINITY;
  // Move the sorted elements of A and B to list[left...right].
  unsigned int i, j;
  for (i = j = 0 ; left &amp;lt;= right ; ++left) {
    list[left] = A[i] &amp;lt; B[j] ? A[i++] : B[j++];
  }
  free(A);
  free(B);
}

// The following method demonstrates a in-place version of merge method.
// However, it downgrades mergesort overall performance to quadratic O(n^2)!
// Naive in-place merge: O(n^2)
void naiveInplaceMerge(int list[],
           const unsigned int left,
           const unsigned int division,
           const unsigned int right)
{
  assert(left &amp;lt;= right);
  //      |&amp;lt;-- sorted --&amp;gt;|&amp;lt;-- sorted --&amp;gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  unsigned int anchor = left;
  for (unsigned int i = division + 1 ; i &amp;lt;= right ; ++i) {
    for (unsigned int j = i ; j &amp;gt; anchor ; --j) { // Replace anchor with left is fine.
      // The following condition is definitely true and will be triggered.
      // list[division + k + 1] &amp;gt;= list[division + k] where k &amp;gt;= 1
      // is assertive because list[division + 1 .... right] is a sorted from
      // minimal item to maximal one.
      if (list[j] &amp;gt;= list[j-1]) {
        anchor = j;
        break;
      }
      std::swap(list[j], list[j-1]);
    }
  }
}

void topDownMergeSort(int list[], const unsigned int left, const unsigned int right)
{
  if (left &amp;gt;= right) {
    return;
  }

  const unsigned int middle = (left + right) / 2;
  topDownMergeSort(list, left, middle);
  topDownMergeSort(list, middle + 1, right);
  merge(list, left, middle, right);
  // mergeWithSentinel(list, left, middle, right);
  // naiveInplaceMerge(list, left, middle, right); // Slower!
}

void bottomUpMergeSort(int list[], const unsigned int length)
{
  // &amp;lt;----------  l = 2^k + r  ----------&amp;gt;  where k, r are integers, k &amp;gt;= 0,
  // &amp;lt;-----  2^k  -----&amp;gt;|&amp;lt;-----  r  -----&amp;gt;  and 0 &amp;lt;= r &amp;lt; 2^k.
  // +---+---+---------+---+---------+---+
  // | 0 | 1 | ....... | n | ....... | m |
  // +---+---+---------+---+---------+---+
  //
  // l            k  r
  // 1 : 2^0 + 0  0  0
  // 2 : 2^1 + 0  1  0
  // 3 : 2^1 + 1  1  1
  // 4 : 2^2 + 0  2  0
  // 5 : 2^2 + 1  2  1
  // 6 : 2^2 + 2  2  2
  // 7 : 2^2 + 3  2  3
  // 8 : 2^3 + 0  3  0
  // 9 : 2^3 + 1  3  1
  // ...
  // ...
  //
  // When r = 0:  The length of list is powers of 2, denoted 2^k, so all the
  //              size of blocks for merging must be same. At the round (k+1),
  //              the size is 2^k, where k &amp;gt;= 0 is a integer.
  // When r != 0: We can consider there are extra &amp;#39;r&amp;#39; elements added into the
  //              above list whose length is powers of 2.
  //              The extra &amp;#39;r&amp;#39; elements will be merged when the block size is
  //              grown to 2^k, where k &amp;gt;= 0 and 0 &amp;lt; r &amp;lt; 2^k.
  //
  // Each round, the list is divided into blocks and then merged
  // from size 1, 2, 4, ... to lenght/2.
  for (unsigned int size = 1 ; size &amp;lt; length ; size *= 2) {
    // If i &amp;gt;= length - size, then the rest elements list[i .. length - 1]
    // is smaller than or equal to one block size, so there is nothing to be
    // merged. These rest elements will be merged when size = 2^k
    // and 2^(k-1) &amp;lt; length - 2^k &amp;lt; 2^k,.
    for (unsigned int i = 0 ; i &amp;lt; length - size ; i += 2 * size) {
      // Merge the adjacent two blocks.
      merge(list, i, i + size - 1, std::min(i + 2 * size - 1, length - 1));
      // mergeWithSentinel(list, i, i + size - 1, min(i + 2 * size - 1, length - 1));
      // naiveInplaceMerge(list, i, i + size - 1, min(i + 2 * size - 1, length - 1)); // Slower!

      // Uncomment below to check when the rest items will be merged.
      // if ((size/2 &amp;lt; length - size/2) &amp;amp;&amp;amp; (length - size &amp;lt; size)) {
      //   std::cout &amp;lt;&amp;lt; &amp;quot;List length: &amp;quot; &amp;lt;&amp;lt; length &amp;lt;&amp;lt; std::endl;
      //   std::cout &amp;lt;&amp;lt; &amp;quot;Merge the last &amp;quot; &amp;lt;&amp;lt; length - size &amp;lt;&amp;lt;
      //                &amp;quot; items when size is &amp;quot; &amp;lt;&amp;lt; size &amp;lt;&amp;lt; std::endl;
      //   assert(min(i + 2 * size - 1, length - 1) == length - 1);
      // }
    }
  }
}

void mergeSort(int list[], const unsigned int length)
{
  assert(length);

  // topDownMergeSort(list, 0, length - 1);
  bottomUpMergeSort(list, length);
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=merge_sort.cpp&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;appendix&quot;&gt;Appendix&lt;/h2&gt;

&lt;h3 id=&quot;correctness-of-naive-in-place-merge&quot;&gt;Correctness of &lt;em&gt;naive in-place merge&lt;/em&gt;&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{naiveInplaceMerge($L, l, m, r$):} \\
&amp; \space \space \space \space \text{for $i \leftarrow m+1$ to $r$:} \\
&amp; \space \space \space \space \space \space \space \space \text{for $j \leftarrow i$ down to $l+1$:} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{if $L[j-1] \leq L[j]$:} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \text{break} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{swap $L[j-1]$ and $L[j]$} \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;proof-by-mathematical-induction&quot;&gt;Proof by mathematical induction&lt;/h4&gt;

&lt;h5 id=&quot;lemma-1&quot;&gt;Lemma 1&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a sorted list &lt;script type=&quot;math/tex&quot;&gt;A = [a_1, a_2, ..., a_N]&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; elements,
where &lt;script type=&quot;math/tex&quot;&gt;a_1 \leq a_2 \leq ... \leq a_N&lt;/script&gt;,
and one value &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;,
the list &lt;script type=&quot;math/tex&quot;&gt;L = A \cup [x] = [a_1, a_2, ..., a_N, x]&lt;/script&gt;
(&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is appended to the end of list &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;),
can be sorted by the &lt;em&gt;naive in-place merge&lt;/em&gt; method with &lt;script type=&quot;math/tex&quot;&gt;l = 1, m = N, r = N + 1&lt;/script&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Base step: When &lt;script type=&quot;math/tex&quot;&gt;N = 0&lt;/script&gt;, list &lt;script type=&quot;math/tex&quot;&gt;L = [x]&lt;/script&gt; is trivially true&lt;/li&gt;
  &lt;li&gt;Induction Hypothesis: Suppose this assumption holds when &lt;script type=&quot;math/tex&quot;&gt;N = k&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;Induction Step: When &lt;script type=&quot;math/tex&quot;&gt;N = k + 1&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;x \geq L[k]&lt;/script&gt;, then the &lt;script type=&quot;math/tex&quot;&gt;L = a_1 \leq a_2 \leq ... \leq a_k \leq x&lt;/script&gt; is naturally sorted&lt;/li&gt;
      &lt;li&gt;Otherwise, &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
x &lt; L[k] %]]&gt;&lt;/script&gt; and the &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[k]&lt;/script&gt; are swapped.
        &lt;ul&gt;
          &lt;li&gt;Now &lt;script type=&quot;math/tex&quot;&gt;L[1...k] = [a_1, a_2, ... , a_{k-1}, x]&lt;/script&gt;&lt;/li&gt;
          &lt;li&gt;By the hypothesis, the &lt;em&gt;naive in-place merge&lt;/em&gt; works when &lt;script type=&quot;math/tex&quot;&gt;N = k&lt;/script&gt;, so we can a sorted &lt;script type=&quot;math/tex&quot;&gt;L[1...k]&lt;/script&gt;&lt;/li&gt;
          &lt;li&gt;Thus, the list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; now is sorted since &lt;script type=&quot;math/tex&quot;&gt;L[1...k]&lt;/script&gt; is sorted
and all its elements are smaller than the current &lt;script type=&quot;math/tex&quot;&gt;(k+1)&lt;/script&gt;th element &lt;script type=&quot;math/tex&quot;&gt;L[k]&lt;/script&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;lemma-2&quot;&gt;Lemma 2&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a sorted list &lt;script type=&quot;math/tex&quot;&gt;A = [a_1, a_2, ..., a_N]&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; elements
where &lt;script type=&quot;math/tex&quot;&gt;a_1 \leq a_2 \leq ... \leq a_N&lt;/script&gt;,
and &lt;script type=&quot;math/tex&quot;&gt;B = [b_1, b_2, ..., b_M]&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; elements
where &lt;script type=&quot;math/tex&quot;&gt;b_1 \leq b_2 \leq ... \leq b_M&lt;/script&gt;,
the list &lt;script type=&quot;math/tex&quot;&gt;L = A \cup B = [a_1, a_2, ..., a_N, b_1, b_2, ..., b_M]&lt;/script&gt;
can be sorted by the above &lt;em&gt;naive in-place merge&lt;/em&gt; method with &lt;script type=&quot;math/tex&quot;&gt;l = 1, m = N, r = M+N&lt;/script&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Base step: When &lt;script type=&quot;math/tex&quot;&gt;M = 1&lt;/script&gt;, the condition is same as &lt;em&gt;Lemma 1&lt;/em&gt;, so it’s true&lt;/li&gt;
  &lt;li&gt;Induction Hypothesis: Suppose this assumption holds when &lt;script type=&quot;math/tex&quot;&gt;M = k&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;Induction Step: When &lt;script type=&quot;math/tex&quot;&gt;M = k + 1&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;When &lt;script type=&quot;math/tex&quot;&gt;i = N + 1&lt;/script&gt;
        &lt;ul&gt;
          &lt;li&gt;the element &lt;script type=&quot;math/tex&quot;&gt;L[N+1]&lt;/script&gt; will be merged with &lt;script type=&quot;math/tex&quot;&gt;L[1...N] = A&lt;/script&gt;&lt;/li&gt;
          &lt;li&gt;then the list &lt;script type=&quot;math/tex&quot;&gt;L[1...N+1]&lt;/script&gt; is sorted by &lt;em&gt;Lemma 1&lt;/em&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;When &lt;script type=&quot;math/tex&quot;&gt;i = N + 2&lt;/script&gt;
        &lt;ul&gt;
          &lt;li&gt;the list is composed by sorted sublists &lt;script type=&quot;math/tex&quot;&gt;A^\prime = L[1...N+1]&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;B^\prime = L[N+2...N+k+1]&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; elements&lt;/li&gt;
          &lt;li&gt;By the hypothesis, the &lt;em&gt;naive in-place merge&lt;/em&gt; works when &lt;script type=&quot;math/tex&quot;&gt;\vert B^\prime \vert = k&lt;/script&gt;&lt;/li&gt;
          &lt;li&gt;Thus, the list &lt;script type=&quot;math/tex&quot;&gt;L = A^\prime \cup B^\prime = A \cup B&lt;/script&gt; is sorted&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www-bcf.usc.edu/~dkempe/CS104/11-07.pdf&quot; title=&quot;2013 CS104: Recursive Sorting Algorithms and their Analysis&quot;&gt;CS104&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.princeton.edu/courses/archive/spr07/cos226/lectures/04MergeQuick.pdf&quot; title=&quot;Mergesort and Quicksort&quot;&gt;COS226&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.mcgill.ca/~dprecup/courses/IntroCS/Lectures/comp250-lecture16.pdf&quot; title=&quot;Lecture 16: MergeSort proof of correctness, and running time&quot;&gt;COMP250&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.inf.unibz.it/~nutt/DSA1112/DSALabs/sols2.pdf&quot; title=&quot;Data Structures and Algorithms&quot;&gt;DSA1112&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cs.rochester.edu/~gildea/csc282/slides/C02-start.pdf&quot; title=&quot;Getting Started&quot;&gt;CSC282&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Algorithm" /><category term="Sorting" /><summary type="html">Merge Sort

This post series is synchronized with my book CodePlay
and this post could be read here.

Idea
Merge sort is an efficient algorithm that
applies the concepts of divide and conquer to sort the list.

The key idea of divide and conquer is to recursively break down the problems
into two or more sub-problems and they are same or related to the original problem,
until these divided sub-problems are simple enough to solve directly.
Then, the solutions of the original problem can be combined and derived
by the solutions of all the sub-problems.

Divide and conquer
The calculation of Fibonacci number, ,
is one example.
To calculate , it needs to find  and .
Similarly, to calculate , it needs to  and .
The sub-problems for calculating  and  have same form
as the one for .

Recursively, we will need to get , , …, , 
and  and  are easy enough to solve directly. They are both .
Thus, , , … and then 
can be computed.

Dividing the sorting-problem
Let’s apply this concept to the sorting problem.
If we want to sort the list ,
the sub-lists  must also be sorted,
so we can narrow down our problem scope for handling the sub-lists.
Next,  can be divided to 
and  also can be split into  and .
Finally,  are not dividable
so we stop breaking down the list.

       [6, 3, 7, 1, 9, 2, 5]
         /               \
   [6, 3, 7, 1]       [9, 2, 5]
    /        \          /     \
 [6, 3]    [7, 1]    [9, 2]  [5]
 /    \    /    \    /    \
[6]  [3]  [7]  [1]  [9]  [2]



In the same way, the whole list can be divided into
.

Conquering the sub-problems
After there is only one element left,
the subproblem is solved by nature since it’s already sorted.

However, the problem becomes

  how do we combine these sorted chunks into a sorted list


We need a method that can merge two sorted lists,
 and , where ,
into a bigger sorted list .

Combining all the results of sub-sorting-problem

Suppose we have two sorted lists  and .
We provide two ways to merge them into a sorted list.

Picking the smallest elements one by one
The simplest method is to pick the smallest elements iteratively
by searching both lists from the minimal to maximal.

We only need to compare the left most elements of both lists
and pick the smaller one since  and  are already sorted.

The following example demonstrate the process of this idea:

() &amp;lt;- search index

A = [(3), 6, 10, 23]
B = [(2), 7, 50, 55]
L = []                            // &amp;lt;- 2


In the first round,  is picked since 
and going to be put into another list .

                                  // You can think the left most element
                                  // is shifted one by one
A = [(3), 6, 10, 23]              // [3, 6, 10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2]                           // &amp;lt;- 3



After  is picked, we move the index of  from  to .
Next,  is picked since  and going to be put into .

A = [3, (6), 10, 23]              // [6, 10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2, 3]                        // &amp;lt;- 6



After  is picked, we move the index of  from  to .
Next,  is picked since  and going to be put into .

A = [3, 6, (10), 23]              // [10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2, 3, 6]                     // &amp;lt;- 7



After  is picked, we move the index of  from  to .
Next,  is picked since  and going to be put into .

A = [3, 6, (10), 23]              // [10, 23]
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7]                  // &amp;lt;- 10



After  is picked, we move the index of  from  to .
Next,  is picked since  and going to be put into .

A = [3, 6, 10, (23)]              // [23]
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7, 10]



After  is picked, we move the index of  from  to .
Next,  is picked since  and going to be put into .

A = [3, 6, 10, 23]                // []
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7, 10, 23]



After  is picked, there is no need to compare again
since the  is the last element in .

A = [3, 6, 10, 23]                // []
B = [2, 7, 50, 55]                // []
L = [2, 3, 6, 7, 10, 23, 50, 55]



Next, we can append all the rest elements
from  to the end of  into the .
Finally, we get a sort list .

Swapping the elements one by one

Another idea to merge the two sorted lists
 and ,
is to couple them together into a list 

() &amp;lt;- element who will be moved
L = [3, 6, 10, 23, | (2), 7, 50, 55]

// The '|' doesn't exist! It's only a notation for better explanation.



and then move the minimal element of the later list()
to the right position of the former list().

The way for finding right the position is to compare the elements one by one
from the end of the former list() to its head.

() &amp;lt;- element who will be moved
L = [3, 6, 10, (2), 23, | 7, 50, 55]



In our example, the  is swapped with  since .
Then we keep comparing  with .

() &amp;lt;- element who will be moved
L = [3, 6, (2), 10, 23, | 7, 50, 55]



Similarly, the  are swapped since .

() &amp;lt;- element who will be moved
L = [3, (2), 6,  10, 23, | 7, 50, 55]



Next, the  are swapped since .

() &amp;lt;- element who will be moved
L = [(2), 3, 6,  10, 23, | 7, 50, 55]



Next, the  are swapped since .
After this round, there is nothing to compare,
so the  is moved to its right position.
Now  and 

In the same way, we can do this process again with .
It’s the minimal element of the later list  now.

() &amp;lt;- element who will be moved
L = [2, 3, 6, 10, 23, | (7), 50, 55]
L = [2, 3, 6, 10, (7), 23, | 50, 55]
L = [2, 3, 6, (7), 10, 23, | 50, 55]

L = [2, 3, 6, 7, 10, 23, | 50, 55]



After this round,  and .

Then do it again with with .

() &amp;lt;- element who will be moved
L = [2, 3, 6,  7, 10, 23, | (50), 55]

L = [2, 3, 6,  7, 10, 23, 50, | 55]



However,  doesn’t move because .
We just need to append  to the end of the former list .
After this round,  and .

() &amp;lt;- element who will be moved
L = [2, 3, 6,  7, 10, 23, 50, | (55)]

L = [2, 3, 6,  7, 10, 23, 50, 55]



It’s same to .
It doesn’t need to be moved since ,
so just append it to the .
Finally,  and  is empty now.
Now we have a sorted list !

Which merge method is better

The first method use extra space to store the sorted results,
rather than the second in-place solution.
On the other hand, the second method needs more swapping executions
and its a linear operation.
For better performance, we take the first method as our approach here.

Actually, there is a way to save the extra space
and it works as fast as the first method above.
However, it’s complicated.
I will write another post for illustrating it.
Please refer In-place merge sort in Elementary Algorithms
to read it.

Algorithm







Proof

Correctness of Merge

  List L

        &amp;lt;------   sorted   ------&amp;gt; &amp;lt;------   sorted  -------&amp;gt;
        &amp;lt;- merged -&amp;gt; &amp;lt;---  A  ---&amp;gt; &amp;lt;- merged -&amp;gt; &amp;lt;---  B  ---&amp;gt;
  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----
   ... | l | ...... | i | ... | m | m+1 | .... | j | ... | r | ...
  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----
                      ^                          ^
                head of sublist A          head of sublist B

  List L'

   &amp;lt;--   merged  --&amp;gt; &amp;lt;---   empty   ---&amp;gt;
  +---+-------+-----+---+-------+-------+
  | 1 |  ...  | k-1 | k | ..... | r-l+1 |
  +---+-------+-----+---+-------+-------+
                      ^
                head of empty area of list L'

  L[l...m]    : the sorted sublists for merging with L[m+1...r]
  L[m+1...r]  : the sorted sublists for merging with L[l...m]
  A, B        : the sublists containing elements that have NOT been merged yet
  L'[1...k-1] : the merged list from L[l...i-1] and L[m+1...j-1]

  i: The index of the first element in L[l...m] that has NOT been merged yet
  j: The index of the first element in L[m+1...r] that has NOT been merged yet
  k: The index of next merged element copied from L[i] or L[j]



Loop Invariant:
At the beginning of the while-loop, the following conditions hold:


  Sublists  and  are sorted
   holds the elements from sublists  and 
  All elements in  is less or equal than
sublists  and 
   are sorted.
Formally, 


Then we use loop-invariants to prove:


  Initialization: At the very beginning when 
    
      the input  are sorted so 1 holds
      the list  is empty so 2, 3, 4 hold
    
  
  Maintenance: Consider the iteration 
    
      1 is preserved since there is no change in 
      2 is preserved because
        
          If , 
            
              then 
              3 is preserved because 
and 
            
          
          Otherwise, 
            
              then 
              3 is preserved because 
and 
            
          
        
      
      The previous appended element must be smaller than
the current selected minimal element or 1 is false
      By 3, the next selected minimal element will be larger than current one
      So 4 is also preserved
    
  
  Termination
    
      By 2,  consists of the elements in 
      By 4,  are sorted
    
  


Correctness of Merge Sort


  Given a list  with  elements,
the  can be sorted
by applying the above the MergeSort with .



  Base step: When , it’s trivial.
  Induction Hypothesis:
Suppose this assumption holds when list has  elements
  Induction Step: When 
    
      the list  is divide to ( elements)
and ( elements)
      so 
      and 
      By our hypothesis,  and  can be sorted
      By the proved correctness of merge above,
the merged  and  is also sorted,
so the proof is done
    
  


Complexity

  ^    +------------------------------------------------------+   Merge
  |    |                           N                          |   Complexity
  |    +------------------------------------------------------+
  |                 |                              |
  |                 v                              v
  |    +------------------------+    +------------------------+
  |    |           N/2          |    |           N/2          |   2 * O(N/2)
  |    +------------------------+    +------------------------+
  |         |              |              |              |
            v              v              v              v
  K    +---------+    +---------+    +---------+    +---------+
       |   N/4   |    |   N/4   |    |   N/4   |    |   N/4   |   4 * O(N/4)
  |    +---------+    +---------+    +---------+    +---------+
  |      |     |        |     |        |     |        |     |
  |      v     v        v     v        v     v        v     v
  |
  |                        .  .  .  .  .  .                       2^i * O(N/(2^i))
  |
  |    +---+  +---+  +---+                                +---+
  |    | 1 |  | 1 |  | 1 |  .  .  .  .  .  .  .  .  .  .  | 1 |   N * O(1)
  v    +---+  +---+  +---+                                +---+

  N: the number of list elements.
  K: K layers from N to 1.
     N/2^k = 1 =&amp;gt; N = 2^K =&amp;gt; K = log_2(N)



The above figure is the recursion tree of merge sort.
The list containing  elements is recursively divided to sort
until there is only one elements.
Suppose that there is  times of division, therefore,



On the other hand, the time complexity
depends on the performance of merge .
The used merge here is the basic version.
It iteratively picks the minimal elements from both sublists
then copied to another list .
After all the elements in one sublist are all selected,
we move the rest elements in the other sublist to list .
Finally, we assigned , .
Thus,  can be defined as



where  is a constant reflecting the basic operations
like comparisons or assignments for merging routine.

By the recursion tree

From the above figure, the total time for the merge sort is


Thus, the time complexity is .

By telescoping

Formally, since the merge sort repeatedly breaks down the -elements list
into two -elements sublists,
the amount of time that merge sort, ,
can be written as follows:





Thus, the time complexity is .

Implementation

See the files on gist here.

#include &amp;lt;algorithm&amp;gt;  // for std::min, std::swap
#include &amp;lt;cassert&amp;gt;
#include &amp;lt;cstring&amp;gt;    // for memcpy
#include &amp;quot;sorting.h&amp;quot;

/*
 * Merge sort: O(n * log(n))
 */
// Basic merge: O(n)
// The following is the most straightforward way to merge two sorted array.
// However, it allocates extra memory for sorted results in every recursion.
void merge(int list[],
           const unsigned int left,
           const unsigned int division,
           const unsigned int right)
{
  assert(left &amp;lt;= right);
  //      |&amp;lt;-- sorted --&amp;gt;|&amp;lt;-- sorted --&amp;gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  unsigned int i = left;
  unsigned int j = division + 1;
  const unsigned int size = right - left + 1;
  int array[size];

  // When left &amp;lt;= i &amp;lt;= div and div + 1 &amp;lt;= j &amp;lt;= right:
  // Compare list[i] and list[j], if list[i] &amp;lt; list[j], then copy list[i] into
  // the new array and let i = i + 1. Otherwise, copy list[j] into the new array
  // and let j = j + 1. If i &amp;gt; div, it means list[left...div] is all compared
  // and already copied, so we just need to put the rest list[j...right] into
  // the array. In the same way, if j &amp;gt; right, then put the rest list[i...div]
  // into the array.
  unsigned int k = 0;
  for (k = 0 ; k &amp;lt; size; ++k) {
    array[k] = (j &amp;gt; right || (i &amp;lt;= division &amp;amp;&amp;amp; list[i] &amp;lt; list[j])) ? list[i++] : list[j++];
  }

  // while (i &amp;lt;= division &amp;amp;&amp;amp; j &amp;lt;= right) {
  //   array[k++] = (list[i] &amp;lt; list[j]) ? list[i++] : list[j++];
  //   // if (list[i] &amp;lt; list[j]) {
  //   //   array[k] = list[i];
  //   //   ++i;
  //   // } else {
  //   //   array[k] = list[j];
  //   //   ++j;
  //   // }
  //   // ++k;
  // }
  //
  // // In this case, j &amp;gt; right, so we put the rest list[i...div] into the array.
  // while (i &amp;lt;= division) {
  //   array[k++] = list[i++];
  //   // array[k] = list[i];
  //   // ++i;
  //   // ++k;
  // }
  //
  // // in this case, i &amp;gt; div, so we put the rest list[j...right] into the array.
  // while (j &amp;lt;= right) {
  //   array[k++] = list[j++];
  //   // array[k] = list[j];
  //   // ++j;
  //   // ++k;
  // }

  assert(k == size);
  assert(i == division + 1);
  assert(j == right + 1);

  // Overwrite list[left...right] by the new sorted array.
  for (k = 0 ; k &amp;lt; size ; ++k) {
    list[left + k] = array[k];
  }
  assert(left + k == right + 1);
}

// Append ∞ as the last sentinel element to the both ordered arrays for merging.
void mergeWithSentinel(int list[], unsigned int left, unsigned int division, unsigned int right)
{
  assert(left &amp;lt;= right);
  //      |&amp;lt;-- sorted --&amp;gt;|&amp;lt;-- sorted --&amp;gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  //      |&amp;lt;---  A&amp;#39;  ---&amp;gt;|&amp;lt;---  B&amp;#39;  ---&amp;gt;|

  // Allocate list A = A&amp;#39; ∪ [INFINITY] and list B = B&amp;#39; ∪ [INFINITY]
  const static int INFINITY = ((unsigned int)(-1) &amp;gt;&amp;gt; 1);
  const unsigned int sizeA = division - left + 2; // (division - left + 1) + 1
  const unsigned int sizeB = right - division + 1; // (right - (division + 1) + 1) + 1
  int *A = new int[sizeA]; // 1 is for [ INFINITY ]
  int *B = new int[sizeB];
  // Copy elements from list[left...division] to A&amp;#39;[0...(sizeA - 2)].
  memcpy((void*)A, (void*)(list + left), sizeof(int) * (sizeA - 1));
  // Copy elements from list[(division + 1)...right] to B&amp;#39;[0...(sizeB - 2)].
  memcpy((void*)B, (void*)(list + division + 1), sizeof(int) * (sizeB - 1));
  // Set the last elements of A and B to INFINITY.
  A[sizeA - 1] = B[sizeB - 1] = INFINITY;
  // Move the sorted elements of A and B to list[left...right].
  unsigned int i, j;
  for (i = j = 0 ; left &amp;lt;= right ; ++left) {
    list[left] = A[i] &amp;lt; B[j] ? A[i++] : B[j++];
  }
  free(A);
  free(B);
}

// The following method demonstrates a in-place version of merge method.
// However, it downgrades mergesort overall performance to quadratic O(n^2)!
// Naive in-place merge: O(n^2)
void naiveInplaceMerge(int list[],
           const unsigned int left,
           const unsigned int division,
           const unsigned int right)
{
  assert(left &amp;lt;= right);
  //      |&amp;lt;-- sorted --&amp;gt;|&amp;lt;-- sorted --&amp;gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  unsigned int anchor = left;
  for (unsigned int i = division + 1 ; i &amp;lt;= right ; ++i) {
    for (unsigned int j = i ; j &amp;gt; anchor ; --j) { // Replace anchor with left is fine.
      // The following condition is definitely true and will be triggered.
      // list[division + k + 1] &amp;gt;= list[division + k] where k &amp;gt;= 1
      // is assertive because list[division + 1 .... right] is a sorted from
      // minimal item to maximal one.
      if (list[j] &amp;gt;= list[j-1]) {
        anchor = j;
        break;
      }
      std::swap(list[j], list[j-1]);
    }
  }
}

void topDownMergeSort(int list[], const unsigned int left, const unsigned int right)
{
  if (left &amp;gt;= right) {
    return;
  }

  const unsigned int middle = (left + right) / 2;
  topDownMergeSort(list, left, middle);
  topDownMergeSort(list, middle + 1, right);
  merge(list, left, middle, right);
  // mergeWithSentinel(list, left, middle, right);
  // naiveInplaceMerge(list, left, middle, right); // Slower!
}

void bottomUpMergeSort(int list[], const unsigned int length)
{
  // &amp;lt;----------  l = 2^k + r  ----------&amp;gt;  where k, r are integers, k &amp;gt;= 0,
  // &amp;lt;-----  2^k  -----&amp;gt;|&amp;lt;-----  r  -----&amp;gt;  and 0 &amp;lt;= r &amp;lt; 2^k.
  // +---+---+---------+---+---------+---+
  // | 0 | 1 | ....... | n | ....... | m |
  // +---+---+---------+---+---------+---+
  //
  // l            k  r
  // 1 : 2^0 + 0  0  0
  // 2 : 2^1 + 0  1  0
  // 3 : 2^1 + 1  1  1
  // 4 : 2^2 + 0  2  0
  // 5 : 2^2 + 1  2  1
  // 6 : 2^2 + 2  2  2
  // 7 : 2^2 + 3  2  3
  // 8 : 2^3 + 0  3  0
  // 9 : 2^3 + 1  3  1
  // ...
  // ...
  //
  // When r = 0:  The length of list is powers of 2, denoted 2^k, so all the
  //              size of blocks for merging must be same. At the round (k+1),
  //              the size is 2^k, where k &amp;gt;= 0 is a integer.
  // When r != 0: We can consider there are extra &amp;#39;r&amp;#39; elements added into the
  //              above list whose length is powers of 2.
  //              The extra &amp;#39;r&amp;#39; elements will be merged when the block size is
  //              grown to 2^k, where k &amp;gt;= 0 and 0 &amp;lt; r &amp;lt; 2^k.
  //
  // Each round, the list is divided into blocks and then merged
  // from size 1, 2, 4, ... to lenght/2.
  for (unsigned int size = 1 ; size &amp;lt; length ; size *= 2) {
    // If i &amp;gt;= length - size, then the rest elements list[i .. length - 1]
    // is smaller than or equal to one block size, so there is nothing to be
    // merged. These rest elements will be merged when size = 2^k
    // and 2^(k-1) &amp;lt; length - 2^k &amp;lt; 2^k,.
    for (unsigned int i = 0 ; i &amp;lt; length - size ; i += 2 * size) {
      // Merge the adjacent two blocks.
      merge(list, i, i + size - 1, std::min(i + 2 * size - 1, length - 1));
      // mergeWithSentinel(list, i, i + size - 1, min(i + 2 * size - 1, length - 1));
      // naiveInplaceMerge(list, i, i + size - 1, min(i + 2 * size - 1, length - 1)); // Slower!

      // Uncomment below to check when the rest items will be merged.
      // if ((size/2 &amp;lt; length - size/2) &amp;amp;&amp;amp; (length - size &amp;lt; size)) {
      //   std::cout &amp;lt;&amp;lt; &amp;quot;List length: &amp;quot; &amp;lt;&amp;lt; length &amp;lt;&amp;lt; std::endl;
      //   std::cout &amp;lt;&amp;lt; &amp;quot;Merge the last &amp;quot; &amp;lt;&amp;lt; length - size &amp;lt;&amp;lt;
      //                &amp;quot; items when size is &amp;quot; &amp;lt;&amp;lt; size &amp;lt;&amp;lt; std::endl;
      //   assert(min(i + 2 * size - 1, length - 1) == length - 1);
      // }
    }
  }
}

void mergeSort(int list[], const unsigned int length)
{
  assert(length);

  // topDownMergeSort(list, 0, length - 1);
  bottomUpMergeSort(list, length);
}



Appendix

Correctness of naive in-place merge



Proof by mathematical induction

Lemma 1


  Given a sorted list  with  elements,
where ,
and one value ,
the list 
( is appended to the end of list ),
can be sorted by the naive in-place merge method with .



  Base step: When , list  is trivially true
  Induction Hypothesis: Suppose this assumption holds when 
  Induction Step: When 
    
      If , then the  is naturally sorted
      Otherwise,  and the  and  are swapped.
        
          Now 
          By the hypothesis, the naive in-place merge works when , so we can a sorted 
          Thus, the list  now is sorted since  is sorted
and all its elements are smaller than the current th element 
        
      
    
  


Lemma 2


  Given a sorted list  with  elements
where ,
and  with  elements
where ,
the list 
can be sorted by the above naive in-place merge method with .



  Base step: When , the condition is same as Lemma 1, so it’s true
  Induction Hypothesis: Suppose this assumption holds when 
  Induction Step: When 
    
      When 
        
          the element  will be merged with 
          then the list  is sorted by Lemma 1
        
      
      When 
        
          the list is composed by sorted sublists 
and  with  elements
          By the hypothesis, the naive in-place merge works when 
          Thus, the list  is sorted
        
      
    
  


Reference

  CS104
  COS226
  COMP250
  DSA1112
  CSC282</summary></entry><entry><title type="html">Bubble Sort</title><link href="http://localhost:4000/post/bubble-sort" rel="alternate" type="text/html" title="Bubble Sort" /><published>2017-01-01T00:00:00+08:00</published><updated>2017-01-01T00:00:00+08:00</updated><id>http://localhost:4000/post/bubble-sort</id><content type="html" xml:base="http://localhost:4000/post/bubble-sort">&lt;h1 id=&quot;bubble-sort&quot;&gt;Bubble Sort&lt;/h1&gt;

&lt;p&gt;This post series is synchronized with my book &lt;a href=&quot;https://www.gitbook.com/book/chunminchang/codeplay/details&quot; title=&quot;CodePlay&quot;&gt;CodePlay&lt;/a&gt;
and this post could be read &lt;a href=&quot;https://chunminchang.gitbooks.io/codeplay/content/sorting/bubble_sort.html&quot; title=&quot;Bubble Sort&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;idea&quot;&gt;Idea&lt;/h2&gt;
&lt;p&gt;The basic concept is same to &lt;a href=&quot;https://chunminchang.gitbooks.io/codeplay/content/sorting/selection_sort.html&quot; title=&quot;Selection Sort&quot;&gt;&lt;em&gt;Selection Sort&lt;/em&gt;&lt;/a&gt;.
The list is rearranged from minimal to maximal value
by picking the maximal(or minimal) value from the unsorted list iteratively.&lt;/p&gt;

&lt;p&gt;In &lt;em&gt;selection sort&lt;/em&gt;, the minimal element is selected after searching whole list.
On the other hand, &lt;em&gt;bubble sort&lt;/em&gt; iteratively compares two neighbor elements
and swaps the elements if the left element is greater(or less) than
the right one, from the list head to the list tail.
Therefore, the maximal, the second-maximal, … values will be
“bubbled” up to the tail of list one by one.&lt;/p&gt;

&lt;p&gt;Take &lt;script type=&quot;math/tex&quot;&gt;L = [ 5, 3, 4, 2, 1 ]&lt;/script&gt; as an example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Step 1: Move the &lt;strong&gt;maximal&lt;/strong&gt; value to the &lt;strong&gt;last&lt;/strong&gt; position of the list.
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;5 &gt; 3&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 3, 5, 4, 2, 1 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;5 &gt; 4&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 3, 4, 5, 2, 1 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;5 &gt; 2&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 3, 4, 2, 5, 1 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;5 &gt; 1&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 3, 4, 2, 1, 5 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The maximal value &lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt; is moved to the last of the list&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 2: Move the &lt;strong&gt;second-maximal&lt;/strong&gt; value to the &lt;strong&gt;second-last&lt;/strong&gt; position of the list.
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
3 &lt; 4 %]]&gt;&lt;/script&gt; so do nothing.&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;4 &gt; 2&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 3, 2, 4, 1, 5 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;4 &gt; 1&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 3, 2, 1, 4, 5 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The second-maximal value &lt;script type=&quot;math/tex&quot;&gt;4&lt;/script&gt; is moved to the second-last of the list&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 3: Move the &lt;strong&gt;third-maximal&lt;/strong&gt; value to the &lt;strong&gt;third-last&lt;/strong&gt; position of the list.
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;3 &gt; 2&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 2, 3, 1, 4, 5 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;3 &gt; 1&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 2, 1, 3, 4, 5 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The third-maximal value &lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt; is moved to the third-last of the list&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 4: Move the &lt;strong&gt;fourth-maximal&lt;/strong&gt; value to the &lt;strong&gt;fourth-last&lt;/strong&gt; position of the list.
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;2 &gt; 1&lt;/script&gt; so swap them. &lt;script type=&quot;math/tex&quot;&gt;L = [ 1, 2, 3, 4, 5 ]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The fourth-maximal value &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; is moved to the fourth-last of the list&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dividing-one-list-into-unsorted-list-and-sorted-list&quot;&gt;Dividing one list into unsorted list and sorted list&lt;/h3&gt;

&lt;p&gt;In above example, the list is naturally partition into the sorted part
and the unsorted part.
The part contains the “bubbled” elements are sorted.
The others are unsorted.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Step 1: Move the &lt;strong&gt;maximal&lt;/strong&gt; value to the &lt;strong&gt;last&lt;/strong&gt; position of the list.
    &lt;ul&gt;
      &lt;li&gt;This iteration ends after the comparison of last two elements(&lt;em&gt;4th&lt;/em&gt; and &lt;em&gt;5th&lt;/em&gt;)&lt;/li&gt;
      &lt;li&gt;The maximal value &lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt; is “bubbled” to the last(&lt;em&gt;5th&lt;/em&gt;) of the list&lt;/li&gt;
      &lt;li&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;L = [ 3, 2, 4, 1, | 5 ]&lt;/script&gt;
      &lt;/li&gt;
      &lt;li&gt;The &lt;em&gt;5th&lt;/em&gt; element is sorted part and the &lt;em&gt;1st-to-4th&lt;/em&gt; is unsorted part&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 2: Move the &lt;strong&gt;second-maximal&lt;/strong&gt; value to the &lt;strong&gt;second-last&lt;/strong&gt; position of the list.
    &lt;ul&gt;
      &lt;li&gt;This iteration ends after the comparison of second-last two elements(&lt;em&gt;3rd&lt;/em&gt; and &lt;em&gt;4th&lt;/em&gt;)&lt;/li&gt;
      &lt;li&gt;The second-maximal value &lt;script type=&quot;math/tex&quot;&gt;4&lt;/script&gt; is “bubbled” to the second-last(&lt;em&gt;4th&lt;/em&gt;) of the list&lt;/li&gt;
      &lt;li&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;L = [ 3, 2, 1, | 4, 5 ]&lt;/script&gt;
      &lt;/li&gt;
      &lt;li&gt;The &lt;em&gt;4th-to-5th&lt;/em&gt; elements is sorted part and the &lt;em&gt;1st-to-3rd&lt;/em&gt; is unsorted part&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 3: Move the &lt;strong&gt;third-maximal&lt;/strong&gt; value to the &lt;strong&gt;third-last&lt;/strong&gt; position of the list.
    &lt;ul&gt;
      &lt;li&gt;This iteration ends after the comparison of third-last two elements(&lt;em&gt;2nd&lt;/em&gt; and &lt;em&gt;3rd&lt;/em&gt;)&lt;/li&gt;
      &lt;li&gt;The third-maximal value &lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt; is “bubbled” to the third-last(&lt;em&gt;3rd&lt;/em&gt;) of the list&lt;/li&gt;
      &lt;li&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;L = [ 2, 1, | 3, 4, 5 ]&lt;/script&gt;
      &lt;/li&gt;
      &lt;li&gt;The &lt;em&gt;3rd-to-5th&lt;/em&gt; elements is sorted part and the &lt;em&gt;1st-to-2nd&lt;/em&gt; is unsorted part&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 4: Move the &lt;strong&gt;fourth-maximal&lt;/strong&gt; value to the &lt;strong&gt;fourth-last&lt;/strong&gt; position of the list.
    &lt;ul&gt;
      &lt;li&gt;This iteration ends after the comparison of fourth-last two elements(&lt;em&gt;1st&lt;/em&gt; and &lt;em&gt;2nd&lt;/em&gt;)&lt;/li&gt;
      &lt;li&gt;The fourth-maximal value &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; is “bubbled” to the fourth-last(&lt;em&gt;2nd&lt;/em&gt;) of the list&lt;/li&gt;
      &lt;li&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;L = [ 1, | 2, 3, 4, 5 ]&lt;/script&gt;
      &lt;/li&gt;
      &lt;li&gt;The &lt;em&gt;2nd-to-5th&lt;/em&gt; elements is sorted part and the &lt;em&gt;1st&lt;/em&gt; is unsorted part&lt;/li&gt;
      &lt;li&gt;The last left element is definitely the &lt;strong&gt;smallest&lt;/strong&gt; value&lt;/li&gt;
      &lt;li&gt;so whole list from &lt;em&gt;1st&lt;/em&gt; to &lt;em&gt;5th&lt;/em&gt; is sorted&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;algorithm&quot;&gt;Algorithm&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{BubbleSort($L$):} \\
&amp; \space \space \space \space \text{for $i \leftarrow 1$ to $\vert L \vert - 1$:} \\
&amp; \space \space \space \space \space \space \space \space \text{for $j \leftarrow 1$ to $\vert L \vert - i$:} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{if $L[j] &gt; L[j+1]$:} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \text{swap $L[j]$ and $L[j+1]$} \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;At the 1st round, the 1st-last element is sorted&lt;/li&gt;
  &lt;li&gt;At the 2nd round, the 2nd-last to 1st-last elements are sorted&lt;/li&gt;
  &lt;li&gt;At the 3rd round, the 3rd-last to 1st-last elements are sorted&lt;/li&gt;
  &lt;li&gt;At the &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; round, the &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;-last to 1st-last elements are sorted&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;/h3&gt;

&lt;h4 id=&quot;proof-by-mathematical-induction&quot;&gt;Proof by mathematical induction&lt;/h4&gt;

&lt;h5 id=&quot;lemma-1&quot;&gt;Lemma 1&lt;/h5&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{for $j \leftarrow 1$ to $\vert L \vert - 1$:} \\
&amp; \space \space \space \space \text{if $L[j] &gt; L[j+1]$:} \\
&amp; \space \space \space \space \space \space \space \space \text{swap $L[j]$ and $L[j+1]$} \\
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; elements, where &lt;script type=&quot;math/tex&quot;&gt;N = \vert L \vert &gt; 0&lt;/script&gt;,
the maximal element of &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; will be &lt;script type=&quot;math/tex&quot;&gt;L[N]&lt;/script&gt;(the last element).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Base step: When &lt;script type=&quot;math/tex&quot;&gt;N = 1&lt;/script&gt;, the assumption obviously holds&lt;/li&gt;
  &lt;li&gt;Induction Hypothesis: Assume the hypothesis holds when &lt;script type=&quot;math/tex&quot;&gt;N = k(j \leftarrow 1 \text{ to } k-1)&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;Induction Step: when &lt;script type=&quot;math/tex&quot;&gt;N = k + 1&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;After the iteration of &lt;script type=&quot;math/tex&quot;&gt;j = k - 1&lt;/script&gt;,
the list is divided into two parts: &lt;script type=&quot;math/tex&quot;&gt;L[1...k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[k+1]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;From above hypothesis, the maximal value in &lt;script type=&quot;math/tex&quot;&gt;L[1...k]&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;L[k]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;When &lt;script type=&quot;math/tex&quot;&gt;j = k&lt;/script&gt;:
        &lt;ul&gt;
          &lt;li&gt;if &lt;script type=&quot;math/tex&quot;&gt;L[k] \leq L[k+1]&lt;/script&gt;, then the maximal element is &lt;script type=&quot;math/tex&quot;&gt;L[k+1]&lt;/script&gt;,
so the hypothesis still holds&lt;/li&gt;
          &lt;li&gt;if &lt;script type=&quot;math/tex&quot;&gt;L[k] &gt; L[k+1]&lt;/script&gt;, they will be swapped.
After then, the maximal element will be &lt;script type=&quot;math/tex&quot;&gt;L[k+1]&lt;/script&gt;,
so the hypothesis still holds&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;lemma-2&quot;&gt;Lemma 2&lt;/h5&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{for $i \leftarrow 1$ to $\vert L \vert - 1$:} \\
&amp; \space \space \space \space \text{for $j \leftarrow 1$ to $\vert L \vert - i$:} \\
&amp; \space \space \space \space \space \space \space \space \text{if $L[j] &gt; L[j+1]$:} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{swap $L[j]$ and $L[j+1]$} \\
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;After the &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; iteration,
&lt;script type=&quot;math/tex&quot;&gt;L[N - i + 1]&lt;/script&gt; will be the &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;th largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Base step: When &lt;script type=&quot;math/tex&quot;&gt;i = 1&lt;/script&gt;, the assumption holds because &lt;em&gt;lemma 1&lt;/em&gt; is true&lt;/li&gt;
  &lt;li&gt;Induction Hypothesis: Assume hypothesis holds when &lt;script type=&quot;math/tex&quot;&gt;i = k&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;Induction Step: When &lt;script type=&quot;math/tex&quot;&gt;i = k + 1&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;The goal is to prove that the &lt;script type=&quot;math/tex&quot;&gt;L[N - k]&lt;/script&gt; is
the &lt;script type=&quot;math/tex&quot;&gt;(k + 1)&lt;/script&gt;th largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;After the iteration &lt;script type=&quot;math/tex&quot;&gt;i = k&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[N-k+1]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;th
largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;We can divide the list into &lt;script type=&quot;math/tex&quot;&gt;L[1...N-k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[N-k+1...N]&lt;/script&gt;
        &lt;ul&gt;
          &lt;li&gt;The list &lt;script type=&quot;math/tex&quot;&gt;L[N-k+1...N]&lt;/script&gt; contains the picked
&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;th, &lt;script type=&quot;math/tex&quot;&gt;(k-1)&lt;/script&gt;th, …. , &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;st largest elements&lt;/li&gt;
          &lt;li&gt;The list &lt;script type=&quot;math/tex&quot;&gt;L[1...N-k]&lt;/script&gt; is the unselected and unsorted list&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;By applying the &lt;em&gt;lemma 1&lt;/em&gt; to &lt;script type=&quot;math/tex&quot;&gt;L[1...N-k]&lt;/script&gt;,
the maximal element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N-k]&lt;/script&gt; will be &lt;script type=&quot;math/tex&quot;&gt;L[N-k]&lt;/script&gt;
after all the iterations for &lt;script type=&quot;math/tex&quot;&gt;1 \leq j \leq N - k&lt;/script&gt;.&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L[N-k]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;(k+1)&lt;/script&gt;th selected maximal element&lt;/li&gt;
      &lt;li&gt;so &lt;script type=&quot;math/tex&quot;&gt;L[N - (k+1) + 1] = L[N-k]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;(k+1)&lt;/script&gt;th largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h5&gt;

&lt;p&gt;By &lt;em&gt;lemma 2&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;After &lt;script type=&quot;math/tex&quot;&gt;i = 1&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[N]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;st largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;After &lt;script type=&quot;math/tex&quot;&gt;i = 2&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[N - 1]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;nd largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;After &lt;script type=&quot;math/tex&quot;&gt;i = 3&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[N - 2]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt;rd largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;After &lt;script type=&quot;math/tex&quot;&gt;i = k&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[N - k + 1]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;th largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;After &lt;script type=&quot;math/tex&quot;&gt;i = k+1&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[N - k]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;(k+1)&lt;/script&gt;th largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;After &lt;script type=&quot;math/tex&quot;&gt;i = N-2&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[3]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;N-2&lt;/script&gt;th largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;After &lt;script type=&quot;math/tex&quot;&gt;i = N-1&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[2]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;N-1&lt;/script&gt;th largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;After &lt;script type=&quot;math/tex&quot;&gt;i = N&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;L[1]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;th largest element of &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thus, the list $L[1…N]$ is sorted by the order that &lt;script type=&quot;math/tex&quot;&gt;L[1] \leq L[2] \leq L[3] \leq ... \leq L[N-1] \leq L[N]&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;complexity&quot;&gt;Complexity&lt;/h2&gt;

&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;N = \vert L \vert&lt;/script&gt; denote the length of list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;iterations for &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;j \in [1, N-1]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;j \in [1, N-2]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;N-2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;j \in [1, 2]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;N-1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;j = 1&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The total of all iterations of &lt;em&gt;BubbleSort(&lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;)&lt;/em&gt; is tracked in above table
and its sum is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
(N - 1) + (N - 2) + ... + 2 + 1
&amp;= \frac{ N \cdot (N - 1) }{ 2 } \\
&amp;= \frac{ 1 }{ 2 } \cdot N^2 - \frac{ 1 }{ 2 } N
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, the complexity is &lt;script type=&quot;math/tex&quot;&gt;\mathcal{O}(N^2)&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;See the files on &lt;a href=&quot;https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb&quot; title=&quot;Sorting&quot;&gt;gist here&lt;/a&gt;.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;algorithm&amp;gt;  // for std::swap
#include &amp;lt;cassert&amp;gt;
#include &amp;quot;sorting.h&amp;quot;

/*
 * Bubble sort: O(n^2)
 */
void bubbleSort(int list[], const unsigned int length)
{
  assert(length);

  // &amp;lt;--  unsorted  --&amp;gt;|&amp;lt;--  sorted  --&amp;gt;
  // +---+---+---------+---+-------+---+
  // | 0 | 1 | ....... | m | ..... | M |
  // +---+---+---------+---+---+---+---+
  //                     ^           ^
  //              current min        Max
  for (unsigned int i = 0 ; i &amp;lt; length - 1 ; ++i) {
    for (unsigned int j = 0 ; j &amp;lt; length - 1 - i ; ++j) {
      if (list[j] &amp;gt; list[j+1]) {
        std::swap(list[j], list[j+1]);
      }
    }
  }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=bubble_sort.cpp&quot;&gt; &lt;/script&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Algorithm" /><category term="Sorting" /><summary type="html">Bubble Sort

This post series is synchronized with my book CodePlay
and this post could be read here.

Idea
The basic concept is same to Selection Sort.
The list is rearranged from minimal to maximal value
by picking the maximal(or minimal) value from the unsorted list iteratively.

In selection sort, the minimal element is selected after searching whole list.
On the other hand, bubble sort iteratively compares two neighbor elements
and swaps the elements if the left element is greater(or less) than
the right one, from the list head to the list tail.
Therefore, the maximal, the second-maximal, … values will be
“bubbled” up to the tail of list one by one.

Take  as an example:


  Step 1: Move the maximal value to the last position of the list.
    
       so swap them. 
       so swap them. 
       so swap them. 
       so swap them. 
      The maximal value  is moved to the last of the list
    
  
  Step 2: Move the second-maximal value to the second-last position of the list.
    
       so do nothing.
       so swap them. 
       so swap them. 
      The second-maximal value  is moved to the second-last of the list
    
  
  Step 3: Move the third-maximal value to the third-last position of the list.
    
       so swap them. 
       so swap them. 
      The third-maximal value  is moved to the third-last of the list
    
  
  Step 4: Move the fourth-maximal value to the fourth-last position of the list.
    
       so swap them. 
      The fourth-maximal value  is moved to the fourth-last of the list
    
  


Dividing one list into unsorted list and sorted list

In above example, the list is naturally partition into the sorted part
and the unsorted part.
The part contains the “bubbled” elements are sorted.
The others are unsorted.


  Step 1: Move the maximal value to the last position of the list.
    
      This iteration ends after the comparison of last two elements(4th and 5th)
      The maximal value  is “bubbled” to the last(5th) of the list
      
        
      
      The 5th element is sorted part and the 1st-to-4th is unsorted part
    
  
  Step 2: Move the second-maximal value to the second-last position of the list.
    
      This iteration ends after the comparison of second-last two elements(3rd and 4th)
      The second-maximal value  is “bubbled” to the second-last(4th) of the list
      
        
      
      The 4th-to-5th elements is sorted part and the 1st-to-3rd is unsorted part
    
  
  Step 3: Move the third-maximal value to the third-last position of the list.
    
      This iteration ends after the comparison of third-last two elements(2nd and 3rd)
      The third-maximal value  is “bubbled” to the third-last(3rd) of the list
      
        
      
      The 3rd-to-5th elements is sorted part and the 1st-to-2nd is unsorted part
    
  
  Step 4: Move the fourth-maximal value to the fourth-last position of the list.
    
      This iteration ends after the comparison of fourth-last two elements(1st and 2nd)
      The fourth-maximal value  is “bubbled” to the fourth-last(2nd) of the list
      
        
      
      The 2nd-to-5th elements is sorted part and the 1st is unsorted part
      The last left element is definitely the smallest value
      so whole list from 1st to 5th is sorted
    
  


Algorithm




  At the 1st round, the 1st-last element is sorted
  At the 2nd round, the 2nd-last to 1st-last elements are sorted
  At the 3rd round, the 3rd-last to 1st-last elements are sorted
  At the  round, the -last to 1st-last elements are sorted


Proof

Proof by mathematical induction

Lemma 1



  Given a list  with  elements, where ,
the maximal element of  will be (the last element).



  Base step: When , the assumption obviously holds
  Induction Hypothesis: Assume the hypothesis holds when 
  Induction Step: when 
    
      After the iteration of ,
the list is divided into two parts:  and 
      From above hypothesis, the maximal value in  is 
      When :
        
          if , then the maximal element is ,
so the hypothesis still holds
          if , they will be swapped.
After then, the maximal element will be ,
so the hypothesis still holds
        
      
    
  


Lemma 2



  After the  iteration,
 will be the th largest element of 



  Base step: When , the assumption holds because lemma 1 is true
  Induction Hypothesis: Assume hypothesis holds when 
  Induction Step: When 
    
      The goal is to prove that the  is
the th largest element of 
      After the iteration ,  is the th
largest element of 
      We can divide the list into  and 
        
          The list  contains the picked
th, th, …. , st largest elements
          The list  is the unselected and unsorted list
        
      
      By applying the lemma 1 to ,
the maximal element of  will be 
after all the iterations for .
       is the th selected maximal element
      so  is the th largest element of 
    
  


Conclusion

By lemma 2


  After ,  is the st largest element of 
  After ,  is the nd largest element of 
  After ,  is the rd largest element of 
  …
  After ,  is the th largest element of 
  After ,  is the th largest element of 
  …
  After ,  is the th largest element of 
  After ,  is the th largest element of 
  After ,  is the th largest element of 


Thus, the list $L[1…N]$ is sorted by the order that .

Complexity

Let  denote the length of list .


  
    
      
      iterations for 
    
  
  
    
      
      
    
    
      
      
    
    
      …
      …
    
    
      
      
    
    
      
      
    
  


The total of all iterations of BubbleSort() is tracked in above table
and its sum is:



Thus, the complexity is .

Implementation

See the files on gist here.

#include &amp;lt;algorithm&amp;gt;  // for std::swap
#include &amp;lt;cassert&amp;gt;
#include &amp;quot;sorting.h&amp;quot;

/*
 * Bubble sort: O(n^2)
 */
void bubbleSort(int list[], const unsigned int length)
{
  assert(length);

  // &amp;lt;--  unsorted  --&amp;gt;|&amp;lt;--  sorted  --&amp;gt;
  // +---+---+---------+---+-------+---+
  // | 0 | 1 | ....... | m | ..... | M |
  // +---+---+---------+---+---+---+---+
  //                     ^           ^
  //              current min        Max
  for (unsigned int i = 0 ; i &amp;lt; length - 1 ; ++i) {
    for (unsigned int j = 0 ; j &amp;lt; length - 1 - i ; ++j) {
      if (list[j] &amp;gt; list[j+1]) {
        std::swap(list[j], list[j+1]);
      }
    }
  }
}</summary></entry><entry><title type="html">Insertion Sort</title><link href="http://localhost:4000/post/insertion-sort" rel="alternate" type="text/html" title="Insertion Sort" /><published>2016-12-30T00:00:00+08:00</published><updated>2016-12-30T00:00:00+08:00</updated><id>http://localhost:4000/post/insertion-sort</id><content type="html" xml:base="http://localhost:4000/post/insertion-sort">&lt;h1 id=&quot;insertion-sort&quot;&gt;Insertion sort&lt;/h1&gt;

&lt;p&gt;This post series is synchronized with my book &lt;a href=&quot;https://www.gitbook.com/book/chunminchang/codeplay/details&quot; title=&quot;CodePlay&quot;&gt;CodePlay&lt;/a&gt;
and this post could be read &lt;a href=&quot;https://chunminchang.gitbooks.io/codeplay/content/sorting/insertion_sort.html&quot; title=&quot;Insertion Sort&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;idea&quot;&gt;Idea&lt;/h2&gt;
&lt;p&gt;The basic concept is similar to &lt;a href=&quot;https://chunminchang.gitbooks.io/codeplay/content/sorting/selection_sort.html&quot; title=&quot;Selection Sort&quot;&gt;&lt;em&gt;Selection Sort&lt;/em&gt;&lt;/a&gt;.
Considering there are two lists. One is already sorted,
and the other is unsorted, denoted &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; respectively.
The key idea is to pick the element from &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; one by one
and then &lt;strong&gt;insert&lt;/strong&gt; them into the correct positions of &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;.
Suppose we have &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = [3, 8, 34]&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = [23, 2, 67, 34, 97]&lt;/script&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Step 1
    &lt;ul&gt;
      &lt;li&gt;Pick &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt; (which is the first element) from &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt;,
and insert it into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Find a position in &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; such that
&lt;strong&gt;all elements before it is less than or equal to &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt;
and all elements after it is greater than &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Start comparing it from the &lt;strong&gt;last(maximal)&lt;/strong&gt; element
to the &lt;strong&gt;first(minimal)&lt;/strong&gt; one in &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;
(Or you can do same thing from the first element to the last one)&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt; is greater than &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt;, so we keep moving&lt;/li&gt;
      &lt;li&gt;Next, we found that &lt;script type=&quot;math/tex&quot;&gt;8&lt;/script&gt; is less than &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;A-ha! &lt;script type=&quot;math/tex&quot;&gt;23&lt;/script&gt; should be inserted between &lt;script type=&quot;math/tex&quot;&gt;8&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; are updated to &lt;script type=&quot;math/tex&quot;&gt;[3, 8, 23, 34]&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;[2, 67, 34, 97]&lt;/script&gt; respectively.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 2
    &lt;ul&gt;
      &lt;li&gt;Pick the current first element of &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;,
and insert it into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Same as the previous step, we start comparing &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; from the maximal element
of &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; to find the position to insert&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt; is obviously larger than &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;, so we should keep moving&lt;/li&gt;
      &lt;li&gt;In this step, we can not find any element less than or equal to &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; after
the all elements in &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; are checked&lt;/li&gt;
      &lt;li&gt;Thus, the &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; is the minimal value among these elements&lt;/li&gt;
      &lt;li&gt;We should put &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt; as the first element in &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; are updated to &lt;script type=&quot;math/tex&quot;&gt;[2, 3, 8, 23, 34]&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;[67, 34, 97]&lt;/script&gt; respectively&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 3
    &lt;ul&gt;
      &lt;li&gt;pick the current first element of &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;67&lt;/script&gt;,
and then insert it into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Start comparing &lt;script type=&quot;math/tex&quot;&gt;67&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt;, we found &lt;script type=&quot;math/tex&quot;&gt;67&lt;/script&gt; is greater&lt;/li&gt;
      &lt;li&gt;It means that &lt;script type=&quot;math/tex&quot;&gt;67&lt;/script&gt; is the maximal value among these elements&lt;/li&gt;
      &lt;li&gt;Therefore, &lt;script type=&quot;math/tex&quot;&gt;67&lt;/script&gt; should be inserted at the last position of &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; are updated to
&lt;script type=&quot;math/tex&quot;&gt;[2, 3, 8, 23, 34, 67]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;[34, 97]&lt;/script&gt; respectively&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 4
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt; is picked to compare with the elements in &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;.&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;67&lt;/script&gt; is greater than &lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt;, so go next&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt; is equal to &lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt;, so we stop here&lt;/li&gt;
      &lt;li&gt;The picked &lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt; should be inserted between the existed &lt;script type=&quot;math/tex&quot;&gt;34&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;67&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;so the &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; are updated to
&lt;script type=&quot;math/tex&quot;&gt;[2, 3, 8, 23, 34, 34, 67]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;[97]&lt;/script&gt; respectively.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step 5
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;97&lt;/script&gt; is picked to insert.&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;97&lt;/script&gt; is greater than &lt;script type=&quot;math/tex&quot;&gt;67&lt;/script&gt;,&lt;/li&gt;
      &lt;li&gt;so it should be put to the last position of &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Finally, &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; is empty
and &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = [2, 3, 8, 23, 34, 34, 67, 97]&lt;/script&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;how-to-find-the-inserted-position&quot;&gt;How to find the inserted position&lt;/h3&gt;

&lt;p&gt;We can use the following method to find the &lt;strong&gt;first&lt;/strong&gt; element
whose value is &lt;strong&gt;less than or equal to&lt;/strong&gt; the picked element:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{Position($L, x$):} \\
&amp; \space \space \space \space i \leftarrow N\\
&amp; \space \space \space \space \text{while $i &gt; 0$ and $L[i] &gt; x$:} \\
&amp; \space \space \space \space \space \space \space \space i \leftarrow i - 1 \\
&amp; \space \space \space \space \text{return} \space i \\
\end{align} %]]&gt;&lt;/script&gt;
,where &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is the element needs to be inserted,
&lt;script type=&quot;math/tex&quot;&gt;L[i]&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;th element in the sorted list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;,
and &lt;script type=&quot;math/tex&quot;&gt;N = \vert L \vert&lt;/script&gt; is the length of &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;After getting the position &lt;script type=&quot;math/tex&quot;&gt;p = Position(L, x)&lt;/script&gt; given the element &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;,
we need to insert &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; between &lt;script type=&quot;math/tex&quot;&gt;L[p]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[p+1]&lt;/script&gt;.
(If &lt;script type=&quot;math/tex&quot;&gt;p = 0&lt;/script&gt;, then we insert &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; as the first element &lt;script type=&quot;math/tex&quot;&gt;L[1]&lt;/script&gt;.
If &lt;script type=&quot;math/tex&quot;&gt;p = N&lt;/script&gt;, then we insert &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; as the last element &lt;script type=&quot;math/tex&quot;&gt;L[p + 1]&lt;/script&gt;.)&lt;/p&gt;

&lt;h3 id=&quot;dividing-one-list-into-unsorted-list-and-sorted-list&quot;&gt;Dividing one list into unsorted list and sorted list&lt;/h3&gt;

&lt;p&gt;In implementation, we usually divide the source list &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; into two parts.
One is sorted, the other is unsorted.
They are denoted &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; respectively.
This is better for memory usage than
creating another list to put the sorted results.&lt;/p&gt;

&lt;p&gt;Suppose we have &lt;script type=&quot;math/tex&quot;&gt;L = [73, 24, 37, 9, 97, 29] = L_{sorted} \cup L_{unsorted}&lt;/script&gt;,
where &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; are initialized to &lt;script type=&quot;math/tex&quot;&gt;[]&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;[73, 24, 37, 9, 97, 29]&lt;/script&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;First round
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;73&lt;/script&gt; is picked, but there is nothing could be compared&lt;/li&gt;
      &lt;li&gt;so we just put it into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = [73]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = [24, 37, 9, 97, 29]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;now &lt;script type=&quot;math/tex&quot;&gt;L = L_{sorted} \cup L_{unsorted} = [73 \vert 24, 37, 9, 97, 29]&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Second round
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;24&lt;/script&gt; is picked and &lt;script type=&quot;math/tex&quot;&gt;p = Position(L_{sorted}, 24) = 0&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;so, we should insert &lt;script type=&quot;math/tex&quot;&gt;24&lt;/script&gt; as the &lt;strong&gt;first&lt;/strong&gt; element and update lists&lt;/li&gt;
      &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = [24, 73]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = [37, 9, 97, 29]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;now &lt;script type=&quot;math/tex&quot;&gt;L = L_{sorted} \cup L_{unsorted} = [24, 73 \vert 37, 9, 97, 29]&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Third round
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;37&lt;/script&gt; is picked and &lt;script type=&quot;math/tex&quot;&gt;p = Position(L_{sorted}, 37) = 1&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;so we should insert &lt;script type=&quot;math/tex&quot;&gt;37&lt;/script&gt; between &lt;script type=&quot;math/tex&quot;&gt;L[p] = L[1] = 24&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[p + 1] = L[2] = 73&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = [24, 37, 73]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = [9, 97, 29]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;now &lt;script type=&quot;math/tex&quot;&gt;L = L_{sorted} \cup L_{unsorted} = [24, 37, 73 \vert 9, 97, 29]&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fourth round
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;9&lt;/script&gt; is picked and &lt;script type=&quot;math/tex&quot;&gt;p = Position(L_{sorted}, 9) = 0&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Thus, &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}, L_{unsorted}&lt;/script&gt; are updated to
&lt;script type=&quot;math/tex&quot;&gt;[9, 24, 37, 73]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;[97, 29]&lt;/script&gt;.&lt;/li&gt;
      &lt;li&gt;now &lt;script type=&quot;math/tex&quot;&gt;L = L_{sorted} \cup L_{unsorted} = [9, 24, 37, 73 \vert 97, 29]&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fifth round
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;97&lt;/script&gt; is picked and &lt;script type=&quot;math/tex&quot;&gt;p = Position(L_{sorted}, 97) = 4 = \vert L_{sorted} \vert&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;so we should put &lt;script type=&quot;math/tex&quot;&gt;97&lt;/script&gt; as the &lt;strong&gt;last&lt;/strong&gt; element of the &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = [9, 24, 37, 73, 97]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = [29]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;now &lt;script type=&quot;math/tex&quot;&gt;L = L_{sorted} \cup L_{unsorted} = [9, 24, 37, 73, 97 \vert 29]&lt;/script&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Final round
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;29&lt;/script&gt; is picked and &lt;script type=&quot;math/tex&quot;&gt;p = Position(L_{sorted}, 29) = 2&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;so we should insert &lt;script type=&quot;math/tex&quot;&gt;29&lt;/script&gt; between &lt;script type=&quot;math/tex&quot;&gt;L[p] = L[2] = 24&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[p + 1] = L[3] = 37&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = [9, 24, 29, 37, 73, 97]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = []&lt;/script&gt; is empty&lt;/li&gt;
      &lt;li&gt;now &lt;script type=&quot;math/tex&quot;&gt;L = L_{sorted} \cup L_{unsorted} = [9, 24, 29, 37, 73, 97]&lt;/script&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;algorithm&quot;&gt;Algorithm&lt;/h2&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{InsertionSort($L$):} \\
&amp; \space \space \space \space \text{for $i \leftarrow 2$ to $\vert L \vert$:} \\
&amp; \space \space \space \space \space \space \space \space j \leftarrow i\\
&amp; \space \space \space \space \space \space \space \space \text{while $j &gt; 1$ and $L[j-1] &gt; L[j]$:} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{swap $L[j-1]$ and $L[j]$} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space j \leftarrow j - 1 \\
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;The above method will divide &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; into two parts.
&lt;script type=&quot;math/tex&quot;&gt;L[1...i-1] = L_{sorted}&lt;/script&gt; is sorted, and &lt;script type=&quot;math/tex&quot;&gt;L[i...N] = L_{unsorted}&lt;/script&gt; is unsorted,
where &lt;script type=&quot;math/tex&quot;&gt;N = \vert L \vert&lt;/script&gt; is the length of &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;.
The &lt;script type=&quot;math/tex&quot;&gt;L[i]&lt;/script&gt; will be picked to insert into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; iteratively.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When &lt;script type=&quot;math/tex&quot;&gt;i = 2&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = L[1]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = L[2...N]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The goal in this round is to insert the &lt;script type=&quot;math/tex&quot;&gt;L[2]&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The &lt;script type=&quot;math/tex&quot;&gt;L[2]&lt;/script&gt; is picked and compare with &lt;script type=&quot;math/tex&quot;&gt;L[1]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
L[2] &lt; L[1] %]]&gt;&lt;/script&gt;, then we swap them&lt;/li&gt;
      &lt;li&gt;Otherwise, do nothing&lt;/li&gt;
      &lt;li&gt;Then, &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = L[1...2]&lt;/script&gt; is sorted and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = L[3...N]&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;When &lt;script type=&quot;math/tex&quot;&gt;i = 3&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = L[1...2]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = L[3...N]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The goal in this round is to insert the &lt;script type=&quot;math/tex&quot;&gt;L[3]&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The &lt;script type=&quot;math/tex&quot;&gt;L[3]&lt;/script&gt; is picked&lt;/li&gt;
      &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;L[3] &gt;= L[2]&lt;/script&gt;, it means that &lt;script type=&quot;math/tex&quot;&gt;L[1...3]&lt;/script&gt; is sorted, so we don’t need to do anything&lt;/li&gt;
      &lt;li&gt;Otherwise(&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
L[3] &lt; L[2] %]]&gt;&lt;/script&gt;), swap &lt;script type=&quot;math/tex&quot;&gt;L[3]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L[2]&lt;/script&gt;
and check whether it needs to swap again if &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
L[2] &lt; L[1] %]]&gt;&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;After finishing checking, &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = L[1...3]&lt;/script&gt; is sorted
and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = L[4...N]&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;When &lt;script type=&quot;math/tex&quot;&gt;i = k&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = L[1...k-1]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = L[k...N]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The goal in this round is to insert the &lt;script type=&quot;math/tex&quot;&gt;L[k]&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The &lt;script type=&quot;math/tex&quot;&gt;L[k]&lt;/script&gt; is picked to compare with the elements one by one in &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;,
from the maximal(&lt;script type=&quot;math/tex&quot;&gt;L[k-1]&lt;/script&gt;) to minimal item(&lt;script type=&quot;math/tex&quot;&gt;L[1]&lt;/script&gt;), to find a place to insert&lt;/li&gt;
      &lt;li&gt;After finishing checking, &lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = L[1...k]&lt;/script&gt; is sorted
and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted}&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;L[k+1...N]&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;When &lt;script type=&quot;math/tex&quot;&gt;i = N&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L_{sorted} = L[1...N-1]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = L[N]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The goal in this round is to insert the &lt;script type=&quot;math/tex&quot;&gt;L[N]&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;In the same way, the &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt; is sorted after finishing the procedure&lt;/li&gt;
      &lt;li&gt;so &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; is updated to &lt;script type=&quot;math/tex&quot;&gt;L[1...N]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_{unsorted} = []&lt;/script&gt; is empty&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;another-method-without-swapping&quot;&gt;Another method without swapping&lt;/h3&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
&amp; \text{InsertionSort($L$):} \\
&amp; \space \space \space \space \text{for $i \leftarrow 2$ to $\vert L \vert$:} \\
&amp; \space \space \space \space \space \space \space \space c \leftarrow L[i] \\
&amp; \space \space \space \space \space \space \space \space j \leftarrow i \\
&amp; \space \space \space \space \space \space \space \space \text{while $j &gt; 1$ and $L[j-1] &gt; c$:} \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space L[j] = L[j-1] \\
&amp; \space \space \space \space \space \space \space \space \space \space \space \space j = j - 1 \\
&amp; \space \space \space \space \space \space \space \space L[j] = c \\
\end{align} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;/h3&gt;

&lt;h4 id=&quot;proof-by-mathematical-induction&quot;&gt;Proof by mathematical induction&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;After each iteration for &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;InsertionSort&lt;/script&gt;,
  the &lt;script type=&quot;math/tex&quot;&gt;L[1...i]&lt;/script&gt; is sorted array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We need to prove this statement is true.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;when &lt;script type=&quot;math/tex&quot;&gt;i = 2&lt;/script&gt;:
    &lt;ul&gt;
      &lt;li&gt;Same as the above explanation&lt;/li&gt;
      &lt;li&gt;The assumption is hold&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;when &lt;script type=&quot;math/tex&quot;&gt;i = k&lt;/script&gt;:
    &lt;ul&gt;
      &lt;li&gt;Assume the statement is hold when &lt;script type=&quot;math/tex&quot;&gt;i = k&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;L[1...k]&lt;/script&gt; is sorted array&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;when &lt;script type=&quot;math/tex&quot;&gt;i = k + 1&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;L[k + 1] &gt; L[k]&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;L[1...k + 1]&lt;/script&gt; is naturally sorted
so the proof is done&lt;/li&gt;
      &lt;li&gt;Otherwise, the &lt;script type=&quot;math/tex&quot;&gt;L[k + 1]&lt;/script&gt; is swapped with &lt;script type=&quot;math/tex&quot;&gt;L[k]&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Now &lt;script type=&quot;math/tex&quot;&gt;L[1...k-1]&lt;/script&gt; is sorted and &lt;script type=&quot;math/tex&quot;&gt;L[k + 1] &gt; L[k]&lt;/script&gt;(after swapping!)&lt;/li&gt;
      &lt;li&gt;Next, we apply this algorithm to &lt;script type=&quot;math/tex&quot;&gt;L = L[1...k-1] \cup L[k]&lt;/script&gt; and now &lt;script type=&quot;math/tex&quot;&gt;i = k&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;The statement is hold when &lt;script type=&quot;math/tex&quot;&gt;i = k&lt;/script&gt;,
so &lt;script type=&quot;math/tex&quot;&gt;L[1...k]&lt;/script&gt; is sorted after applying the algorithm&lt;/li&gt;
      &lt;li&gt;Now &lt;script type=&quot;math/tex&quot;&gt;L[1...k]&lt;/script&gt; is sorted and &lt;script type=&quot;math/tex&quot;&gt;L[k + 1] &gt; L[k]&lt;/script&gt;, so the proof is done&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;complexity&quot;&gt;Complexity&lt;/h2&gt;
&lt;p&gt;The time complexity depends on the speed to find the inserted position.
The more iterations to find the value of &lt;script type=&quot;math/tex&quot;&gt;Position(L, x)&lt;/script&gt; need,
the more time it takes.
The worst case is that we need to go through whole &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt; to find correct
positions to insert. It happens when the list is arranged from maximal to
minimal values(e.g.,&lt;script type=&quot;math/tex&quot;&gt;[5, 4, 3, 2, 1]&lt;/script&gt;).
In this case, if the length of list is &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;, we need to search
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{align}
0 + 1 + 2 + ... + (N - 1)
&amp;= \frac{ N \cdot (N - 1) }{ 2 } \\
&amp;= \frac{ 1 }{ 2 } \cdot N^2 - \frac{ 1 }{ 2 } N
\end{align} %]]&gt;&lt;/script&gt;
times to move all the items into &lt;script type=&quot;math/tex&quot;&gt;L_{sorted}&lt;/script&gt;.
Thus, the complexity is &lt;script type=&quot;math/tex&quot;&gt;\mathcal{O}(N^2)&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;See the files on &lt;a href=&quot;https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb&quot; title=&quot;Sorting&quot;&gt;gist here&lt;/a&gt;.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;algorithm&amp;gt;  // for std::swap
#include &amp;lt;cassert&amp;gt;
#include &amp;quot;sorting.h&amp;quot;

/*
 * Insertion sort: O(n^2)
 */
void insertionSort(int list[], const unsigned int length)
{
  assert(length);

  // &amp;lt;-- sorted --&amp;gt;|&amp;lt;-- unsorted --&amp;gt;
  // +---+-----+---+---------------+
  // | 0 | ... | t | ............  |
  // +---+-----+---+---------------+
  //             ^
  //       tail is the index of last item of sorted list.
  for (unsigned int tail = 1 ; tail &amp;lt; length; ++tail) { // list[0] is sorted!
    for (unsigned int j = tail; j &amp;gt; 0 &amp;amp;&amp;amp; list[j - 1] &amp;gt; list[j] ; --j) {
      std::swap(list[j], list[j - 1]);
    }
  }
}

// void insertionSort(int list[], const unsigned int length)
// {
//   assert(length);
//
//   for (unsigned int tail = 1 ; tail &amp;lt; length; ++tail) {
//     int current = list[tail];
//     unsigned int j = tail;
//     while(j &amp;gt; 0 &amp;amp;&amp;amp; list[j-1] &amp;gt; current) {
//       list[j] = list[j - 1];
//       --j;
//     }
//     list[j] = current;
//   }
// }
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=insertion_sort.cpp&quot;&gt; &lt;/script&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Algorithm" /><category term="Sorting" /><summary type="html">Insertion sort

This post series is synchronized with my book CodePlay
and this post could be read here.

Idea
The basic concept is similar to Selection Sort.
Considering there are two lists. One is already sorted,
and the other is unsorted, denoted  and  respectively.
The key idea is to pick the element from  one by one
and then insert them into the correct positions of .
Suppose we have 
and :


  Step 1
    
      Pick  (which is the first element) from ,
and insert it into 
      Find a position in  such that
all elements before it is less than or equal to 
and all elements after it is greater than 
      Start comparing it from the last(maximal) element
to the first(minimal) one in 
(Or you can do same thing from the first element to the last one)
       is greater than , so we keep moving
      Next, we found that  is less than 
      A-ha!  should be inserted between  and 
      The  and  are updated to 
and  respectively.
    
  
  Step 2
    
      Pick the current first element of , ,
and insert it into 
      Same as the previous step, we start comparing  from the maximal element
of  to find the position to insert
       is obviously larger than , so we should keep moving
      In this step, we can not find any element less than or equal to  after
the all elements in  are checked
      Thus, the  is the minimal value among these elements
      We should put  as the first element in 
      The  and  are updated to 
and  respectively
    
  
  Step 3
    
      pick the current first element of , ,
and then insert it into 
      Start comparing  with , we found  is greater
      It means that  is the maximal value among these elements
      Therefore,  should be inserted at the last position of 
      The  and  are updated to
 and  respectively
    
  
  Step 4
    
       is picked to compare with the elements in .
       is greater than , so go next
       is equal to , so we stop here
      The picked  should be inserted between the existed  and 
      so the  and  are updated to
 and  respectively.
    
  
  Step 5
    
       is picked to insert.
       is greater than ,
      so it should be put to the last position of 
      Finally,  is empty
and .
    
  


How to find the inserted position

We can use the following method to find the first element
whose value is less than or equal to the picked element:

,where  is the element needs to be inserted,
 is the th element in the sorted list ,
and  is the length of .

After getting the position  given the element ,
we need to insert  between  and .
(If , then we insert  as the first element .
If , then we insert  as the last element .)

Dividing one list into unsorted list and sorted list

In implementation, we usually divide the source list  into two parts.
One is sorted, the other is unsorted.
They are denoted  and  respectively.
This is better for memory usage than
creating another list to put the sorted results.

Suppose we have ,
where  and  are initialized to 
and .


  First round
    
       is picked, but there is nothing could be compared
      so we just put it into 
       and 
      now 
    
  
  Second round
    
       is picked and 
      so, we should insert  as the first element and update lists
      then  and 
      now 
    
  
  Third round
    
       is picked and 
      so we should insert  between  and 
      then  and 
      now 
    
  
  Fourth round
    
       is picked and 
      Thus,  are updated to
 and .
      now 
    
  
  Fifth round
    
       is picked and 
      so we should put  as the last element of the 
      then  and 
      now .
    
  
  Final round
    
       is picked and 
      so we should insert  between  and 
      then  and  is empty
      now .
    
  


Algorithm


The above method will divide  into two parts.
 is sorted, and  is unsorted,
where  is the length of .
The  will be picked to insert into  iteratively.


  When 
    
       and 
      The goal in this round is to insert the  into 
      The  is picked and compare with 
      If , then we swap them
      Otherwise, do nothing
      Then,  is sorted and 
    
  
  When 
    
       and 
      The goal in this round is to insert the  into 
      The  is picked
      If , it means that  is sorted, so we don’t need to do anything
      Otherwise(), swap  and 
and check whether it needs to swap again if 
      After finishing checking,  is sorted
and 
    
  
  When 
    
       and 
      The goal in this round is to insert the  into 
      The  is picked to compare with the elements one by one in ,
from the maximal() to minimal item(), to find a place to insert
      After finishing checking,  is sorted
and  is 
    
  
  When 
    
       and 
      The goal in this round is to insert the  into 
      In the same way, the  is sorted after finishing the procedure
      so  is updated to  and  is empty
    
  


Another method without swapping


Proof

Proof by mathematical induction


  After each iteration for  in ,
  the  is sorted array.


We need to prove this statement is true.


  when :
    
      Same as the above explanation
      The assumption is hold
    
  
  when :
    
      Assume the statement is hold when 
       is sorted array
    
  
  when 
    
      If , then  is naturally sorted
so the proof is done
      Otherwise, the  is swapped with 
      Now  is sorted and (after swapping!)
      Next, we apply this algorithm to  and now 
      The statement is hold when ,
so  is sorted after applying the algorithm
      Now  is sorted and , so the proof is done
    
  


Complexity
The time complexity depends on the speed to find the inserted position.
The more iterations to find the value of  need,
the more time it takes.
The worst case is that we need to go through whole  to find correct
positions to insert. It happens when the list is arranged from maximal to
minimal values(e.g.,).
In this case, if the length of list is , we need to search

times to move all the items into .
Thus, the complexity is .

Implementation

See the files on gist here.

#include &amp;lt;algorithm&amp;gt;  // for std::swap
#include &amp;lt;cassert&amp;gt;
#include &amp;quot;sorting.h&amp;quot;

/*
 * Insertion sort: O(n^2)
 */
void insertionSort(int list[], const unsigned int length)
{
  assert(length);

  // &amp;lt;-- sorted --&amp;gt;|&amp;lt;-- unsorted --&amp;gt;
  // +---+-----+---+---------------+
  // | 0 | ... | t | ............  |
  // +---+-----+---+---------------+
  //             ^
  //       tail is the index of last item of sorted list.
  for (unsigned int tail = 1 ; tail &amp;lt; length; ++tail) { // list[0] is sorted!
    for (unsigned int j = tail; j &amp;gt; 0 &amp;amp;&amp;amp; list[j - 1] &amp;gt; list[j] ; --j) {
      std::swap(list[j], list[j - 1]);
    }
  }
}

// void insertionSort(int list[], const unsigned int length)
// {
//   assert(length);
//
//   for (unsigned int tail = 1 ; tail &amp;lt; length; ++tail) {
//     int current = list[tail];
//     unsigned int j = tail;
//     while(j &amp;gt; 0 &amp;amp;&amp;amp; list[j-1] &amp;gt; current) {
//       list[j] = list[j - 1];
//       --j;
//     }
//     list[j] = current;
//   }
// }</summary></entry></feed>
