<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-08-08T14:30:29+08:00</updated><id>http://localhost:4000//</id><title type="html">Peak Up</title><subtitle>everyday surpass myself</subtitle><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><entry><title type="html">The Misuse of RefPtr</title><link href="http://localhost:4000/post/the-misuse-of-refptr" rel="alternate" type="text/html" title="The Misuse of RefPtr" /><published>2017-08-08T00:00:00+08:00</published><updated>2017-08-08T00:00:00+08:00</updated><id>http://localhost:4000/post/the-misuse-of-refptr</id><content type="html" xml:base="http://localhost:4000/post/the-misuse-of-refptr">&lt;p&gt;In &lt;a href=&quot;/post/refptr-v-s-shared-ptr&quot;&gt;last post&lt;/a&gt;,
I introduced the &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt; that can keep tracking the references to the
object &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; and the references are counted by object &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;Today, I will note my misuse of it several weeks ago.
This is also why I want to write the posts about &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-behavior-i-want&quot;&gt;What behavior I want&lt;/h2&gt;
&lt;p&gt;The following behavior is what I want when I was implementing one patch
for Firefox:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A list containing all of the solders.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Put the `s` into the list.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The `s` is destroyed, so it should be removed from the list now.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and we will put the &lt;code class=&quot;highlighter-rouge&quot;&gt;Solder&lt;/code&gt; instance into the &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt; when
it’s created and remove it when it’s destroyed.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;why-it-doesnt-work&quot;&gt;Why it doesn’t work&lt;/h2&gt;
&lt;p&gt;This is a wrong pattern to meet our expectation.
The solders in the list will &lt;strong&gt;only&lt;/strong&gt; be destroyed and removed from the list
when the whole program is ended.
The solders are only removed from the list in its deconstructor.
However, whenever the &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Solder&amp;gt; s(new Solder())&lt;/code&gt;
is deconstructed (by &lt;code class=&quot;highlighter-rouge&quot;&gt;~RefPtr&lt;/code&gt;) in the main function,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;~Solder()&lt;/code&gt; won’t be called
since there must be one another &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Solder&amp;gt; some&lt;/code&gt; in the list
referencing the solder.
Thus, the &lt;code class=&quot;highlighter-rouge&quot;&gt;~Solder()&lt;/code&gt; is only be called
when the element in the list is decontructed.&lt;/p&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample code&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;// $ g++ test.cpp --std=c++11
#include &amp;quot;RefPtr.h&amp;quot;
#include &amp;lt;algorithm&amp;gt;  // std::remove
#include &amp;lt;cassert&amp;gt;    // assert
#include &amp;lt;iostream&amp;gt;   // std::cout, std::endl
#include &amp;lt;vector&amp;gt;     // std::vector

///////////////////////////////////////////////////////////////////////////////
// Solder Interface
class Solder: public ReferenceCount
{
public:
  Solder(int n);
  ~Solder();
  int CountOff(); // Report the number.

private:
  int number;
};

///////////////////////////////////////////////////////////////////////////////
// Squad Interface
class Squad
{
public:
  static void Add(Solder* s);
  static void Remove(Solder* s);
  static void CountOff(); // Call all of the solders.
  static unsigned int Size();
private:
  static std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; members;
};

///////////////////////////////////////////////////////////////////////////////
// Solder Implementation
Solder::Solder(int n)
  : number(n)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is created.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Add(this);
}

Solder::~Solder()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Remove(this);
}

int
Solder::CountOff()
{
  return number;
}

///////////////////////////////////////////////////////////////////////////////
// Squad Implementation
std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; Squad::members;

/* static */ void
Squad::Add(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Add Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; to members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.push_back(s);
}

/* static */ void
Squad::Remove(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Remove Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; from members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.erase(std::remove(members.begin(), members.end(), s), members.end());
}

/* static */ void
Squad::CountOff()
{
  for (auto&amp;amp; m: members) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; m-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; is here!&amp;quot; &amp;lt;&amp;lt; std::endl;
  }
}

/* static */ unsigned int
Squad::Size()
{
  return members.size();
}

///////////////////////////////////////////////////////////////////////////////
// *** Wrong example to use RefPtr ***
//   We will put the Solder instances into the squad when they are created,
//   and remove the instances from the squad when they are destroyed.
//   We expect the following behavior.
//
//   List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l;
//   {
//     RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put s into the list
//   }
//   // s is destroyed and removed from the list, so list is empty now.
int main()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Creating a solder and put it into squad.&amp;quot; &amp;lt;&amp;lt; std::endl;

  {
    RefPtr&amp;lt;Solder&amp;gt; s(new Solder(1));
    Squad::CountOff();
    // There should be one solder in the squad now.
    assert(Squad::Size() == 1 &amp;amp;&amp;amp; s-&amp;gt;GetCount() == 2);
  }

  std::cout &amp;lt;&amp;lt; &amp;quot;Solder should be removed from squad and destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  // In our mind, we expect there is no solder in the squad now.
  assert(Squad::Size() == 0); // Comment this to check the below one.
  // But it&amp;#39;s wrong. The correct status of the memebers is:
  // assert(Squad::Size() == 1);

  // In our expectation, we expect the solder 1 will be destroyed and removed
  // from the sqaud when the program is running out of &amp;#39;}&amp;#39; above.
  // At that time, the ~RefPtr() will be called and check whether we need to
  // release the solder 1. However, since we still have a reference to solder 1
  // in the members list of the squal, the reference count to solder 1 is not 0.
  // Therefore, it won&amp;#39;t be removed!

  // Actually,
  // ------------------------------------
  // List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; list
  // Solder()
  // {
  //   Add &amp;#39;this&amp;#39; into the list
  // }
  // ~Solder()
  // {
  //   Remove &amp;#39;this&amp;#39; from the list
  // }
  // ------------------------------------
  // is a wrong pattern to meet our expectation.
  // The solders in the list will only be destroyed and removed from the list
  // when the whole program is ended. The solders are only removed from
  // the list in its deconstructor. However, whenever the
  // RefPtr&amp;lt;Solder&amp;gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,
  // the ~Solder() won&amp;#39;t be called since there must be one another
  // RefPtr&amp;lt;Solder&amp;gt; in the list referencing the solder.
  // Thus, the ~Solder() is only be called when the element in the list is
  // decontructed.

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1.js?file=misuse.cpp&quot;&gt; &lt;/script&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><category term="Firefox" /><summary type="html">In last post,
I introduced the RefPtr&amp;lt;T&amp;gt; that can keep tracking the references to the
object T and the references are counted by object T itself.

Today, I will note my misuse of it several weeks ago.
This is also why I want to write the posts about RefPtr&amp;lt;T&amp;gt;.

What behavior I want
The following behavior is what I want when I was implementing one patch
for Firefox:

List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l; // A list containing all of the solders.
{
  RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put the `s` into the list.
}
// The `s` is destroyed, so it should be removed from the list now.



and we will put the Solder instance into the l when
it’s created and remove it when it’s destroyed.

Solder()
{
  Add this into `l`
}
~Solder()
{
  Remove this from `l`
}



Why it doesn’t work
This is a wrong pattern to meet our expectation.
The solders in the list will only be destroyed and removed from the list
when the whole program is ended.
The solders are only removed from the list in its deconstructor.
However, whenever the RefPtr&amp;lt;Solder&amp;gt; s(new Solder())
is deconstructed (by ~RefPtr) in the main function,
the ~Solder() won’t be called
since there must be one another RefPtr&amp;lt;Solder&amp;gt; some in the list
referencing the solder.
Thus, the ~Solder() is only be called
when the element in the list is decontructed.

Sample code
// $ g++ test.cpp --std=c++11
#include &amp;quot;RefPtr.h&amp;quot;
#include &amp;lt;algorithm&amp;gt;  // std::remove
#include &amp;lt;cassert&amp;gt;    // assert
#include &amp;lt;iostream&amp;gt;   // std::cout, std::endl
#include &amp;lt;vector&amp;gt;     // std::vector

///////////////////////////////////////////////////////////////////////////////
// Solder Interface
class Solder: public ReferenceCount
{
public:
  Solder(int n);
  ~Solder();
  int CountOff(); // Report the number.

private:
  int number;
};

///////////////////////////////////////////////////////////////////////////////
// Squad Interface
class Squad
{
public:
  static void Add(Solder* s);
  static void Remove(Solder* s);
  static void CountOff(); // Call all of the solders.
  static unsigned int Size();
private:
  static std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; members;
};

///////////////////////////////////////////////////////////////////////////////
// Solder Implementation
Solder::Solder(int n)
  : number(n)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is created.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Add(this);
}

Solder::~Solder()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Remove(this);
}

int
Solder::CountOff()
{
  return number;
}

///////////////////////////////////////////////////////////////////////////////
// Squad Implementation
std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; Squad::members;

/* static */ void
Squad::Add(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Add Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; to members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.push_back(s);
}

/* static */ void
Squad::Remove(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Remove Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; from members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.erase(std::remove(members.begin(), members.end(), s), members.end());
}

/* static */ void
Squad::CountOff()
{
  for (auto&amp;amp; m: members) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; m-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; is here!&amp;quot; &amp;lt;&amp;lt; std::endl;
  }
}

/* static */ unsigned int
Squad::Size()
{
  return members.size();
}

///////////////////////////////////////////////////////////////////////////////
// *** Wrong example to use RefPtr ***
//   We will put the Solder instances into the squad when they are created,
//   and remove the instances from the squad when they are destroyed.
//   We expect the following behavior.
//
//   List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l;
//   {
//     RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put s into the list
//   }
//   // s is destroyed and removed from the list, so list is empty now.
int main()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Creating a solder and put it into squad.&amp;quot; &amp;lt;&amp;lt; std::endl;

  {
    RefPtr&amp;lt;Solder&amp;gt; s(new Solder(1));
    Squad::CountOff();
    // There should be one solder in the squad now.
    assert(Squad::Size() == 1 &amp;amp;&amp;amp; s-&amp;gt;GetCount() == 2);
  }

  std::cout &amp;lt;&amp;lt; &amp;quot;Solder should be removed from squad and destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  // In our mind, we expect there is no solder in the squad now.
  assert(Squad::Size() == 0); // Comment this to check the below one.
  // But it&amp;#39;s wrong. The correct status of the memebers is:
  // assert(Squad::Size() == 1);

  // In our expectation, we expect the solder 1 will be destroyed and removed
  // from the sqaud when the program is running out of &amp;#39;}&amp;#39; above.
  // At that time, the ~RefPtr() will be called and check whether we need to
  // release the solder 1. However, since we still have a reference to solder 1
  // in the members list of the squal, the reference count to solder 1 is not 0.
  // Therefore, it won&amp;#39;t be removed!

  // Actually,
  // ------------------------------------
  // List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; list
  // Solder()
  // {
  //   Add &amp;#39;this&amp;#39; into the list
  // }
  // ~Solder()
  // {
  //   Remove &amp;#39;this&amp;#39; from the list
  // }
  // ------------------------------------
  // is a wrong pattern to meet our expectation.
  // The solders in the list will only be destroyed and removed from the list
  // when the whole program is ended. The solders are only removed from
  // the list in its deconstructor. However, whenever the
  // RefPtr&amp;lt;Solder&amp;gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,
  // the ~Solder() won&amp;#39;t be called since there must be one another
  // RefPtr&amp;lt;Solder&amp;gt; in the list referencing the solder.
  // Thus, the ~Solder() is only be called when the element in the list is
  // decontructed.

  return 0;
}</summary></entry><entry><title type="html">RefPtr v.s. shared_ptr</title><link href="http://localhost:4000/post/refptr-v-s-shared-ptr" rel="alternate" type="text/html" title="RefPtr v.s. shared_ptr" /><published>2017-07-31T00:00:00+08:00</published><updated>2017-07-31T00:00:00+08:00</updated><id>http://localhost:4000/post/refptr-v-s-shared-ptr</id><content type="html" xml:base="http://localhost:4000/post/refptr-v-s-shared-ptr">&lt;p&gt;When I tried to replace Mozilla’s &lt;a href=&quot;http://searchfox.org/mozilla-central/source/mfbt/RefPtr.h&quot; title=&quot;RefPtr&quot;&gt;RefPtr&lt;/a&gt; with standard C++
smart-pointer to note one of my misusage of it,
I used &lt;em&gt;std::shard_ptr&lt;/em&gt; to do it.
However, it didn’t work since there is a huge difference between
Mozilla’s &lt;a href=&quot;http://searchfox.org/mozilla-central/source/mfbt/RefPtr.h&quot; title=&quot;RefPtr&quot;&gt;RefPtr&lt;/a&gt; and the &lt;em&gt;std::shard_ptr&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I’ve never noticed that because I never use smart-pointer
before I worked for Mozilla.
So it’s a perfect chance for me to get closer to look at their difference.&lt;/p&gt;

&lt;h2 id=&quot;reference-count&quot;&gt;Reference count&lt;/h2&gt;
&lt;p&gt;Although they’re both using reference-count to track object
and manage objects’ life-time by the count,
they are counting on different things.&lt;/p&gt;

&lt;p&gt;Suppose we have reference-counted pointers &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;T&amp;gt;&lt;/code&gt;,
we will call it like &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Foo&amp;gt; p(new Foo(...))&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;refptr&quot;&gt;&lt;em&gt;RefPtr&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;When using &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;,
the total reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt; objects.
That’s see an example below.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Foo must provide reference-counted interface.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// The total references will be counted on Foo object f.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of f is 1 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of f is 2 now.  
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the reference count of f is back to 1 now since p2 is destroyed.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;stdshard_ptr&quot;&gt;&lt;em&gt;std::shard_ptr&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;When using &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;T&amp;gt;&lt;/code&gt;,
the total reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&lt;/code&gt; itself.
That’s see an example below.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Bar does NOT need to provide reference-counted interface.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p1 is 1 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p1 and p2 is 2 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the reference count of p1 is back to 1 now since p2 is destroyed.
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p3 is 1 now.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Even worse, the above program will cause an error:
&lt;strong&gt;pointer being freed was not allocated&lt;/strong&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;p1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;p3&lt;/code&gt; both control the life-time of &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.
When &lt;code class=&quot;highlighter-rouge&quot;&gt;p1&lt;/code&gt; is destroyed, its reference-count is down to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;,
so it will deallocate &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.
Nevertheless, When &lt;code class=&quot;highlighter-rouge&quot;&gt;p3&lt;/code&gt; is destroyed,
its reference-count is also down to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;,
so it will deallocate &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; &lt;strong&gt;again&lt;/strong&gt; and cause an error:
&lt;strong&gt;Freeing an already-freed object&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Thus, using&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;to replace the following pattern should save your life.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// This is a bad pattern!
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample code&lt;/h2&gt;
&lt;p&gt;That’s see the example-implementation of these two smart-pointers.
Again, the key difference between &lt;em&gt;RefPtr&lt;/em&gt; and &lt;em&gt;std::shard_ptr&lt;/em&gt; is&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt; p(new T(...))&lt;/code&gt;:
the reference is counted on the newed &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; object
so the &lt;code class=&quot;highlighter-rouge&quot;&gt;class T&lt;/code&gt; must provide &lt;em&gt;reference-counted&lt;/em&gt; interface.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))&lt;/code&gt;:
the reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt; itself.&lt;/li&gt;
&lt;/ul&gt;

&lt;noscript&gt;&lt;pre&gt;#ifndef REFPTR_H
#define REFPTR_H

#include &amp;lt;cassert&amp;gt;

#define DEBUG
#ifdef DEBUG
#ifdef NDEBUG
#undef NDEBUG
#endif // NDEBUG
#include &amp;lt;iostream&amp;gt;
#endif // DEBUG

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Interface
class ReferenceCount
{
public:
  void AddRef();
  void Release();
  unsigned int GetCount();
  bool IsShared();

protected:
  ReferenceCount();
  // Disallow copy constructor
  ReferenceCount(const ReferenceCount&amp;amp; rhs) = delete;
  // ReferenceCount&amp;amp; operator=(const ReferenceCount&amp;amp; rhs);
  virtual ~ReferenceCount();

private:
  unsigned int count;
};

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Implementation
ReferenceCount::ReferenceCount()
  : count(0)
{
}

// ReferenceCount::ReferenceCount(const ReferenceCount&amp;amp; rhs)
//   : count(0)
// {
// }

ReferenceCount::~ReferenceCount()
{
}

// ReferenceCount&amp;amp;
// ReferenceCount::&amp;amp; operator=(const ReferenceCount&amp;amp; rhs)
// {
//   return this;
// }

void
ReferenceCount::AddRef()
{
  ++count;
}

void
ReferenceCount::Release()
{
  if (!--count) {
#ifdef DEBUG
    fprintf(stderr, &amp;quot;Release %s @ %p\n&amp;quot;, typeid(*this).name() + 1,this);
#endif
    delete this;
  }
}

unsigned int
ReferenceCount::GetCount()
{
  return count;
}

bool
ReferenceCount::IsShared()
{
  return count &amp;gt; 1;
}

///////////////////////////////////////////////////////////////////////////////
// RefPtr Interface
//   pointee must support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class RefPtr
{
public:
  // Default constructor
  RefPtr(T* realPtr = nullptr);

  // Copy constructor
  RefPtr(const RefPtr&amp;amp; rhs);

  ~RefPtr();

  RefPtr&amp;amp; operator=(const RefPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  bool operator==(const RefPtr&amp;amp; rhs);

  bool operator==(const T* rawPtr);

private:
  T *pointee;
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// RefPtr Implementation
template&amp;lt;class T&amp;gt;
void
RefPtr&amp;lt;T&amp;gt;::Init()
{
  if (!pointee) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p\n&amp;quot;, typeid(T).name() + 1, pointee);
#endif
  pointee-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(T* realPtr)
  : pointee(realPtr)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(const RefPtr&amp;amp; rhs)
  : pointee(rhs.pointee)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::~RefPtr()
{
  if (!pointee) {
    return;
  }
  pointee-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator=(const RefPtr&amp;amp; rhs)
{
  if (pointee != rhs.pointee) {
    if (pointee) {
      pointee-&amp;gt;Release();
    }
    pointee = rhs.pointee;
    Init();
  }

  return *this;
}

template&amp;lt;class T&amp;gt;
T*
RefPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(pointee);
  return pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(pointee);
  return *pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const RefPtr&amp;amp; rhs)
{
  return pointee == rhs.pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const T* rawPtr)
{
  return pointee == rawPtr;
}

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Interface
//   pointee doesn&amp;#39;t need to support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class SharedPtr
{
public:
  // Default constructor
  SharedPtr(T* realPtr = nullptr);

  // Copy constructor
  SharedPtr(const SharedPtr&amp;amp; rhs);

  ~SharedPtr();

  SharedPtr&amp;amp; operator=(const SharedPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  // Gives clients access to IsShared() and GetCount()
  ReferenceCount&amp;amp; GetCounter()
  {
    return *counter;
  }

private:
  ///////////////////////////////
  // The references are counted inside SharedPtr instead of in the pointee!
  struct Counter: public ReferenceCount {
    Counter(T* realPtr = nullptr)
      : pointee(realPtr) {}
    ~Counter() { delete pointee; }
    T *pointee;
  };

  Counter *counter;
  ///////////////////////////////
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Implementation
template&amp;lt;class T&amp;gt;
void
SharedPtr&amp;lt;T&amp;gt;::Init()
{
  if (!counter) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p\n&amp;quot;, typeid(counter).name() + 1, counter);
#endif
  counter-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(T* realPtr)
  : counter(new Counter(realPtr))
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(const SharedPtr&amp;amp; rhs)
  : counter(rhs.counter)
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::~SharedPtr()
{
  counter-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator=(const SharedPtr&amp;amp; rhs)
{
  if (counter != rhs.counter) {
    counter-&amp;gt;Release();
    counter = rhs.counter;
    Init();
  }
  return *this;
}
template&amp;lt;class T&amp;gt;
T*
SharedPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(counter-&amp;gt;pointee);
  return counter-&amp;gt;pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(counter-&amp;gt;pointee);
  return *(counter-&amp;gt;pointee);
}

#endif // REFPTR_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1.js?file=RefPtr.h&quot;&gt; &lt;/script&gt;

&lt;p&gt;You can look &lt;a href=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1&quot; title=&quot;RefPtr and SharedPtr&quot;&gt;here&lt;/a&gt; to see how to use it.&lt;/p&gt;

&lt;p&gt;The above code is referenced from &lt;a href=&quot;http://www.aristeia.com/BookErrata/M29Source.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><category term="Firefox" /><summary type="html">When I tried to replace Mozilla’s RefPtr with standard C++
smart-pointer to note one of my misusage of it,
I used std::shard_ptr to do it.
However, it didn’t work since there is a huge difference between
Mozilla’s RefPtr and the std::shard_ptr

I’ve never noticed that because I never use smart-pointer
before I worked for Mozilla.
So it’s a perfect chance for me to get closer to look at their difference.

Reference count
Although they’re both using reference-count to track object
and manage objects’ life-time by the count,
they are counting on different things.

Suppose we have reference-counted pointers RefPtr&amp;lt;T&amp;gt;
and std::shard_ptr&amp;lt;T&amp;gt;,
we will call it like RefPtr&amp;lt;Foo&amp;gt; p(new Foo(...))
and std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))

RefPtr
When using RefPtr&amp;lt;T&amp;gt;,
the total reference is counted on the Foo objects.
That’s see an example below.
// Foo must provide reference-counted interface.
Foo* f = new Foo(...) // The total references will be counted on Foo object f.
RefPtr&amp;lt;Foo&amp;gt; p1(f) // the reference count of f is 1 now.
{
  RefPtr&amp;lt;Foo&amp;gt; p2(f) // the reference count of f is 2 now.  
}
// the reference count of f is back to 1 now since p2 is destroyed.



std::shard_ptr
When using std::shard_ptr&amp;lt;T&amp;gt;,
the total reference is counted on the std::shard_ptr itself.
That’s see an example below.
// Bar does NOT need to provide reference-counted interface.
Bar* b = new Bar(...)
std::shard_ptr&amp;lt;Bar&amp;gt; p1(f) // the reference count of p1 is 1 now.
{
  std::shard_ptr&amp;lt;Bar&amp;gt; p2(p1) // the reference count of p1 and p2 is 2 now.
}
// the reference count of p1 is back to 1 now since p2 is destroyed.

std::shard_ptr&amp;lt;Bar&amp;gt; p3(b) // the reference count of p3 is 1 now.


Even worse, the above program will cause an error:
pointer being freed was not allocated.
The p1 and p3 both control the life-time of b.
When p1 is destroyed, its reference-count is down to 0,
so it will deallocate b.
Nevertheless, When p3 is destroyed,
its reference-count is also down to 0,
so it will deallocate b again and cause an error:
Freeing an already-freed object

Thus, using
std::shard_ptr&amp;lt;Bar&amp;gt; p(new Bar(...))


to replace the following pattern should save your life.
// This is a bad pattern!
Bar* b = new Bar(...)
std::shard_ptr&amp;lt;Bar&amp;gt; p(f)



Sample code
That’s see the example-implementation of these two smart-pointers.
Again, the key difference between RefPtr and std::shard_ptr is

  RefPtr&amp;lt;T&amp;gt; p(new T(...)):
the reference is counted on the newed T object
so the class T must provide reference-counted interface.
  std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...)):
the reference is counted on the q itself.


#ifndef REFPTR_H
#define REFPTR_H

#include &amp;lt;cassert&amp;gt;

#define DEBUG
#ifdef DEBUG
#ifdef NDEBUG
#undef NDEBUG
#endif // NDEBUG
#include &amp;lt;iostream&amp;gt;
#endif // DEBUG

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Interface
class ReferenceCount
{
public:
  void AddRef();
  void Release();
  unsigned int GetCount();
  bool IsShared();

protected:
  ReferenceCount();
  // Disallow copy constructor
  ReferenceCount(const ReferenceCount&amp;amp; rhs) = delete;
  // ReferenceCount&amp;amp; operator=(const ReferenceCount&amp;amp; rhs);
  virtual ~ReferenceCount();

private:
  unsigned int count;
};

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Implementation
ReferenceCount::ReferenceCount()
  : count(0)
{
}

// ReferenceCount::ReferenceCount(const ReferenceCount&amp;amp; rhs)
//   : count(0)
// {
// }

ReferenceCount::~ReferenceCount()
{
}

// ReferenceCount&amp;amp;
// ReferenceCount::&amp;amp; operator=(const ReferenceCount&amp;amp; rhs)
// {
//   return this;
// }

void
ReferenceCount::AddRef()
{
  ++count;
}

void
ReferenceCount::Release()
{
  if (!--count) {
#ifdef DEBUG
    fprintf(stderr, &amp;quot;Release %s @ %p &amp;quot;, typeid(*this).name() + 1,this);
#endif
    delete this;
  }
}

unsigned int
ReferenceCount::GetCount()
{
  return count;
}

bool
ReferenceCount::IsShared()
{
  return count &amp;gt; 1;
}

///////////////////////////////////////////////////////////////////////////////
// RefPtr Interface
//   pointee must support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class RefPtr
{
public:
  // Default constructor
  RefPtr(T* realPtr = nullptr);

  // Copy constructor
  RefPtr(const RefPtr&amp;amp; rhs);

  ~RefPtr();

  RefPtr&amp;amp; operator=(const RefPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  bool operator==(const RefPtr&amp;amp; rhs);

  bool operator==(const T* rawPtr);

private:
  T *pointee;
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// RefPtr Implementation
template&amp;lt;class T&amp;gt;
void
RefPtr&amp;lt;T&amp;gt;::Init()
{
  if (!pointee) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p &amp;quot;, typeid(T).name() + 1, pointee);
#endif
  pointee-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(T* realPtr)
  : pointee(realPtr)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(const RefPtr&amp;amp; rhs)
  : pointee(rhs.pointee)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::~RefPtr()
{
  if (!pointee) {
    return;
  }
  pointee-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator=(const RefPtr&amp;amp; rhs)
{
  if (pointee != rhs.pointee) {
    if (pointee) {
      pointee-&amp;gt;Release();
    }
    pointee = rhs.pointee;
    Init();
  }

  return *this;
}

template&amp;lt;class T&amp;gt;
T*
RefPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(pointee);
  return pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(pointee);
  return *pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const RefPtr&amp;amp; rhs)
{
  return pointee == rhs.pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const T* rawPtr)
{
  return pointee == rawPtr;
}

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Interface
//   pointee doesn&amp;#39;t need to support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class SharedPtr
{
public:
  // Default constructor
  SharedPtr(T* realPtr = nullptr);

  // Copy constructor
  SharedPtr(const SharedPtr&amp;amp; rhs);

  ~SharedPtr();

  SharedPtr&amp;amp; operator=(const SharedPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  // Gives clients access to IsShared() and GetCount()
  ReferenceCount&amp;amp; GetCounter()
  {
    return *counter;
  }

private:
  ///////////////////////////////
  // The references are counted inside SharedPtr instead of in the pointee!
  struct Counter: public ReferenceCount {
    Counter(T* realPtr = nullptr)
      : pointee(realPtr) {}
    ~Counter() { delete pointee; }
    T *pointee;
  };

  Counter *counter;
  ///////////////////////////////
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Implementation
template&amp;lt;class T&amp;gt;
void
SharedPtr&amp;lt;T&amp;gt;::Init()
{
  if (!counter) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p &amp;quot;, typeid(counter).name() + 1, counter);
#endif
  counter-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(T* realPtr)
  : counter(new Counter(realPtr))
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(const SharedPtr&amp;amp; rhs)
  : counter(rhs.counter)
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::~SharedPtr()
{
  counter-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator=(const SharedPtr&amp;amp; rhs)
{
  if (counter != rhs.counter) {
    counter-&amp;gt;Release();
    counter = rhs.counter;
    Init();
  }
  return *this;
}
template&amp;lt;class T&amp;gt;
T*
SharedPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(counter-&amp;gt;pointee);
  return counter-&amp;gt;pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(counter-&amp;gt;pointee);
  return *(counter-&amp;gt;pointee);
}

#endif // REFPTR_H


You can look here to see how to use it.

The above code is referenced from here</summary></entry><entry><title type="html">Development Notes for Mozilla</title><link href="http://localhost:4000/post/development-notes-for-mozilla" rel="alternate" type="text/html" title="Development Notes for Mozilla" /><published>2017-07-19T00:00:00+08:00</published><updated>2017-07-19T00:00:00+08:00</updated><id>http://localhost:4000/post/development-notes-for-mozilla</id><content type="html" xml:base="http://localhost:4000/post/development-notes-for-mozilla">&lt;p&gt;The following are some of my notes to develop the mozilla products.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.penflip.com/Chun-Min/mozilla-newbie-notes&quot; title=&quot;Mozilla Newbie Notes&quot;&gt;Basic knowledge&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;XPCOM&lt;/li&gt;
      &lt;li&gt;WebIDL&lt;/li&gt;
      &lt;li&gt;Mochitest&lt;/li&gt;
      &lt;li&gt;others&lt;/li&gt;
      &lt;li&gt;&lt;del&gt;Firefox OS&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1S4njAbl4tSFCrJ3cnE30L4PcYeWdvY-1wcghX2mWNOE/edit?usp=sharing&quot; title=&quot;IPDL&quot;&gt;IPDL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1o9qeSucSDAJO94TmZmebxRnGepY7MVy-MeVGqyaIO0s/edit?usp=sharing&quot; title=&quot;Firefox (System) Add-on&quot;&gt;(System) Add-on&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1eDjlmBdBrECQ_vXve0HgzmBilgL8HwHrcFQz9puGGr0/edit?usp=sharing&quot; title=&quot;Message Manager&quot;&gt;Message Manager&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1zxanY8xDioeIrfPyuzx9QDgggO1pC8erqhcL30gL7Wc/edit?usp=sharing&quot; title=&quot;Keyboard Event Dispatch&quot;&gt;Keyboard Event Dispatch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/15iXd4ZXy9Y1uKdXkuFsdoqXAzw7Y4pUFKlDaNiAFkb0/edit?usp=sharing&quot; title=&quot;JPAKE over TLS&quot;&gt;JPAKE over TLS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Firefox" /><category term="Fennec" /><summary type="html">The following are some of my notes to develop the mozilla products.


  Basic knowledge
    
      XPCOM
      WebIDL
      Mochitest
      others
      Firefox OS
    
  
  IPDL
  (System) Add-on
  Message Manager
  Keyboard Event Dispatch
  JPAKE over TLS</summary></entry><entry><title type="html">Hash Table v.s. Mutable Array</title><link href="http://localhost:4000/post/hash-table-v-s-mutable-array" rel="alternate" type="text/html" title="Hash Table v.s. Mutable Array" /><published>2017-07-15T00:00:00+08:00</published><updated>2017-07-15T00:00:00+08:00</updated><id>http://localhost:4000/post/hash-table-v-s-mutable-array</id><content type="html" xml:base="http://localhost:4000/post/hash-table-v-s-mutable-array">&lt;p&gt;It’s common sense that the time complexity of insertion and removal of a
hash table are all both &lt;em&gt;O(1)&lt;/em&gt;, while array takes &lt;em&gt;O(n)&lt;/em&gt; for removal.
However, when the data size(&lt;em&gt;n&lt;/em&gt;) is small, the array will beat the hash table.&lt;/p&gt;

&lt;p&gt;Here is the result from my test&lt;a href=&quot;https://gist.github.com/ChunMinChang/b6b7b534e1ef3683f76d830d72c489a6&quot; title=&quot;Performance: Mutable array v.s. Hashtable&quot;&gt;(gist here)&lt;/a&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;# Performance: Mutable array v.s. Hashtable

Subjects:
- mutable array: ```std::vector```
- hash table: ```std::unordered_map```

## Results

### Insertion time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000  | 10000 |
| ------------------ | ----- | ----- | ----- | ----- | ----- | ----- |
| std::vector        | 0.015 | 0.021 | 0.097 | 0.093 | 0.366 | 0.616 |
| std::unordered_map | 0.034 | 0.081 | 0.202 | 0.503 | 2.425 | 3.482 |


### Removal time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000   | 10000   |
| ------------------ | ----- | ----- | ----- | ----- | ------ | ------- |
| std::vector        | 0.008 | 0.046 | 0.129 | 3.82  | 88.562 | 344.566 |
| std::unordered_map | 0.013 | 0.051 | 0.078 | 0.456 | 2.14   | 3.6     |&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/b6b7b534e1ef3683f76d830d72c489a6.js?file=README.md&quot;&gt; &lt;/script&gt;

&lt;p&gt;By the results, if you are pretty sure the data size is less than &lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;
then you should use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unordered_map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On the other hand, if you need to insert and remove itmes frequently,
and the data size is greater than &lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;,
then you should use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::unordered_map&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt;.
If items are inserted frequently but removed rarely, &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; is fine.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">It’s common sense that the time complexity of insertion and removal of a
hash table are all both O(1), while array takes O(n) for removal.
However, when the data size(n) is small, the array will beat the hash table.

Here is the result from my test(gist here)
# Performance: Mutable array v.s. Hashtable

Subjects:
- mutable array: ```std::vector```
- hash table: ```std::unordered_map```

## Results

### Insertion time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000  | 10000 |
| ------------------ | ----- | ----- | ----- | ----- | ----- | ----- |
| std::vector        | 0.015 | 0.021 | 0.097 | 0.093 | 0.366 | 0.616 |
| std::unordered_map | 0.034 | 0.081 | 0.202 | 0.503 | 2.425 | 3.482 |


### Removal time(ms)
| Data Size          | 10    | 50    | 100   | 1000  | 5000   | 10000   |
| ------------------ | ----- | ----- | ----- | ----- | ------ | ------- |
| std::vector        | 0.008 | 0.046 | 0.129 | 3.82  | 88.562 | 344.566 |
| std::unordered_map | 0.013 | 0.051 | 0.078 | 0.456 | 2.14   | 3.6     |


By the results, if you are pretty sure the data size is less than 50
then you should use std::vector instead of std::unordered_map.

On the other hand, if you need to insert and remove itmes frequently,
and the data size is greater than 50,
then you should use std::unordered_map instead of std::vector.
If items are inserted frequently but removed rarely, std::vector is fine.</summary></entry><entry><title type="html">Adding a IPDL into PContent</title><link href="http://localhost:4000/post/adding-a-ipdl-into-pcontent" rel="alternate" type="text/html" title="Adding a IPDL into PContent" /><published>2017-07-11T00:00:00+08:00</published><updated>2017-07-11T00:00:00+08:00</updated><id>http://localhost:4000/post/adding-a-ipdl-into-pcontent</id><content type="html" xml:base="http://localhost:4000/post/adding-a-ipdl-into-pcontent">&lt;p&gt;This is my note for adding a IPDL into PContent.&lt;/p&gt;

&lt;iframe src=&quot;https://docs.google.com/presentation/d/1S4njAbl4tSFCrJ3cnE30L4PcYeWdvY-1wcghX2mWNOE/embed?start=false&amp;amp;loop=false&amp;amp;delayms=3000&quot; frameborder=&quot;0&quot; width=&quot;960&quot; height=&quot;569&quot; allowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;The sample code is &lt;a href=&quot;https://github.com/ChunMinChang/gecko-dev/commit/54686d3fbc1ce7a696b4755060810d8ed8f4d567&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Multiprocess" /><category term="Firefox" /><summary type="html">This is my note for adding a IPDL into PContent.



The sample code is here</summary></entry><entry><title type="html">Pthread mutex with different types</title><link href="http://localhost:4000/post/pthread-mutex-with-different-types" rel="alternate" type="text/html" title="Pthread mutex with different types" /><published>2017-05-06T00:00:00+08:00</published><updated>2017-05-06T00:00:00+08:00</updated><id>http://localhost:4000/post/pthread-mutex-with-different-types</id><content type="html" xml:base="http://localhost:4000/post/pthread-mutex-with-different-types">&lt;p&gt;When I tried to &lt;a href=&quot;deadlock-when-using-audiounit&quot;&gt;produce a deadlock in &lt;em&gt;CoreAudio&lt;/em&gt;&lt;/a&gt; with pthread,
I realized that the &lt;em&gt;mutex&lt;/em&gt; with &lt;strong&gt;NORMAL&lt;/strong&gt; type locked by one pthread
could be unlocked by another pthread.
Normally, this behavior should be &lt;strong&gt;disallowed&lt;/strong&gt;.
It will result in undefined behaviors.
If one pthread could unlock a mutex owned by other thread whenever it wants,
then the mutex will be meaningless,
unless it’s a expected behavior.&lt;/p&gt;

&lt;p&gt;In my case, it’s exactly what I want, 
because I need to break the deadlock to continue the program.
However, in most case, this behavior should be &lt;strong&gt;forbidden&lt;/strong&gt;,
so I do some research about
what the behaviors of mutexes with different types are.&lt;/p&gt;

&lt;p&gt;Here is my conclusion:&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;# pthread

Sample code for demonstrating different behavior
in different pthread type
- *PTHREAD_MUTEX_NORMAL*
  - This type of mutex does **not** detect deadlock
  - A thread attempting to relock this mutex without first unlocking it
    shall deadlock
  - A thread attempting to unlock a mutex locked by a different thread
    results in undefined behavior
  - A thread attempting to unlock an unlocked mutex
    results in undefined behavior
- *PTHREAD_MUTEX_ERRORCHECK*
  - This type of mutex provides error checking
  - A thread attempting to relock this mutex without first unlocking
    it shall return with an error
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_RECURSIVE*
  - A thread attempting to relock this mutex without first unlocking it
    shall succeed in locking the mutex
    - The relocking is allowd only in the **same** thread
    - The relocking deadlock which can occur with mutexes of type
      *PTHREAD_MUTEX_NORMAL* **cannot** occur with this type of mutex
    - Multiple locks of this mutex shall require the same number of unlocks
      to release the mutex before another thread can acquire the mutex
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_DEFAULT*
  - Its default value is set to *PTHREAD_MUTEX_NORMAL*
  - It&amp;#39;s allowed to map its value to other types

## Scenarios and results
We have four scenarios:
1. Lock a locked mutex in same thread
2. Unlock a unlocked mutex
3. (Wait to) Lock a locked mutex owned by another thread (__normal use case__)
4. Unlock a locked mutex owned by another thread

Unlocking a mutex owned by current thread is definitely ok,
so it&amp;#39;s exclusive in our scenarios.

The results of our scenarios in different type is:

|            | 1 | 2 | 3 | 4 |
|------------|---|---|---|---|
| NORMAL     | ! | v | v | v |
| ERRORCHECK |   |   | v |   |
| RECURSIVE  | v |   | v |   |
| DEFAULT    | ! | v | v | v |

- ```!```: It works without any error, but it will be **self-deadlocked**
- ```v```: It works without any error
- empty: It can not works, with an error returned


## TODO
- Sample code for ```pthread_kill``` and ```pthread_detach```


## Note

### pthread_mutex_trylock
The ```pthread_mutex_trylock()``` shall be equivalent
to ```pthread_mutex_lock()```,
except that if the mutex object referenced by mutex is currently locked
(by any thread, including the current thread),
the call shall return immediately.
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/fe46f3760e2230c09675e258ae1cf8eb.js?file=README.md&quot;&gt; &lt;/script&gt;

&lt;p&gt;The test code can be found on &lt;a href=&quot;https://gist.github.com/ChunMinChang/fe46f3760e2230c09675e258ae1cf8eb&quot;&gt;gist here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="Multithread" /><summary type="html">When I tried to produce a deadlock in CoreAudio with pthread,
I realized that the mutex with NORMAL type locked by one pthread
could be unlocked by another pthread.
Normally, this behavior should be disallowed.
It will result in undefined behaviors.
If one pthread could unlock a mutex owned by other thread whenever it wants,
then the mutex will be meaningless,
unless it’s a expected behavior.

In my case, it’s exactly what I want, 
because I need to break the deadlock to continue the program.
However, in most case, this behavior should be forbidden,
so I do some research about
what the behaviors of mutexes with different types are.

Here is my conclusion:

# pthread

Sample code for demonstrating different behavior
in different pthread type
- *PTHREAD_MUTEX_NORMAL*
  - This type of mutex does **not** detect deadlock
  - A thread attempting to relock this mutex without first unlocking it
    shall deadlock
  - A thread attempting to unlock a mutex locked by a different thread
    results in undefined behavior
  - A thread attempting to unlock an unlocked mutex
    results in undefined behavior
- *PTHREAD_MUTEX_ERRORCHECK*
  - This type of mutex provides error checking
  - A thread attempting to relock this mutex without first unlocking
    it shall return with an error
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_RECURSIVE*
  - A thread attempting to relock this mutex without first unlocking it
    shall succeed in locking the mutex
    - The relocking is allowd only in the **same** thread
    - The relocking deadlock which can occur with mutexes of type
      *PTHREAD_MUTEX_NORMAL* **cannot** occur with this type of mutex
    - Multiple locks of this mutex shall require the same number of unlocks
      to release the mutex before another thread can acquire the mutex
  - A thread attempting to unlock a mutex which another thread has locked
    shall return with an error
  - A thread attempting to unlock an unlocked mutex
    shall return with an error
- *PTHREAD_MUTEX_DEFAULT*
  - Its default value is set to *PTHREAD_MUTEX_NORMAL*
  - It&amp;#39;s allowed to map its value to other types

## Scenarios and results
We have four scenarios:
1. Lock a locked mutex in same thread
2. Unlock a unlocked mutex
3. (Wait to) Lock a locked mutex owned by another thread (__normal use case__)
4. Unlock a locked mutex owned by another thread

Unlocking a mutex owned by current thread is definitely ok,
so it&amp;#39;s exclusive in our scenarios.

The results of our scenarios in different type is:

|            | 1 | 2 | 3 | 4 |
|------------|---|---|---|---|
| NORMAL     | ! | v | v | v |
| ERRORCHECK |   |   | v |   |
| RECURSIVE  | v |   | v |   |
| DEFAULT    | ! | v | v | v |

- ```!```: It works without any error, but it will be **self-deadlocked**
- ```v```: It works without any error
- empty: It can not works, with an error returned


## TODO
- Sample code for ```pthread_kill``` and ```pthread_detach```


## Note

### pthread_mutex_trylock
The ```pthread_mutex_trylock()``` shall be equivalent
to ```pthread_mutex_lock()```,
except that if the mutex object referenced by mutex is currently locked
(by any thread, including the current thread),
the call shall return immediately.



The test code can be found on gist here</summary></entry><entry><title type="html">Deadlock when using AudioUnit</title><link href="http://localhost:4000/post/deadlock-when-using-audiounit" rel="alternate" type="text/html" title="Deadlock when using AudioUnit" /><published>2017-05-05T00:00:00+08:00</published><updated>2017-05-05T00:00:00+08:00</updated><id>http://localhost:4000/post/deadlock-when-using-audiounit</id><content type="html" xml:base="http://localhost:4000/post/deadlock-when-using-audiounit">&lt;p&gt;There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1337805&quot;&gt;bug here&lt;/a&gt;.
It &lt;strong&gt;only happens on OSX&lt;/strong&gt;.
After &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1350511#c1&quot;&gt;analysis&lt;/a&gt;,
I wrote a test to prevent others from getting into the same problem.
The test is added to &lt;a href=&quot;https://github.com/ChunMinChang/cubeb&quot;&gt;cubeb&lt;/a&gt;,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of &lt;a href=&quot;https://github.com/ChunMinChang/cubeb/blob/8939c0d168a27b1d5047779caad46835ca4651b9/test/test_deadlock.cpp#L1-L43&quot;&gt;the deadlock&lt;/a&gt;)
in the test.&lt;/p&gt;

&lt;p&gt;However, the code is not easy enough for those who are not familir with &lt;em&gt;cubeb&lt;/em&gt;,
so I wrote a general version to highlight the issue to
everyone who uses &lt;em&gt;AudioUnit&lt;/em&gt; in their audio backend.
You can find the code on &lt;a href=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9&quot;&gt;gist here&lt;/a&gt;&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &amp;lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&amp;gt; Thread B

#include &amp;lt;assert.h&amp;gt;               // for assert
#include &amp;lt;pthread.h&amp;gt;              // for pthread
#include &amp;lt;signal.h&amp;gt;               // for signal
#include &amp;lt;unistd.h&amp;gt;               // for sleep, usleep

#include &amp;quot;AudioStream.h&amp;quot;          // for AudioStream
#include &amp;quot;utils.h&amp;quot;                // for LOG
#include &amp;quot;OwnedCriticalSection.h&amp;quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&amp;#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&amp;lt;OwnedCriticalSection&amp;gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&amp;quot;pending task thread is killed!\n&amp;quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;amp;&amp;amp; LOG(&amp;quot;Output callback is on thread %llu, holding mutex_AU\n&amp;quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&amp;#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&amp;quot;[%llu] Force to switch threads\n&amp;quot;, id);
    usleep(10000);
  }

  LOG(&amp;quot;[%llu] Try getting another mutex: gMutex...\n&amp;quot;, id);
  locker guard(gMutex);

  LOG(&amp;quot;[%llu] Got mutex finally!\n&amp;quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&amp;quot;Task thread: %llu, holding gMutex, is created\n&amp;quot;, id);

  while(!gCalling) {
    LOG(&amp;quot;[%llu] waiting for output callback before running task\n&amp;quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&amp;quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&amp;quot;[%llu] Another AudioUnit is created!\n&amp;quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&amp;quot;Task thread: %llu is created\n&amp;quot;, id);
//
//   while(!gCalling) {
//     LOG(&amp;quot;[%llu] waiting for output callback before running task\n&amp;quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&amp;quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&amp;quot;[%llu] Another AudioUnit is created!\n&amp;quot;, id);
//
//   // Hold the mutex.
//   LOG(&amp;quot;[%llu] Try getting another mutex: gMutex...\n&amp;quot;, id);
//   locker guard(gMutex);
//
//   LOG(&amp;quot;[%llu] Got mutex finally!\n&amp;quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&amp;quot;Monitor thread %llu on thread %llu\n&amp;quot;, sid, id);

  unsigned int sec = 1;
  LOG(&amp;quot;[%llu] sleep %d seconds before checking task for thread %llu\n&amp;quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&amp;quot;[%llu] Kill the task thread %llu!\n&amp;quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&amp;#39;t be released,
    // so we need unlock it manually. Notice that we can&amp;#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&amp;quot;\n[%llu] Task is %sdone\n\n&amp;quot;, id, gTaskDone ? &amp;quot;&amp;quot;: &amp;quot;NOT &amp;quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;amp;subject, NULL, task, NULL);
  pthread_create(&amp;amp;detector, NULL, watchdog, (void *) &amp;amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;amp;&amp;amp; &amp;quot;Callback should be fired!&amp;quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;amp;&amp;amp; &amp;quot;Deadlock detected!&amp;quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;amp;&amp;amp; &amp;quot;Killer is out of control!&amp;quot;);

  return 0;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=test_deadlock.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;The APIs called to play and stop the audio stream is:&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &amp;lt;AudioUnit/AudioUnit.h&amp;gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;CoreAudio/CoreAudio.h&amp;gt;

#include &amp;quot;AudioStream.h&amp;quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;amp;&amp;amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &amp;quot;|&amp;quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&amp;#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&amp;gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&amp;lt;AudioStream*&amp;gt;(aRefCon); // Get arguments
  void* buffer = aData-&amp;gt;mBuffers[0].mData;
  as-&amp;gt;mCallback(buffer, aNumFrames);
  return noErr;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as &lt;em&gt;Mutex-AU&lt;/em&gt;)
shared with &lt;em&gt;AudioUnit&lt;/em&gt;.
The &lt;em&gt;Mutex-AU&lt;/em&gt; is held inside it’s framework, so you don’t notice it.&lt;/p&gt;

&lt;p&gt;Thus, if the callback thread requests another &lt;em&gt;mutex M&lt;/em&gt; held by the another
thread, without releasing &lt;em&gt;mutex-AU&lt;/em&gt;, then it will cause a deadlock when the
another thread, which holds the &lt;em&gt;mutex M&lt;/em&gt;, request to use AudioUnit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That is,
if we have a &lt;em&gt;thread T&lt;/em&gt;, holding the &lt;em&gt;mutex M&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and one &lt;em&gt;callback thread&lt;/em&gt; which holds the &lt;em&gt;mutex-AU&lt;/em&gt;,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The deadlock will occur when the &lt;em&gt;callback thread&lt;/em&gt; requests the &lt;em&gt;mutex M&lt;/em&gt;
(the callback thread is blocked for waiting the &lt;em&gt;mutex M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and the &lt;em&gt;thread T&lt;/em&gt; requests the &lt;em&gt;mutex-AU&lt;/em&gt; to use AudioUnit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Media" /><category term="CoreAudio" /><category term="Multithread" /><summary type="html">There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the bug here.
It only happens on OSX.
After analysis,
I wrote a test to prevent others from getting into the same problem.
The test is added to cubeb,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of the deadlock)
in the test.

However, the code is not easy enough for those who are not familir with cubeb,
so I wrote a general version to highlight the issue to
everyone who uses AudioUnit in their audio backend.
You can find the code on gist here

// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &amp;lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&amp;gt; Thread B

#include &amp;lt;assert.h&amp;gt;               // for assert
#include &amp;lt;pthread.h&amp;gt;              // for pthread
#include &amp;lt;signal.h&amp;gt;               // for signal
#include &amp;lt;unistd.h&amp;gt;               // for sleep, usleep

#include &amp;quot;AudioStream.h&amp;quot;          // for AudioStream
#include &amp;quot;utils.h&amp;quot;                // for LOG
#include &amp;quot;OwnedCriticalSection.h&amp;quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&amp;#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&amp;lt;OwnedCriticalSection&amp;gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&amp;quot;pending task thread is killed! &amp;quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;amp;&amp;amp; LOG(&amp;quot;Output callback is on thread %llu, holding mutex_AU &amp;quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&amp;#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&amp;quot;[%llu] Force to switch threads &amp;quot;, id);
    usleep(10000);
  }

  LOG(&amp;quot;[%llu] Try getting another mutex: gMutex... &amp;quot;, id);
  locker guard(gMutex);

  LOG(&amp;quot;[%llu] Got mutex finally! &amp;quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&amp;quot;Task thread: %llu, holding gMutex, is created &amp;quot;, id);

  while(!gCalling) {
    LOG(&amp;quot;[%llu] waiting for output callback before running task &amp;quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)... &amp;quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&amp;quot;[%llu] Another AudioUnit is created! &amp;quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&amp;quot;Task thread: %llu is created &amp;quot;, id);
//
//   while(!gCalling) {
//     LOG(&amp;quot;[%llu] waiting for output callback before running task &amp;quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&amp;quot;[%llu] Try creating another AudioUnit (getting mutex_AU)... &amp;quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&amp;quot;[%llu] Another AudioUnit is created! &amp;quot;, id);
//
//   // Hold the mutex.
//   LOG(&amp;quot;[%llu] Try getting another mutex: gMutex... &amp;quot;, id);
//   locker guard(gMutex);
//
//   LOG(&amp;quot;[%llu] Got mutex finally! &amp;quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&amp;quot;Monitor thread %llu on thread %llu &amp;quot;, sid, id);

  unsigned int sec = 1;
  LOG(&amp;quot;[%llu] sleep %d seconds before checking task for thread %llu &amp;quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&amp;quot;[%llu] Kill the task thread %llu! &amp;quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&amp;#39;t be released,
    // so we need unlock it manually. Notice that we can&amp;#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&amp;quot; [%llu] Task is %sdone  &amp;quot;, id, gTaskDone ? &amp;quot;&amp;quot;: &amp;quot;NOT &amp;quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;amp;subject, NULL, task, NULL);
  pthread_create(&amp;amp;detector, NULL, watchdog, (void *) &amp;amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;amp;&amp;amp; &amp;quot;Callback should be fired!&amp;quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;amp;&amp;amp; &amp;quot;Deadlock detected!&amp;quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;amp;&amp;amp; &amp;quot;Killer is out of control!&amp;quot;);

  return 0;
}



The APIs called to play and stop the audio stream is:
#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &amp;lt;AudioUnit/AudioUnit.h&amp;gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H



#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;CoreAudio/CoreAudio.h&amp;gt;

#include &amp;quot;AudioStream.h&amp;quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;amp;&amp;amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &amp;quot;|&amp;quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&amp;#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&amp;gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&amp;lt;AudioStream*&amp;gt;(aRefCon); // Get arguments
  void* buffer = aData-&amp;gt;mBuffers[0].mData;
  as-&amp;gt;mCallback(buffer, aNumFrames);
  return noErr;
}



The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as Mutex-AU)
shared with AudioUnit.
The Mutex-AU is held inside it’s framework, so you don’t notice it.

Thus, if the callback thread requests another mutex M held by the another
thread, without releasing mutex-AU, then it will cause a deadlock when the
another thread, which holds the mutex M, request to use AudioUnit.



That is,
if we have a thread T, holding the mutex M



and one callback thread which holds the mutex-AU,



The deadlock will occur when the callback thread requests the mutex M
(the callback thread is blocked for waiting the mutex M)



and the thread T requests the mutex-AU to use AudioUnit</summary></entry><entry><title type="html">How to simulate a C++ class in C</title><link href="http://localhost:4000/post/how-to-simulate-a-c-class-in-c" rel="alternate" type="text/html" title="How to simulate a C++ class in C" /><published>2017-04-25T00:00:00+08:00</published><updated>2017-04-25T00:00:00+08:00</updated><id>http://localhost:4000/post/how-to-simulate-a-c-class-in-c</id><content type="html" xml:base="http://localhost:4000/post/how-to-simulate-a-c-class-in-c">&lt;h1 id=&quot;how-to-simulate-a-c-class-in-c&quot;&gt;How to simulate a C++ class in C&lt;/h1&gt;

&lt;p&gt;After learning &lt;em&gt;C++&lt;/em&gt;, I am curious about
how could I bring the &lt;em&gt;object-oriented&lt;/em&gt; style to &lt;em&gt;C&lt;/em&gt;.
Could we simulate a &lt;em&gt;C++&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; in C?&lt;/p&gt;

&lt;p&gt;To find the answer,
I implement a simple &lt;em&gt;linked list&lt;/em&gt; with &lt;em&gt;object-oriented&lt;/em&gt; style in plain &lt;em&gt;C&lt;/em&gt;.
The key is to use &lt;em&gt;function pointer&lt;/em&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; to
simulate a &lt;em&gt;C++&lt;/em&gt; member function.
you can find my code &lt;a href=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e&quot; title=&quot;Class in C for linked-list implementation&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To compare, I also implement a &lt;a href=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473&quot; title=&quot;Linked-list in C++&quot;&gt;&lt;em&gt;linked list&lt;/em&gt; in &lt;em&gt;C++&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;class-in-c&quot;&gt;Class in C&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef LIST_H
#define LIST_H

#include &amp;lt;stddef.h&amp;gt; // for size_t

struct Node {
  void* data; // Any data type can be stored in this node
  struct Node* next;
};

typedef void (*Callback)(struct Node* node);
struct List {
  struct Node* head;
  struct Node* cursor;

  void (* const destroy)(struct List* self);
  void (* const append)(struct List* self, void* data, size_t size);
  void (* const prepend)(struct List* self, void* data, size_t size);
  void (* const traverse)(struct List* self, Callback func);
};

extern const struct ListClass {
  struct List (*new)();
} /*ListProxy*/ List;

#endif // LIST_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=list.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;assert.h&amp;gt; // for assert
// #include &amp;lt;stddef.h&amp;gt; // for NULL, size_t, they are already included in list.h
#include &amp;lt;stdlib.h&amp;gt; // for calloc, free
#include &amp;lt;string.h&amp;gt; // for memcpy

// Using &amp;quot;static&amp;quot; prevents these functions from being exposed outside.

static void
destroy(struct List* self)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ;) {
    struct Node* next = cur-&amp;gt;next;
    free(cur-&amp;gt;data);
    free(cur);
    cur = next;
  }
  self-&amp;gt;head = self-&amp;gt;cursor = NULL;
}

static void
append(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = NULL;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  if (!self-&amp;gt;head) { // The list is empty.
    assert(!self-&amp;gt;cursor); // cursor = head = NULL now.
    self-&amp;gt;head = n;
  } else {
    assert(self-&amp;gt;cursor);
    self-&amp;gt;cursor-&amp;gt;next = n;
  }
  self-&amp;gt;cursor = n;
}

static void
prepend(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = self-&amp;gt;head;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  self-&amp;gt;head = n;
  if(!self-&amp;gt;cursor) { // The list is empty before inserting value.
    self-&amp;gt;cursor = n;
  }
}

static void
traverse(struct List* self, Callback func)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ; cur = cur-&amp;gt;next) {
    func(cur);
  }
}

static struct List
new()
{
  return (struct List) {
    .head = NULL,
    .cursor = NULL,
    .destroy = (void*) &amp;amp;destroy,
    .append = (void*) &amp;amp;append,
    .prepend = (void*) &amp;amp;prepend,
    .traverse = (void*) &amp;amp;traverse
  };
}

const struct ListClass /*ListProxy*/ List = {
  .new = &amp;amp;new,
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=list.c&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;stdbool.h&amp;gt;  // for bool
#include &amp;lt;stdio.h&amp;gt;    // for printf

#define VA_ARGS(...) , ##__VA_ARGS__
#define CALL(obj, method, ...) ((obj).method(&amp;amp;(obj) VA_ARGS(__VA_ARGS__)))

void print(struct Node* node, bool is_float)
{
  if (!node) {
    return;
  }
  is_float ? printf(&amp;quot;%f&amp;quot;, *(float*)node-&amp;gt;data) :
             printf(&amp;quot;%d&amp;quot;, *(int*)node-&amp;gt;data);
  printf(&amp;quot;%s&amp;quot;, (node-&amp;gt;next) ? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot;\n&amp;quot;);
}

void print_int(struct Node* node)
{
  print(node, false);
}

void print_float(struct Node* node)
{
  print(node, true);
}

int main()
{
  int data_int[6] = { 11, 22, 33, 44, 55, 66 };
  float data_float[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  struct List l = /*ListProxy*/List.new();
  l.prepend(&amp;amp;l, &amp;amp;data_int[0], sizeof(data_int[0]));
  l.append(&amp;amp;l, &amp;amp;data_int[1], sizeof(data_int[1]));
  l.append(&amp;amp;l, &amp;amp;data_int[2], sizeof(data_int[2]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[3], sizeof(data_int[3]));
  l.append(&amp;amp;l, &amp;amp;data_int[4], sizeof(data_int[4]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[5], sizeof(data_int[5]));
  l.traverse(&amp;amp;l, print_int);
  l.destroy(&amp;amp;l);

  CALL(l, prepend,  &amp;amp;data_float[0], sizeof(data_float[0]));
  CALL(l, append,   &amp;amp;data_float[1], sizeof(data_float[1]));
  CALL(l, append,   &amp;amp;data_float[2], sizeof(data_float[2]));
  CALL(l, prepend,  &amp;amp;data_float[3], sizeof(data_float[3]));
  CALL(l, append,   &amp;amp;data_float[4], sizeof(data_float[4]));
  CALL(l, prepend,  &amp;amp;data_float[5], sizeof(data_float[5]));
  CALL(l, traverse, print_float);
  CALL(l, destroy);

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/31f11789bb859356daf05107e8fc859e.js?file=test.c&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;c-version&quot;&gt;C++ version&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef LIST_H
#define LIST_H

#include &amp;lt;assert.h&amp;gt; // for assert
#include &amp;lt;memory&amp;gt;   // for std::unique_ptr

template&amp;lt;typename T&amp;gt;
class List
{
public:
  struct Node // All it&amp;#39;s members are public by default.
  {
    Node(T aData, Node* aNext)
      : mData(aData)
      , mNext(aNext)
    {}

    ~Node() {}

    T mData;
    Node* mNext;
  };

  List();
  ~List();

  void Append(T aData);
  void Prepend(T aData);

  typedef void (*Callback)(Node* aNode);
  void Traverse(Callback aCallback);

private:
  // No need to use smart pointer in low-level data structure.
  // It&amp;#39;s more efficient for managing memory on our own.
  Node* mCursor;
  Node* mHead;
};

// nullptr is introduced in C++11.
template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List()
  : mCursor(nullptr)
  , mHead(nullptr)
{
}

template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
  for (mCursor = mHead ; mCursor != nullptr ;) {
    std::unique_ptr&amp;lt;Node&amp;gt; autoRelease(mCursor);
    // Update mCursor here instead of afterthought in for-loop,
    // in case mCursor is already released.
    mCursor = mCursor-&amp;gt;mNext;
    // The memory chuck pointed by old mCursor will be destroyed
    // upon leaving the &amp;#39;}&amp;#39;.
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Append(T aData)
{
  Node* n = new Node(aData, nullptr);
  if (!mHead) { // the list is empty.
    assert(!mCursor);
    mHead = n;
  } else {
    assert(mCursor);
    mCursor-&amp;gt;mNext = n;
  }
  mCursor = n;
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Prepend(T aData)
{
  Node* n = new Node(aData, mHead);
  mHead = n;
  if (!mCursor) { // The list is empty before inserting value.
    mCursor = n;
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Traverse(Callback aCallback)
{
  for (Node* cur = mHead ; cur != nullptr ; cur = cur-&amp;gt;mNext) {
    aCallback(cur);
  }
}

#endif // LIST_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473.js?file=list.h&quot;&gt; &lt;/script&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;list.h&amp;quot;
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
void Print(T aData, bool aBreakline)
{
  std::cout &amp;lt;&amp;lt; aData &amp;lt;&amp;lt; ((aBreakline)? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot;\n&amp;quot;);
}

void PrintInt(List&amp;lt;int&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

void PrintFloat(List&amp;lt;float&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

int main()
{
  int dataInt[6] = { 11, 22, 33, 44, 55, 66 };
  float dataFloat[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  List&amp;lt;int&amp;gt; li;
  li.Prepend(dataInt[0]);
  li.Append(dataInt[1]);
  li.Append(dataInt[2]);
  li.Prepend(dataInt[3]);
  li.Append(dataInt[4]);
  li.Prepend(dataInt[5]);
  li.Traverse(PrintInt);

  List&amp;lt;float&amp;gt; lf;
  lf.Prepend(dataFloat[0]);
  lf.Append(dataFloat[1]);
  lf.Append(dataFloat[2]);
  lf.Prepend(dataFloat[3]);
  lf.Append(dataFloat[4]);
  lf.Prepend(dataFloat[5]);
  lf.Traverse(PrintFloat);

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/8e04130e778d77e0b30b8954cc5f2473.js?file=test.cpp&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;comparison&quot;&gt;Comparison&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;The C version needs to call &lt;code class=&quot;highlighter-rouge&quot;&gt;destroy&lt;/code&gt; explicitly,
while the C++ version will automatically run deconstructor &lt;code class=&quot;highlighter-rouge&quot;&gt;~List()&lt;/code&gt;
to release the memory, or use smart pointers
like &lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt; to help memory management.
    &lt;ul&gt;
      &lt;li&gt;To release &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo* n = new Foo(...)&lt;/code&gt;, we need to use &lt;code class=&quot;highlighter-rouge&quot;&gt;delete n&lt;/code&gt;
instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;n-&amp;gt;~Foo()&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;Calling a destructor releases the resources owned by the object,
but it does not release the memory allocated to the object itself.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;We need to pass self pointer to the &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; structure
for calling functions to access list’s data,
while we don’t need to do that in C++ version
because class object can get all data inside itself in its implementation.&lt;/li&gt;
  &lt;li&gt;To allow storing different data type in the list,
the C++ version use &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;void*&lt;/code&gt; in the C version.
    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;void* data&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t size&lt;/code&gt;
is regarded as memory chunk beyond types,
pointed by &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; bytes,
so we can store different types data in &lt;strong&gt;runtime&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;While &lt;code class=&quot;highlighter-rouge&quot;&gt;template&amp;lt;typename T&amp;gt;&lt;/code&gt; let us to declare a variable
with type &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; in &lt;strong&gt;compile time&lt;/strong&gt;,
so &lt;em&gt;gcc/g++&lt;/em&gt; can help us for debugging if there is any error.
        &lt;ul&gt;
          &lt;li&gt;function with &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt; cannot be separated in &lt;code class=&quot;highlighter-rouge&quot;&gt;.cpp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;.h&lt;/code&gt;
because compiler needs to see both the template definition
and the specific types/whatever used to &lt;strong&gt;fill in&lt;/strong&gt; the template.
Please read &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl&quot; title=&quot;Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file&quot;&gt;this&lt;/a&gt; for more details.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Replace &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt; is always a pointer type. &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;(0) could cause ambiguity
when we have functions: &lt;code class=&quot;highlighter-rouge&quot;&gt;void f(int)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;void f(foo *)&lt;/code&gt;,
and we call &lt;code class=&quot;highlighter-rouge&quot;&gt;f(NULL)&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">How to simulate a C++ class in C

After learning C++, I am curious about
how could I bring the object-oriented style to C.
Could we simulate a C++ class by struct in C?

To find the answer,
I implement a simple linked list with object-oriented style in plain C.
The key is to use function pointer in struct to
simulate a C++ member function.
you can find my code here

To compare, I also implement a linked list in C++.

Class in C
#ifndef LIST_H
#define LIST_H

#include &amp;lt;stddef.h&amp;gt; // for size_t

struct Node {
  void* data; // Any data type can be stored in this node
  struct Node* next;
};

typedef void (*Callback)(struct Node* node);
struct List {
  struct Node* head;
  struct Node* cursor;

  void (* const destroy)(struct List* self);
  void (* const append)(struct List* self, void* data, size_t size);
  void (* const prepend)(struct List* self, void* data, size_t size);
  void (* const traverse)(struct List* self, Callback func);
};

extern const struct ListClass {
  struct List (*new)();
} /*ListProxy*/ List;

#endif // LIST_H


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;assert.h&amp;gt; // for assert
// #include &amp;lt;stddef.h&amp;gt; // for NULL, size_t, they are already included in list.h
#include &amp;lt;stdlib.h&amp;gt; // for calloc, free
#include &amp;lt;string.h&amp;gt; // for memcpy

// Using &amp;quot;static&amp;quot; prevents these functions from being exposed outside.

static void
destroy(struct List* self)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ;) {
    struct Node* next = cur-&amp;gt;next;
    free(cur-&amp;gt;data);
    free(cur);
    cur = next;
  }
  self-&amp;gt;head = self-&amp;gt;cursor = NULL;
}

static void
append(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = NULL;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  if (!self-&amp;gt;head) { // The list is empty.
    assert(!self-&amp;gt;cursor); // cursor = head = NULL now.
    self-&amp;gt;head = n;
  } else {
    assert(self-&amp;gt;cursor);
    self-&amp;gt;cursor-&amp;gt;next = n;
  }
  self-&amp;gt;cursor = n;
}

static void
prepend(struct List* self, void* data, size_t size) {
  struct Node* n = (struct Node*)calloc(1, sizeof(struct Node));
  assert(n);

  n-&amp;gt;next = self-&amp;gt;head;
  n-&amp;gt;data = calloc(1, size);
  assert(n-&amp;gt;data);
  memcpy(n-&amp;gt;data, data, size);

  self-&amp;gt;head = n;
  if(!self-&amp;gt;cursor) { // The list is empty before inserting value.
    self-&amp;gt;cursor = n;
  }
}

static void
traverse(struct List* self, Callback func)
{
  for (struct Node* cur = self-&amp;gt;head ; cur != NULL ; cur = cur-&amp;gt;next) {
    func(cur);
  }
}

static struct List
new()
{
  return (struct List) {
    .head = NULL,
    .cursor = NULL,
    .destroy = (void*) &amp;amp;destroy,
    .append = (void*) &amp;amp;append,
    .prepend = (void*) &amp;amp;prepend,
    .traverse = (void*) &amp;amp;traverse
  };
}

const struct ListClass /*ListProxy*/ List = {
  .new = &amp;amp;new,
};


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;stdbool.h&amp;gt;  // for bool
#include &amp;lt;stdio.h&amp;gt;    // for printf

#define VA_ARGS(...) , ##__VA_ARGS__
#define CALL(obj, method, ...) ((obj).method(&amp;amp;(obj) VA_ARGS(__VA_ARGS__)))

void print(struct Node* node, bool is_float)
{
  if (!node) {
    return;
  }
  is_float ? printf(&amp;quot;%f&amp;quot;, *(float*)node-&amp;gt;data) :
             printf(&amp;quot;%d&amp;quot;, *(int*)node-&amp;gt;data);
  printf(&amp;quot;%s&amp;quot;, (node-&amp;gt;next) ? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot; &amp;quot;);
}

void print_int(struct Node* node)
{
  print(node, false);
}

void print_float(struct Node* node)
{
  print(node, true);
}

int main()
{
  int data_int[6] = { 11, 22, 33, 44, 55, 66 };
  float data_float[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  struct List l = /*ListProxy*/List.new();
  l.prepend(&amp;amp;l, &amp;amp;data_int[0], sizeof(data_int[0]));
  l.append(&amp;amp;l, &amp;amp;data_int[1], sizeof(data_int[1]));
  l.append(&amp;amp;l, &amp;amp;data_int[2], sizeof(data_int[2]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[3], sizeof(data_int[3]));
  l.append(&amp;amp;l, &amp;amp;data_int[4], sizeof(data_int[4]));
  l.prepend(&amp;amp;l, &amp;amp;data_int[5], sizeof(data_int[5]));
  l.traverse(&amp;amp;l, print_int);
  l.destroy(&amp;amp;l);

  CALL(l, prepend,  &amp;amp;data_float[0], sizeof(data_float[0]));
  CALL(l, append,   &amp;amp;data_float[1], sizeof(data_float[1]));
  CALL(l, append,   &amp;amp;data_float[2], sizeof(data_float[2]));
  CALL(l, prepend,  &amp;amp;data_float[3], sizeof(data_float[3]));
  CALL(l, append,   &amp;amp;data_float[4], sizeof(data_float[4]));
  CALL(l, prepend,  &amp;amp;data_float[5], sizeof(data_float[5]));
  CALL(l, traverse, print_float);
  CALL(l, destroy);

  return 0;
}


C++ version
#ifndef LIST_H
#define LIST_H

#include &amp;lt;assert.h&amp;gt; // for assert
#include &amp;lt;memory&amp;gt;   // for std::unique_ptr

template&amp;lt;typename T&amp;gt;
class List
{
public:
  struct Node // All it&amp;#39;s members are public by default.
  {
    Node(T aData, Node* aNext)
      : mData(aData)
      , mNext(aNext)
    {}

    ~Node() {}

    T mData;
    Node* mNext;
  };

  List();
  ~List();

  void Append(T aData);
  void Prepend(T aData);

  typedef void (*Callback)(Node* aNode);
  void Traverse(Callback aCallback);

private:
  // No need to use smart pointer in low-level data structure.
  // It&amp;#39;s more efficient for managing memory on our own.
  Node* mCursor;
  Node* mHead;
};

// nullptr is introduced in C++11.
template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List()
  : mCursor(nullptr)
  , mHead(nullptr)
{
}

template&amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
  for (mCursor = mHead ; mCursor != nullptr ;) {
    std::unique_ptr&amp;lt;Node&amp;gt; autoRelease(mCursor);
    // Update mCursor here instead of afterthought in for-loop,
    // in case mCursor is already released.
    mCursor = mCursor-&amp;gt;mNext;
    // The memory chuck pointed by old mCursor will be destroyed
    // upon leaving the &amp;#39;}&amp;#39;.
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Append(T aData)
{
  Node* n = new Node(aData, nullptr);
  if (!mHead) { // the list is empty.
    assert(!mCursor);
    mHead = n;
  } else {
    assert(mCursor);
    mCursor-&amp;gt;mNext = n;
  }
  mCursor = n;
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Prepend(T aData)
{
  Node* n = new Node(aData, mHead);
  mHead = n;
  if (!mCursor) { // The list is empty before inserting value.
    mCursor = n;
  }
}

template&amp;lt;typename T&amp;gt;
void
List&amp;lt;T&amp;gt;::Traverse(Callback aCallback)
{
  for (Node* cur = mHead ; cur != nullptr ; cur = cur-&amp;gt;mNext) {
    aCallback(cur);
  }
}

#endif // LIST_H


#include &amp;quot;list.h&amp;quot;
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
void Print(T aData, bool aBreakline)
{
  std::cout &amp;lt;&amp;lt; aData &amp;lt;&amp;lt; ((aBreakline)? &amp;quot;-&amp;gt;&amp;quot; : &amp;quot; &amp;quot;);
}

void PrintInt(List&amp;lt;int&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

void PrintFloat(List&amp;lt;float&amp;gt;::Node* aNode)
{
  Print(aNode-&amp;gt;mData, aNode-&amp;gt;mNext);
}

int main()
{
  int dataInt[6] = { 11, 22, 33, 44, 55, 66 };
  float dataFloat[6] = { 1.1f, 2.2f, 3.3f, 4.4f, 5.5f, 6.6f };

  List&amp;lt;int&amp;gt; li;
  li.Prepend(dataInt[0]);
  li.Append(dataInt[1]);
  li.Append(dataInt[2]);
  li.Prepend(dataInt[3]);
  li.Append(dataInt[4]);
  li.Prepend(dataInt[5]);
  li.Traverse(PrintInt);

  List&amp;lt;float&amp;gt; lf;
  lf.Prepend(dataFloat[0]);
  lf.Append(dataFloat[1]);
  lf.Append(dataFloat[2]);
  lf.Prepend(dataFloat[3]);
  lf.Append(dataFloat[4]);
  lf.Prepend(dataFloat[5]);
  lf.Traverse(PrintFloat);

  return 0;
}


Comparison

  The C version needs to call destroy explicitly,
while the C++ version will automatically run deconstructor ~List()
to release the memory, or use smart pointers
like unique_ptr to help memory management.
    
      To release Foo* n = new Foo(...), we need to use delete n
instead of n-&amp;gt;~Foo()
        
          Calling a destructor releases the resources owned by the object,
but it does not release the memory allocated to the object itself.
        
      
    
  
  We need to pass self pointer to the List structure
for calling functions to access list’s data,
while we don’t need to do that in C++ version
because class object can get all data inside itself in its implementation.
  To allow storing different data type in the list,
the C++ version use template instead of void* in the C version.
    
      The void* data with size_t size
is regarded as memory chunk beyond types,
pointed by data with size bytes,
so we can store different types data in runtime.
      While template&amp;lt;typename T&amp;gt; let us to declare a variable
with type T in compile time,
so gcc/g++ can help us for debugging if there is any error.
        
          function with template cannot be separated in .cpp and .h
because compiler needs to see both the template definition
and the specific types/whatever used to fill in the template.
Please read this for more details.
        
      
    
  
  Replace NULL with nullptr
    
      nullptr is always a pointer type. NULL(0) could cause ambiguity
when we have functions: void f(int), void f(foo *),
and we call f(NULL).</summary></entry><entry><title type="html">How to avoid duplicate symbols when compiling</title><link href="http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling" rel="alternate" type="text/html" title="How to avoid duplicate symbols when compiling" /><published>2017-04-08T00:00:00+08:00</published><updated>2017-04-08T00:00:00+08:00</updated><id>http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling</id><content type="html" xml:base="http://localhost:4000/post/how-to-avoid-duplicate-symbols-when-compiling">&lt;h1 id=&quot;how-to-avoid-duplicatesymbols-when-compiling&quot;&gt;How to avoid duplicate symbols when compiling&lt;/h1&gt;

&lt;p&gt;The error: &lt;code class=&quot;highlighter-rouge&quot;&gt;duplicate symbol for architecture x86_64&lt;/code&gt; will be prompted
if the following &lt;a href=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276&quot; title=&quot;gist&quot;&gt;files&lt;/a&gt; are compiled.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;makefile&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;CXX=g++
CFLAGS=-Wall
EXEC=run

all: bye.o hello.o
	$(CXX) $(CFLAGS) main.cpp bye.o hello.o -o $(EXEC)

bye.o: bye.cpp
	$(CXX) -c $(CFLAGS) bye.cpp

hello.o: hello.cpp
	$(CXX) -c $(CFLAGS) hello.cpp

clean:
	rm $(EXEC) *.o
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=makefile&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;main.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;hello.h&amp;quot;

int main()
{
  SayHello();
  SayBye();
  return 0;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=main.cpp&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;utils.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef UTILS_H
#define UTILS_H

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}

#endif /* UTILS_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=utils.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;hello.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef HELLO_H
#define HELLO_H

void SayHello();

#endif /* HELLO_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=hello.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;hello.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;hello.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayHello()
{
  LOG(&amp;quot;Hello&amp;quot;);
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=hello.cpp&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;bye.h&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#ifndef BYE_H
#define BYE_H

void SayBye();

#endif /* BYE_H */
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=bye.h&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;bye.cpp&lt;/li&gt;
&lt;/ul&gt;
&lt;noscript&gt;&lt;pre&gt;#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayBye()
{
  LOG(&amp;quot;Goodbye&amp;quot;);
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/553962a80ac4d873454597d82227c276.js?file=bye.cpp&quot;&gt; &lt;/script&gt;

&lt;p&gt;You will see the &lt;code class=&quot;highlighter-rouge&quot;&gt;duplicate symbol for architecture x86_64&lt;/code&gt; error
when you compile those files.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
g++ -c -Wall bye.cpp
g++ -c -Wall hello.cpp
g++ -Wall main.cpp bye.o hello.o -o run
duplicate symbol __Z3LOGNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE in:
    bye.o
    hello.o
ld: 1 duplicate symbol for architecture x86_64
clang: error: linker command failed with exit code 1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use -v to see invocation&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
make: &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; [all] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The reason is that we include the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;utils.h&lt;/code&gt;)
into different files(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.cpp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.cpp&lt;/code&gt;),
and compile those files into different libraries(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.o&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.o&lt;/code&gt;),
so the functions in the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt;)
duplicate in those different libraries.&lt;/p&gt;

&lt;p&gt;Thus, when we try using those different libraries(&lt;code class=&quot;highlighter-rouge&quot;&gt;bye.o&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.o&lt;/code&gt;)
at the same time, there are duplicated symbols for functions(&lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt;)
included from the shared header(&lt;code class=&quot;highlighter-rouge&quot;&gt;utils.h&lt;/code&gt;).
The program has no idea about which one it should call
among those duplicated symbols.&lt;/p&gt;

&lt;h2 id=&quot;solution-1-using-macros-instead-of-functions&quot;&gt;Solution 1: Using macros instead of functions&lt;/h2&gt;
&lt;p&gt;The macro is only textual substitution that expanded by the preprocessor,
so there is no symbol generated.&lt;/p&gt;

&lt;p&gt;You can replace function &lt;code class=&quot;highlighter-rouge&quot;&gt;LOG&lt;/code&gt; by&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define LOG(s) (std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then the &lt;code class=&quot;highlighter-rouge&quot;&gt;SayBye()&lt;/code&gt; will be expanded into:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SayBye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Goodbye&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can run: &lt;code class=&quot;highlighter-rouge&quot;&gt;$ g++ -E &amp;lt;file_name&amp;gt;.cpp&lt;/code&gt; to watch
and confirm the preprocessor’s output.&lt;/p&gt;

&lt;h2 id=&quot;solution-2-make-functions-inline&quot;&gt;Solution 2: Make functions &lt;strong&gt;inline&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;It works almost same as macro.
Inline functions are actual functions
whose copy of the function body are injected directly into
each place the function is called.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The insertion occurs only if
the compiler’s cost/benefit analysis shows it to be profitable.
Same as the macros, inline expansion eliminates
the overhead associated with function calls.&lt;/p&gt;

&lt;p&gt;Inline functions are parsed by the compiler,
whereas macros are expanded by the preprocessor.
The preprocessor macros are just substitution patterns in code
before the compilation,
so there is no &lt;strong&gt;type-checking&lt;/strong&gt; at that time.
While inline functions are actual functions, so compiler can keep an eye on
type-checking issues to help debugging.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://chunminchang.gitbooks.io/cplusplus-learning-note/content/Appendix/preprocessor_macros_vs_inline_functions.html#inline-functions&quot; title=&quot;Inline functions&quot;&gt;here&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&quot;solution-3-using-static-to-make-functions-local-in-each-file&quot;&gt;Solution 3: Using &lt;strong&gt;static&lt;/strong&gt; to make functions local in each file&lt;/h2&gt;
&lt;p&gt;Since their states are &lt;strong&gt;not&lt;/strong&gt; sharable,
they should &lt;strong&gt;not&lt;/strong&gt; visible across each other.
Thus, the generated symbols are also local in each file.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Common" /><category term="C/C++" /><summary type="html">How to avoid duplicate symbols when compiling

The error: duplicate symbol for architecture x86_64 will be prompted
if the following files are compiled.


  makefile

CXX=g++
CFLAGS=-Wall
EXEC=run

all: bye.o hello.o
	$(CXX) $(CFLAGS) main.cpp bye.o hello.o -o $(EXEC)

bye.o: bye.cpp
	$(CXX) -c $(CFLAGS) bye.cpp

hello.o: hello.cpp
	$(CXX) -c $(CFLAGS) hello.cpp

clean:
	rm $(EXEC) *.o




  main.cpp

#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;hello.h&amp;quot;

int main()
{
  SayHello();
  SayBye();
  return 0;
}




  utils.h

#ifndef UTILS_H
#define UTILS_H

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}

#endif /* UTILS_H */




  hello.h

#ifndef HELLO_H
#define HELLO_H

void SayHello();

#endif /* HELLO_H */




  hello.cpp

#include &amp;quot;hello.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayHello()
{
  LOG(&amp;quot;Hello&amp;quot;);
}




  bye.h

#ifndef BYE_H
#define BYE_H

void SayBye();

#endif /* BYE_H */




  bye.cpp

#include &amp;quot;bye.h&amp;quot;
#include &amp;quot;utils.h&amp;quot;

void SayBye()
{
  LOG(&amp;quot;Goodbye&amp;quot;);
}



You will see the duplicate symbol for architecture x86_64 error
when you compile those files.
$ make
g++ -c -Wall bye.cpp
g++ -c -Wall hello.cpp
g++ -Wall main.cpp bye.o hello.o -o run
duplicate symbol __Z3LOGNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE in:
    bye.o
    hello.o
ld: 1 duplicate symbol for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [all] Error 1



The reason is that we include the shared header(utils.h)
into different files(bye.cpp and hello.cpp),
and compile those files into different libraries(bye.o and hello.o),
so the functions in the shared header(LOG)
duplicate in those different libraries.

Thus, when we try using those different libraries(bye.o and hello.o)
at the same time, there are duplicated symbols for functions(LOG)
included from the shared header(utils.h).
The program has no idea about which one it should call
among those duplicated symbols.

Solution 1: Using macros instead of functions
The macro is only textual substitution that expanded by the preprocessor,
so there is no symbol generated.

You can replace function LOG by
#define LOG(s) (std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl)



Then the SayBye() will be expanded into:
void SayBye()
{
  (std::cout &amp;lt;&amp;lt; &quot;Goodbye&quot; &amp;lt;&amp;lt; std::endl);
}



You can run: $ g++ -E &amp;lt;file_name&amp;gt;.cpp to watch
and confirm the preprocessor’s output.

Solution 2: Make functions inline
It works almost same as macro.
Inline functions are actual functions
whose copy of the function body are injected directly into
each place the function is called.

inline void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}



The insertion occurs only if
the compiler’s cost/benefit analysis shows it to be profitable.
Same as the macros, inline expansion eliminates
the overhead associated with function calls.

Inline functions are parsed by the compiler,
whereas macros are expanded by the preprocessor.
The preprocessor macros are just substitution patterns in code
before the compilation,
so there is no type-checking at that time.
While inline functions are actual functions, so compiler can keep an eye on
type-checking issues to help debugging.

See here for more details.

Solution 3: Using static to make functions local in each file
Since their states are not sharable,
they should not visible across each other.
Thus, the generated symbols are also local in each file.

static void LOG(std::string s)
{
  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
}</summary></entry><entry><title type="html">Running multiple Firefox at the same time</title><link href="http://localhost:4000/post/running-multiple-firefox-at-the-same-time" rel="alternate" type="text/html" title="Running multiple Firefox at the same time" /><published>2017-03-30T00:00:00+08:00</published><updated>2017-03-30T00:00:00+08:00</updated><id>http://localhost:4000/post/running-multiple-firefox-at-the-same-time</id><content type="html" xml:base="http://localhost:4000/post/running-multiple-firefox-at-the-same-time">&lt;h1 id=&quot;running-multiple-firefox-at-the-same-time&quot;&gt;Running multiple Firefox at the same time&lt;/h1&gt;

&lt;p&gt;I have two firefox: Firefox(normal version) and Firefox Developer Edition.
Today morning, I deleted the Firefox Developer Edition by &lt;em&gt;AppCleaner&lt;/em&gt;
and re-installed it, then something weird happened.&lt;/p&gt;

&lt;p&gt;When I opened the new Firefox Developer Edition
then launched my unchanged Firefox, the Firefox cannot be opened
and it showed an error: &lt;strong&gt;A copy of Firefox is already open.
Only one copy of Firefox an be opened at a time.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/a-copy-of-firefox-is-alreay-open.png&quot; alt=&quot;&quot; title=&quot;A copy of Firefox is already open&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AFAIK, the multiple Firefox instances are able to run at the same time,
if they use &lt;strong&gt;different profiles&lt;/strong&gt;.
Therefore, I opened &lt;code class=&quot;highlighter-rouge&quot;&gt;about:profiles&lt;/code&gt; on Firefox to check it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/firefox-about-profiles-wrong.png&quot; alt=&quot;&quot; title=&quot;Firefox - about:profiles(incorrect)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;From above, the setting was incorrect.
It should use &lt;em&gt;Profile: default&lt;/em&gt; instead of &lt;em&gt;Profile: dev-edition-default&lt;/em&gt;.
That’s why I cannot open Firefox and FirefoxDeveloperEdition at the same time.&lt;/p&gt;

&lt;p&gt;To fix the problem, I simply click &lt;em&gt;Set a default profile&lt;/em&gt;
under &lt;em&gt;Profile: default&lt;/em&gt;, then closed it, and relaunched it to check the setting.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/firefox-about-profiles-right.png&quot; alt=&quot;&quot; title=&quot;Firefox - about:profiles(correct)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I also checked the FirefoxDeveloperEdition’s setting
to make sure everything is fine.
&lt;img src=&quot;../images/posts/firefoxdeveloperedition-about-profiles.png&quot; alt=&quot;&quot; title=&quot;FirefoxDeveloperEdition - about:profiles&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I wrote this to remember how I fix it,
in case the same problem happens again.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Firefox" /><summary type="html">Running multiple Firefox at the same time

I have two firefox: Firefox(normal version) and Firefox Developer Edition.
Today morning, I deleted the Firefox Developer Edition by AppCleaner
and re-installed it, then something weird happened.

When I opened the new Firefox Developer Edition
then launched my unchanged Firefox, the Firefox cannot be opened
and it showed an error: A copy of Firefox is already open.
Only one copy of Firefox an be opened at a time.



AFAIK, the multiple Firefox instances are able to run at the same time,
if they use different profiles.
Therefore, I opened about:profiles on Firefox to check it.



From above, the setting was incorrect.
It should use Profile: default instead of Profile: dev-edition-default.
That’s why I cannot open Firefox and FirefoxDeveloperEdition at the same time.

To fix the problem, I simply click Set a default profile
under Profile: default, then closed it, and relaunched it to check the setting.



I also checked the FirefoxDeveloperEdition’s setting
to make sure everything is fine.


I wrote this to remember how I fix it,
in case the same problem happens again.</summary></entry></feed>
