<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-12-22T11:58:35+08:00</updated><id>http://localhost:4000//</id><title type="html">Peak Up</title><subtitle>everyday surpass myself</subtitle><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><entry><title type="html">Running Average</title><link href="http://localhost:4000/post/running-average" rel="alternate" type="text/html" title="Running Average" /><published>2017-12-21T00:00:00+08:00</published><updated>2017-12-21T00:00:00+08:00</updated><id>http://localhost:4000/post/running-average</id><content type="html" xml:base="http://localhost:4000/post/running-average">&lt;p&gt;Preventing overflow is essential
while calculating the average of a long series of data.
One simplest method to avoid the problem is &lt;em&gt;running average&lt;/em&gt;
(or &lt;em&gt;moving average&lt;/em&gt;, &lt;em&gt;rolling average&lt;/em&gt;, &lt;em&gt;incremental mean&lt;/em&gt;).&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Suppose we have data &lt;script type=&quot;math/tex&quot;&gt;x_1, x_2, \cdots, x_n&lt;/script&gt;
and the new data &lt;script type=&quot;math/tex&quot;&gt;x_{n+1}&lt;/script&gt; will lead to overflow to &lt;script type=&quot;math/tex&quot;&gt;sum_{n+1}&lt;/script&gt;,
where &lt;script type=&quot;math/tex&quot;&gt;sum_i = x_1 + x_2 + \cdots + x_i&lt;/script&gt;.
When &lt;script type=&quot;math/tex&quot;&gt;x_{n+1}&lt;/script&gt; comes, &lt;script type=&quot;math/tex&quot;&gt;sum_{n+1}&lt;/script&gt; will overflow
so &lt;script type=&quot;math/tex&quot;&gt;\mu_{n+1} = \frac{sum_{n+1}}{n+1}&lt;/script&gt; will be wrong,
where &lt;script type=&quot;math/tex&quot;&gt;\mu_i&lt;/script&gt; is the average of &lt;script type=&quot;math/tex&quot;&gt;x_1, x_2, \cdots, x_i&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;How could we solve the problem?&lt;/p&gt;

&lt;h2 id=&quot;naive-approach&quot;&gt;Naive Approach&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Overflow!
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetAverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above approach to prevent overflow
is extracted from &lt;a href=&quot;https://searchfox.org/mozilla-central/rev/f5f1c3f294f89cfd242c3af9eb2c40d19d5e04e7/dom/media/mp3/MP3Demuxer.cpp#709-715,720,728,756-760&quot; title=&quot;Wrong calculation for mp3 time length as we prevent overflow&quot;&gt;Gecko MP3Demuxer&lt;/a&gt;,
but it’s &lt;strong&gt;wrong&lt;/strong&gt; in most cases
(it’s only correct when every incoming data is same).
For example, if we have &lt;script type=&quot;math/tex&quot;&gt;x_1 = 10, x_2 = 20&lt;/script&gt;
and &lt;script type=&quot;math/tex&quot;&gt;x_3 = 90&lt;/script&gt; will lead to overflow to the sum of &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt;
so the average computed by above approach will be &lt;script type=&quot;math/tex&quot;&gt;\frac{(10+20)/2 + 90}{2/2 + 1} = 52.5&lt;/script&gt;,
which is different from &lt;script type=&quot;math/tex&quot;&gt;\frac{10 + 20 + 90}{3} = 40&lt;/script&gt;.
I cannot believe this incorrect code
lives in Firefox &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1093815&quot;&gt;more than 3 years&lt;/a&gt;.
Fortunately, the overflow happens once in a blue moon
so it’s not too much trouble.&lt;/p&gt;

&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;/h3&gt;
&lt;p&gt;We can formally prove the above approach is incorrect.
Let &lt;script type=&quot;math/tex&quot;&gt;sum_{k}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\mu_k&lt;/script&gt; be the &lt;strong&gt;sum&lt;/strong&gt; and &lt;strong&gt;arithmetic mean&lt;/strong&gt;
of &lt;script type=&quot;math/tex&quot;&gt;x_1, x_2, \cdots, x_k&lt;/script&gt; respectively, and &lt;script type=&quot;math/tex&quot;&gt;E_k&lt;/script&gt; be the estimated average
from above approach.&lt;/p&gt;

&lt;p&gt;Since the new incoming data &lt;script type=&quot;math/tex&quot;&gt;x_{n+1}&lt;/script&gt; will cause overflow to &lt;script type=&quot;math/tex&quot;&gt;sum_{n+1}&lt;/script&gt;, so&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;E_{n+1} = \frac{p + x_{n+1}}{q + 1}&lt;/script&gt;
, where
&lt;script type=&quot;math/tex&quot;&gt;p = \frac{sum_{n}}{2} = \frac{x_1 + x_2 + \cdots + x_n}{2}&lt;/script&gt;
and
&lt;script type=&quot;math/tex&quot;&gt;q = \frac{n}{2}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;As a result,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
E_{n+1}
&amp;= \frac{p + x_{n+1}}{q + 1} \\
&amp;= \frac{\frac{x_1 + x_2 + \cdots + x_n}{2} + x_{n+1}}{\frac{n}{2} + 1} \\
&amp;= \frac{\frac{x_1 + x_2 + \cdots + x_n + 2 \cdot x_{n+1}}{2}}{\frac{n + 2}{2}} \\
&amp;= \frac{x_1 + x_2 + \cdots + x_n + 2 \cdot x_{n+1}}{n+2}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We could compare &lt;script type=&quot;math/tex&quot;&gt;E_{n+1}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\mu_{n+1}&lt;/script&gt; to see if they are equal:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\mu_{n+1}
&amp;= \frac{x_1 + x_2 + \cdots + x_n + x_{n+1}}{n+1} \\
&amp;= \frac{(n+2) \cdot (x_1 + x_2 + \cdots + x_n + x_{n+1})}{(n+1) \cdot (n+2)} \\
&amp;= \frac{(n+1) \cdot (x_1 + x_2 + \cdots + x_n + x_{n+1}) + (x_1 + x_2 + \cdots + x_n + x_{n+1})}{(n+1) \cdot (n+2)}
\\
E_{n+1}
&amp;= \frac{x_1 + x_2 + \cdots + x_n + 2 \cdot x_{n+1}}{n+2} \\
&amp;= \frac{(x_1 + x_2 + \cdots + x_n + x_{n+1}) + x_{n+1}}{n+2} \\
&amp;= \frac{(n+1) \cdot ((x_1 + x_2 + \cdots + x_n + x_{n+1}) + x_{n+1})}{(n+1) \cdot (n+2)} \\
&amp;= \frac{(n+1) \cdot (x_1 + x_2 + \cdots + x_n + x_{n+1}) + (n+1) \cdot x_{n+1}}{(n+1) \cdot (n+2)} \\
&amp;= \frac{(n+1) \cdot (x_1 + x_2 + \cdots + x_n + x_{n+1}) + (\overbrace{x_{n+1} + \cdots + x_{n+1}}^{n+1}))}{(n+1) \cdot (n+2)}
\\
\mu_{n+1} - E_{n+1}
&amp;= \frac{ (x_1 + x_2 + \cdots + x_n + x_{n+1}) - (\overbrace{x_{n+1} + \cdots + x_{n+1}}^{n+1}))}{(n+1) \cdot (n+2)} \\
&amp;= \frac{ (x_1 - x_{n+1}) + (x_2 - x_{n+1}) + \cdots +  (x_n - x_{n+1}) + (x_{n+1} - x_{n+1})}{(n+1) \cdot (n+2)} \\
&amp;= \frac{ (x_1 - x_{n+1}) + (x_2 - x_{n+1}) + \cdots +  (x_n - x_{n+1}) }{(n+1) \cdot (n+2)}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, we can clearly see that
&lt;script type=&quot;math/tex&quot;&gt;\mu_{n+1}&lt;/script&gt; will be equal to &lt;script type=&quot;math/tex&quot;&gt;E_{n+1}&lt;/script&gt;
&lt;strong&gt;only&lt;/strong&gt; when &lt;script type=&quot;math/tex&quot;&gt;x_1 = x_2 = \cdots = x_n = x_{n+1}&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;running-average&quot;&gt;Running Average&lt;/h2&gt;

&lt;p&gt;In fact, the average can be calculated
without using the overflowed &lt;script type=&quot;math/tex&quot;&gt;sum_{n+1}&lt;/script&gt;.
Let &lt;script type=&quot;math/tex&quot;&gt;\mu_n&lt;/script&gt; be the mean of &lt;script type=&quot;math/tex&quot;&gt;x_1, x_2, \cdots, x_n&lt;/script&gt;,
we can get &lt;script type=&quot;math/tex&quot;&gt;\mu_n&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;\mu_{n-1}&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\mu_n
&amp;= \frac{ \mu_{n-1} \cdot (n-1) + x_n }{ n } \\
&amp;= \frac{ n \cdot \mu_{n-1} + x_n - \mu_{n-1}}{ n } \\
&amp;= \mu_{n-1} + \frac{ x_n - \mu_{n-1} }{ n }
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;sample-code&quot;&gt;Sample code&lt;/h3&gt;

&lt;p&gt;On this ground, we could correct the &lt;a href=&quot;https://gist.github.com/ChunMinChang/a1d7533859dba59a1701d1d42c29bf82&quot; title=&quot;Calculating average without sum&quot;&gt;code&lt;/a&gt; into:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetAverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UpdateAverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Averager&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Averager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Averager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetAverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1423834&quot; title=&quot;Bug 1423834 - Wrong calculation for mp3 time length as we prevent overflow&quot;&gt;Bug 1423834&lt;/a&gt; is filed for this problem
when I was tracing &lt;a href=&quot;https://searchfox.org/mozilla-central/rev/f5f1c3f294f89cfd242c3af9eb2c40d19d5e04e7/dom/media/mp3/MP3Demuxer.cpp#709-715,720,728,756-760&quot; title=&quot;Wrong calculation for mp3 time length as we prevent overflow&quot;&gt;MP3Demuxer&lt;/a&gt;.
You could find more detail there.&lt;/p&gt;

&lt;p&gt;The following links are some related resources:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;Moving average on Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://math.stackexchange.com/questions/106700/incremental-averageing&quot;&gt;Incremental averageing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3316261/prevent-long-running-averaging-from-overflow&quot;&gt;Prevent long running averaging from overflow?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Algorithm&quot;, &quot;Math&quot;]" /><category term="Firefox" /><summary type="html">Preventing overflow is essential
while calculating the average of a long series of data.
One simplest method to avoid the problem is running average
(or moving average, rolling average, incremental mean).

Problem
Suppose we have data 
and the new data  will lead to overflow to ,
where .
When  comes,  will overflow
so  will be wrong,
where  is the average of .

How could we solve the problem?

Naive Approach

uint64_t count = 0;
uint64_t sum = 0;

void Add(uint64_t data)
{
  if (sum + data &amp;lt; sum) { // Overflow!
    sum = sum / 2;
    count = count / 2;
  }

  sum += data;
  ++count;
}

double GetAverage()
{
  return static_cast&amp;lt;double&amp;gt;(sum) / count;
}



The above approach to prevent overflow
is extracted from Gecko MP3Demuxer,
but it’s wrong in most cases
(it’s only correct when every incoming data is same).
For example, if we have 
and  will lead to overflow to the sum of 
so the average computed by above approach will be ,
which is different from .
I cannot believe this incorrect code
lives in Firefox more than 3 years.
Fortunately, the overflow happens once in a blue moon
so it’s not too much trouble.

Proof
We can formally prove the above approach is incorrect.
Let  and  be the sum and arithmetic mean
of  respectively, and  be the estimated average
from above approach.

Since the new incoming data  will cause overflow to , so


, where

and


As a result,



We could compare  and  to see if they are equal:



Thus, we can clearly see that
 will be equal to 
only when .

Running Average

In fact, the average can be calculated
without using the overflowed .
Let  be the mean of ,
we can get  by :



Sample code

On this ground, we could correct the code into:

double average = 0;
uint64_t count = 0;
void Add(uint64_t data)
{
  average += (data - average) / ++count;
}

double GetAverage()
{
  return average;
}



or

double UpdateAverage(uint64_t data)
{
  static double average = 0;
  static uint64_t count = 0;
  average += (data - average) / ++count;
  return average;
}



or

class Averager
{
public:
  Averager()
    : average(0)
    , count(0)
  {}

  ~Averager() {};

  void Add(uint64_t data) { average += (data - average) / ++count; }

  double GetAverage() { return average; }

private:
  double average;
  uint64_t count;
}



References

Bug 1423834 is filed for this problem
when I was tracing MP3Demuxer.
You could find more detail there.

The following links are some related resources:

  Moving average on Wiki
  Incremental averageing
  Prevent long running averaging from overflow?</summary></entry><entry><title type="html">Estimation of MP3 Duration</title><link href="http://localhost:4000/post/estimation-of-mp3-duration" rel="alternate" type="text/html" title="Estimation of MP3 Duration" /><published>2017-12-19T00:00:00+08:00</published><updated>2017-12-19T00:00:00+08:00</updated><id>http://localhost:4000/post/estimation-of-mp3-duration</id><content type="html" xml:base="http://localhost:4000/post/estimation-of-mp3-duration">&lt;p&gt;To calculate the duration of one &lt;em&gt;MP3&lt;/em&gt; file,
we need to know how it is encoded first.
The estimation for the durtation is different
based on how they are encoded.&lt;/p&gt;

&lt;h2 id=&quot;cbrconstant-bitrate-vs-vbrvariable-bitrate-encoding&quot;&gt;CBR(Constant Bitrate) vs VBR(Variable Bitrate) Encoding&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;MP3&lt;/em&gt; can be encoded either with &lt;strong&gt;constant bitrate&lt;/strong&gt;(&lt;strong&gt;CBR&lt;/strong&gt;)
or &lt;strong&gt;variable bitrate&lt;/strong&gt;(&lt;strong&gt;VBR&lt;/strong&gt;).
The quality of the &lt;em&gt;MP3&lt;/em&gt; encoded with &lt;em&gt;VBR&lt;/em&gt; is better than one with &lt;em&gt;CBR&lt;/em&gt;
since each frame can adopt different bitrate where the music needs it,
while the &lt;em&gt;CBR&lt;/em&gt; file uses same bitrate regardless of what sound wave is.&lt;/p&gt;

&lt;h2 id=&quot;how-to-know-whether-the-file-is-cbr-or-vbr&quot;&gt;How to know whether the file is CBR or VBR&lt;/h2&gt;

&lt;p&gt;There are two types for the &lt;em&gt;MP3&lt;/em&gt; header, &lt;strong&gt;Xing&lt;/strong&gt; and &lt;strong&gt;VBRI&lt;/strong&gt;.
The &lt;em&gt;ID&lt;/em&gt; of the &lt;em&gt;Xing&lt;/em&gt; header is either &lt;strong&gt;Xing&lt;/strong&gt; or &lt;strong&gt;Info&lt;/strong&gt;;
The &lt;em&gt;ID&lt;/em&gt; of &lt;em&gt;VBRI&lt;/em&gt; header is &lt;strong&gt;VBRI&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;If the &lt;em&gt;ID&lt;/em&gt; of &lt;em&gt;Xing&lt;/em&gt; header is &lt;strong&gt;Info&lt;/strong&gt;,
then it is definitely encoded with &lt;em&gt;CBR&lt;/em&gt;.
Nevertheless, &lt;em&gt;CBR&lt;/em&gt; is a special case of &lt;em&gt;VBR&lt;/em&gt;
and therefore labelling &lt;em&gt;Xing&lt;/em&gt; as the header ID of a &lt;em&gt;CBR&lt;/em&gt; file
is logically acceptable.&lt;/p&gt;

&lt;h2 id=&quot;how-to-estimate-the-duration&quot;&gt;How to estimate the duration&lt;/h2&gt;

&lt;h3 id=&quot;cbrconstant-bitrate&quot;&gt;CBR(Constant Bitrate)&lt;/h3&gt;

&lt;p&gt;The calculation for &lt;em&gt;CBR&lt;/em&gt; &lt;em&gt;MP3&lt;/em&gt; is straightforward:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\text{Duration (seconds)} = \frac{ \text{File Size (bits)} }{ \text{Bitrate (bits/second)} }&lt;/script&gt;

&lt;p&gt;The unit of &lt;em&gt;file size&lt;/em&gt; is usually &lt;em&gt;bytes&lt;/em&gt;,
so the &lt;em&gt;bit size&lt;/em&gt; of the file is &lt;code class=&quot;highlighter-rouge&quot;&gt;file size(bytes) * 8&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;vbrvariable-bitrate&quot;&gt;VBR(Variable Bitrate)&lt;/h3&gt;

&lt;p&gt;The calculation for &lt;em&gt;VBR&lt;/em&gt; &lt;em&gt;MP3&lt;/em&gt; is a little complicated:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\text{Duration (seconds)} = \frac{ \text{ Samples Per Frame $\cdot$ Total Frames (samples)} }{ \text{Sample Rate (samples/second)} }&lt;/script&gt;

&lt;p&gt;The duration is &lt;strong&gt;not accurate&lt;/strong&gt; when the &lt;em&gt;total frames&lt;/em&gt; above
is an &lt;strong&gt;estimated&lt;/strong&gt; value.
If the total frames isn’t predefined, then we need to estimate it by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\text{Estimated Total Frames} = \frac{ \text{File Size} }{ \text{Average Frame Size} }&lt;/script&gt;

&lt;h3 id=&quot;live-stream&quot;&gt;Live stream&lt;/h3&gt;

&lt;p&gt;No matter what type the &lt;em&gt;MP3&lt;/em&gt; is encoded with,
the duration is calculated by the &lt;strong&gt;file size&lt;/strong&gt;,
but what if the &lt;em&gt;file size&lt;/em&gt; is &lt;strong&gt;unknown&lt;/strong&gt;?
Before addressing the question, we should ask
what type of media will have an unknown file size.
The answer is &lt;strong&gt;live stream&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;No one knows when the live stream will be closed. It could be anytime.
Hence we don’t need to calculate the duration beforehand in this case.
We just need to make sure the position of the playback
stays at the end of the media track and the end-time keeps increasing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/posts/live-stream-playback.png&quot; alt=&quot;&quot; title=&quot;live stream playback&quot; /&gt;
(The position stays at the end of the media track during streaming.)&lt;/p&gt;

&lt;p&gt;However, for those live stream with &lt;strong&gt;opening remark&lt;/strong&gt;,
we still need to estimate how long the opening talk will be
and show the playback UI as it’s a non-live stream
before it finish introducing and start streaming.
After finishing the opening talk,
the UI should behave as the same as it’s a live stream.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/f53NjLQTafQ&quot; frameborder=&quot;0&quot; gesture=&quot;media&quot; allow=&quot;encrypted-media&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;(You can check this by opening &lt;a href=&quot;http://honey.macchiatomedia.org:8080/stream/1/?lang=en-US%2cen%3bq%3d0.5&quot;&gt;&lt;em&gt;KHNY Honey 103&lt;/em&gt;&lt;/a&gt; directly,
or go to &lt;a href=&quot;https://www.shoutcast.com/&quot;&gt;shoutcast&lt;/a&gt; and play &lt;em&gt;KHNY Honey 103&lt;/em&gt; under Genre &lt;em&gt;Jazz&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;As &lt;em&gt;file size&lt;/em&gt; is unknown, we should use &lt;a href=&quot;https://www.codeproject.com/Articles/8295/MPEG-Audio-Frame-Header#XINGHeader&quot;&gt;&lt;em&gt;number of frames&lt;/em&gt;&lt;/a&gt;
(&lt;a href=&quot;https://searchfox.org/mozilla-central/rev/f6f1731b1b7fec332f86b55fa40e2c9ae67ac39b/dom/media/mp3/MP3FrameParser.cpp#452,475-479&quot;&gt;example&lt;/a&gt;)
to calculate the duration of the opening introduction(&lt;a href=&quot;https://searchfox.org/mozilla-central/rev/22c55eb7b7e6494a8615a7af3b613ff899d2cdba/dom/media/mp3/MP3Demuxer.cpp#389-395&quot;&gt;example&lt;/a&gt;).
(The &lt;em&gt;number of frames&lt;/em&gt; here is same as the &lt;em&gt;total frames&lt;/em&gt; mentioned
in the duration estimation of &lt;em&gt;VBR MP3&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;To sum up this case, the ending time shown on playback at first
should be the duration of the opening talk.
After the playback’s position reaches the end, it should stay at the end
and the duration should keep increasing during streaming music.&lt;/p&gt;

&lt;h4 id=&quot;how-to-know-whether-the-file-size-is-unknown&quot;&gt;How to know whether the file size is unknown&lt;/h4&gt;

&lt;p&gt;Usually, the &lt;em&gt;file size&lt;/em&gt; of a live stream will be set to &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample code&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Duration: &lt;a href=&quot;https://searchfox.org/mozilla-central/rev/22c55eb7b7e6494a8615a7af3b613ff899d2cdba/dom/media/mp3/MP3Demuxer.cpp#382-420&quot;&gt;MP3Demuxer.cpp&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Parsing Header: &lt;a href=&quot;https://searchfox.org/mozilla-central/rev/f6f1731b1b7fec332f86b55fa40e2c9ae67ac39b/dom/media/mp3/MP3FrameParser.cpp#548&quot;&gt;MP3FrameParser.cpp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;useful-references&quot;&gt;Useful References&lt;/h2&gt;

&lt;p&gt;These points are the summary of what I’ve learned from &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419736&quot; title=&quot;Bug 1419736 - mp3 time length bug&quot;&gt;bug 1419736&lt;/a&gt;.
You can see more detail there.
It’s my first bug in demuxer field.
I quickly write a note here in case I need to recall it someday
and I believe it could benefit others.&lt;/p&gt;

&lt;p&gt;The following links are some useful resources I found when
I tried to get into this field:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/8295/MPEG-Audio-Frame-Header&quot;&gt;MPEG Audio Frame Header&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mp3-tech.org/programmer/frame_header.html&quot;&gt;MPEG Audio Layer I/II/III frame header&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mpgedit.org/mpgedit/mpeg_format/mpeghdr.htm&quot;&gt;MPEG Audio Compression Basics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gabriel.mp3-tech.org/mp3infotag.html&quot;&gt;MP3 Info Tag&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3505575/how-can-i-get-the-duration-of-an-mp3-file-cbr-or-vbr-with-a-very-small-library&quot;&gt;How can I get the duration of an MP3 file&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.crifan.com/files/doc/docbook/mpeg_vbr/release/webhelp/ch04_xing_vbri.html&quot;&gt;MPEG簡介與如何計算CBR及VBR的播放時間&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Media&quot;]" /><category term="Demuxer" /><category term="Firefox" /><summary type="html">To calculate the duration of one MP3 file,
we need to know how it is encoded first.
The estimation for the durtation is different
based on how they are encoded.

CBR(Constant Bitrate) vs VBR(Variable Bitrate) Encoding

MP3 can be encoded either with constant bitrate(CBR)
or variable bitrate(VBR).
The quality of the MP3 encoded with VBR is better than one with CBR
since each frame can adopt different bitrate where the music needs it,
while the CBR file uses same bitrate regardless of what sound wave is.

How to know whether the file is CBR or VBR

There are two types for the MP3 header, Xing and VBRI.
The ID of the Xing header is either Xing or Info;
The ID of VBRI header is VBRI.

If the ID of Xing header is Info,
then it is definitely encoded with CBR.
Nevertheless, CBR is a special case of VBR
and therefore labelling Xing as the header ID of a CBR file
is logically acceptable.

How to estimate the duration

CBR(Constant Bitrate)

The calculation for CBR MP3 is straightforward:



The unit of file size is usually bytes,
so the bit size of the file is file size(bytes) * 8.

VBR(Variable Bitrate)

The calculation for VBR MP3 is a little complicated:



The duration is not accurate when the total frames above
is an estimated value.
If the total frames isn’t predefined, then we need to estimate it by:



Live stream

No matter what type the MP3 is encoded with,
the duration is calculated by the file size,
but what if the file size is unknown?
Before addressing the question, we should ask
what type of media will have an unknown file size.
The answer is live stream.

No one knows when the live stream will be closed. It could be anytime.
Hence we don’t need to calculate the duration beforehand in this case.
We just need to make sure the position of the playback
stays at the end of the media track and the end-time keeps increasing.


(The position stays at the end of the media track during streaming.)

However, for those live stream with opening remark,
we still need to estimate how long the opening talk will be
and show the playback UI as it’s a non-live stream
before it finish introducing and start streaming.
After finishing the opening talk,
the UI should behave as the same as it’s a live stream.



(You can check this by opening KHNY Honey 103 directly,
or go to shoutcast and play KHNY Honey 103 under Genre Jazz)

As file size is unknown, we should use number of frames
(example)
to calculate the duration of the opening introduction(example).
(The number of frames here is same as the total frames mentioned
in the duration estimation of VBR MP3)

To sum up this case, the ending time shown on playback at first
should be the duration of the opening talk.
After the playback’s position reaches the end, it should stay at the end
and the duration should keep increasing during streaming music.

How to know whether the file size is unknown

Usually, the file size of a live stream will be set to -1.

Sample code

  Duration: MP3Demuxer.cpp
  Parsing Header: MP3FrameParser.cpp


Useful References

These points are the summary of what I’ve learned from bug 1419736.
You can see more detail there.
It’s my first bug in demuxer field.
I quickly write a note here in case I need to recall it someday
and I believe it could benefit others.

The following links are some useful resources I found when
I tried to get into this field:

  MPEG Audio Frame Header
  MPEG Audio Layer I/II/III frame header
  MPEG Audio Compression Basics
  MP3 Info Tag
  How can I get the duration of an MP3 file
  MPEG簡介與如何計算CBR及VBR的播放時間</summary></entry><entry><title type="html">Master Fibonacci</title><link href="http://localhost:4000/post/master-fibonacci" rel="alternate" type="text/html" title="Master Fibonacci" /><published>2017-09-09T00:00:00+08:00</published><updated>2017-09-09T00:00:00+08:00</updated><id>http://localhost:4000/post/master-fibonacci</id><content type="html" xml:base="http://localhost:4000/post/master-fibonacci">&lt;p&gt;The &lt;em&gt;Fibonacci&lt;/em&gt; number is defined as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_n = F_{n-1} + F_{n-2}&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;F_0 = 0, F_1 = 1&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;It can be directly written into the following most common code
when we learned what the recursion is:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Recursive: O(2^n)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;However, if you try calculating &lt;script type=&quot;math/tex&quot;&gt;F_{100}&lt;/script&gt;,
then you will wait a long long time to get the result
since it has so many overlapping processes.
For example, if we calculate &lt;script type=&quot;math/tex&quot;&gt;F_4&lt;/script&gt;,
then there are duplicated calculations(overlapping substructures) for &lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{matrix}
 &amp; &amp; &amp; &amp; &amp; &amp; &amp; 4 &amp; &amp; &amp; &amp; &amp; \\
 &amp; &amp; &amp; &amp; &amp; &amp; \diagup &amp; &amp; \diagdown &amp; &amp; &amp; &amp; \\
 &amp; &amp; &amp; &amp; &amp; \diagup &amp; &amp; &amp; &amp; \diagdown &amp; &amp; &amp; \\
 &amp; &amp; &amp; &amp; 3 &amp; &amp; &amp; &amp; &amp; &amp; 2 &amp; &amp; \\
 &amp; &amp; &amp; \diagup &amp; &amp; \diagdown &amp; &amp; &amp; &amp; \diagup &amp; &amp; \diagdown &amp; \\
 &amp; &amp; 2 &amp; &amp; &amp; &amp; 1 &amp; &amp; 1 &amp; &amp; &amp; &amp; 0 \\
 &amp; \diagup &amp; &amp; \diagdown &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\
 1 &amp; &amp; &amp; &amp; 0 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp;
\end{matrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;The larger &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is, the more overlapping processes we have.
As a result, the time-complexity is &lt;script type=&quot;math/tex&quot;&gt;O(2^n)&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;memoization&quot;&gt;Memoization&lt;/h3&gt;

&lt;p&gt;To avoid that, we can use a &lt;strong&gt;cache&lt;/strong&gt; to save all the results
and check it first before any calculation,
so all the &lt;script type=&quot;math/tex&quot;&gt;F_k&lt;/script&gt; we need, for &lt;script type=&quot;math/tex&quot;&gt;k \in [0, n]&lt;/script&gt;,
will be computed just once.
Therefore, the time complexity can be shorten to &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Recursive with memoization: O(n)
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(k) = mem[k], F(0) = 0, F(1) = 1.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if n is not calculated yet
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;dynamic-programming&quot;&gt;Dynamic programming&lt;/h3&gt;

&lt;p&gt;The above implementation needs extra space to save the results,
and pay time for memory allocation.
If we iteratively calculate &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;
from &lt;script type=&quot;math/tex&quot;&gt;F_0, F_1&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;F_3&lt;/script&gt;, … then we can get &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;
without extra memory:&lt;/p&gt;

&lt;p&gt;The above implementation needs extra space to save the results,
and pay time for memory allocation.
If we iteratively calculate &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;
from &lt;script type=&quot;math/tex&quot;&gt;F_0, F_1&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;F_3&lt;/script&gt;, …,
to &lt;script type=&quot;math/tex&quot;&gt;F_{n-1}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;F_{n+1}&lt;/script&gt;
then we can use only three or four variables to get &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Dynamic programming: O(n)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a = F(k), b = F(k+1), k = 0 now.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// loop k from 1 to n.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a = F(k+1), b = F(k)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// b = F(k) + F(k+1) = F(k+2)
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Dynamic programming: O(n)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a = F(0), b = F(1)
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// run if n &amp;gt;= 2
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// sum = F(i+1)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// a = F(i)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// b = F(i+1)
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Now, i = n, sum = F(n), a = F(n-1), b = F(n)
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;They also run in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; with less memory consumption
than &lt;em&gt;memoization&lt;/em&gt; approach.
Furthermore, they avoid the memory overhead for the &lt;em&gt;activation records&lt;/em&gt;
on the &lt;em&gt;stack segment/space&lt;/em&gt; for the recursions.
(The recursion will call itself multiple times,
so it will push multiple &lt;em&gt;activation records&lt;/em&gt; for the same function itself,
with different arguments, into the &lt;em&gt;stack segment/space&lt;/em&gt;
of the process loading the program.)&lt;/p&gt;

&lt;h3 id=&quot;closed-form&quot;&gt;Closed-form&lt;/h3&gt;

&lt;p&gt;In fact, the &lt;em&gt;Fibonacci&lt;/em&gt; number can be calculated by the following formula:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_n = \frac{1}{\sqrt{5}} \cdot [ (\frac{1 + \sqrt{5}}{2})^n -  (\frac{1 - \sqrt{5}}{2})^n ]&lt;/script&gt;

&lt;p&gt;(Please read
&lt;!-- [this post](/post/closed-form-for-the-fibonacci-sequence) --&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/closed-form-for-the-fibonacci-sequence&quot;&gt;this post&lt;/a&gt;
to know how it’s derived.)&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// closed-form: O(log(n))
//   Theoretically, the power of n could be done in O(log(n)), but it's
//   complicated to calculate the floating numbers.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// double sqrt5 = sqrt((double)5);
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.2360679775&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Its time-complexity depends on how the power of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is calculated.
It could be done in &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt; time(we will explain it below).
However, the floating point operations limit the calculable number of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;,
and it might block the performance.&lt;/p&gt;

&lt;h3 id=&quot;matrix-algebra&quot;&gt;Matrix Algebra&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;Fibonacci&lt;/em&gt; numbers can be written into the following matrix:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\vec{F_n} =
\begin{bmatrix} F_n \\ F_{F - 1} \end{bmatrix}
=
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_{n - 1} \\ F_{n - 2} \end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;, so it could be easily expanded by the same rule:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
&amp;=
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_n &amp; F_{n - 1} \\ F_{n - 1} &amp; F_{n - 2} \end{bmatrix}
\\
&amp;=
{\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^2
\cdot
\begin{bmatrix} F_{n - 1} &amp; F_{n - 2} \\ F_{n - 2} &amp; F_{n - 3} \end{bmatrix}
\\
\vdots
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} F_2 &amp; F_1 \\ F_1 &amp; F_0 \end{bmatrix}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;(Please read
&lt;!-- [this post](/post/matrix-difference-equation-for-fibonacci-sequence) --&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence&quot;&gt;this post&lt;/a&gt;
for more discussion.)&lt;/p&gt;

&lt;p&gt;That is, the &lt;em&gt;Fibonacci&lt;/em&gt; matrix turns into a perfect power.
Applying
&lt;!-- [exponentiation by squaring](/post/exponentiation-by-squaring) --&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/exponentiation-by-squaring&quot;&gt;exponentiation by squaring&lt;/a&gt;
:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  &amp; \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;, we could implement the above idea to:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Power by matrix exponentiation: O(log(n))
// Matrix A:
//  &amp;lt;---  cols: n  ---&amp;gt;
// +-                 -+
// | A11, A12, ... A1n |   ^
// | A21, A22, ... A2n |   |
// | ...               | rows: m
// | ...               |   |
// | Am1, Am2, ... Amn |   v
// +-                 -+
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Matrix&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Matrix&amp;amp; m)
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   for (unsigned int i = 0; i &amp;lt; m.rows; ++i) {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     for (unsigned int j = 0; j &amp;lt; m.cols; ++j) {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//       os &amp;lt;&amp;lt; m.data[i][j] &amp;lt;&amp;lt; &quot; &quot;;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     }
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     os &amp;lt;&amp;lt; std::endl;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   }
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   return os;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// }
&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Check if they can be multiplied.
&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Calculate the power by fast doubling:
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   k ^ n = (k^2) ^ (n/2)          , if n is even
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//        or k * (k^2) ^ ((k-1)/2)  , if n is odd
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Copy constructor = Matrix x(rows, cols, data);
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*n % 2*/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;cm&quot;&gt;/*n /= 2*/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Using F.data[0][1] since n might be 0.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// (we need to power by n - 1 if we return F.data[0][0].)
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Its time-complexity is &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt; by halving and halving.
Without the floating point operations,
the &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; could be larger than using the &lt;em&gt;closed-form&lt;/em&gt; approach.&lt;/p&gt;

&lt;p&gt;To make it faster, you can use native array instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt;,
but you need to manage the memory usage by yourself.
Please read
&lt;!-- [this post](/post/matrix-difference-equation-for-fibonacci-sequence) --&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence&quot;&gt;this post&lt;/a&gt;
to know how to do it.&lt;/p&gt;

&lt;h3 id=&quot;fast-doubling&quot;&gt;Fast doubling&lt;/h3&gt;

&lt;p&gt;The following equations:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
F_{2n+1} &amp;= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &amp;= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &amp;= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &amp;= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;can be derived by applying &lt;script type=&quot;math/tex&quot;&gt;2n&lt;/script&gt; to the above &lt;em&gt;Fibonacci&lt;/em&gt; matrix:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{bmatrix} F_{2n+1} &amp; F_{2n} \\ F_{2n} &amp; F_{2n - 1} \end{bmatrix}
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{2n}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\cdot
{\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\\
&amp;= \begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
\cdot \begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
\\
&amp;=
\begin{bmatrix}
  {F_{n+1}}^2 + {F_n}^2 &amp; F_n \cdot (F_{n+1} + F_{n-1}) \\
  F_n \cdot (F_{n+1} + F_{n-1}) &amp; {F_n}^2 + {F_{n-1}}^2
\end{bmatrix}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Hence, we could calculate &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
F_n =
\begin{cases}
F_{2n'},  &amp; \text{if $n$ is even} \\
F_{2n'+1}, &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;As a consequence, we could use &lt;script type=&quot;math/tex&quot;&gt;F_{n'}, F_{n' + 1}&lt;/script&gt;
to compute &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; by the following program:
(Please read
&lt;!-- [this post](/post/calculating-fibonacci-numbers-by-fast-doubling) --&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/calculating-fibonacci-numbers-by-fast-doubling&quot;&gt;this post&lt;/a&gt;
to know how the code is derived.)&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// The position of the highest bit of n.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// So we need to loop `h` times to get the answer.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Example: n = (Dec)50 = (Bin)00110010, then h = 6.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//                               ^ 6th bit from right side
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = 1
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// There is only one `1` in the bits of `mask`. The `1`'s position is same as
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// iteratively to do `AND` operation with `n` to check `n / 2^j` is odd
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// or even.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Run h times!
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Let j = h-i (looping from i = 1 to i = h),
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// n_j = floor(n / 2^j) = n &amp;gt;&amp;gt; j (n_j = n when j = 0), k = floor(n_j / 2),
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// then a = F(k), b = F(k+1) now.
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// F(2k+1) = F(k)^2 + F(k+1)^2
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n_j is odd: k = (n_j-1)/2 =&amp;gt; n_j = 2k + 1
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//   F(n_j) = F(2k + 1)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// n_j is even: k = n_j/2 =&amp;gt; n_j = 2k
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//   F(n_j) = F(2k)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//   F(n_j + 1) = F(2k + 1)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Its time-complexity is also &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt; by halving and halving.
In contrast to &lt;em&gt;matrix algebra&lt;/em&gt; approach,
there is no need for using matrix
that contains the duplicated &lt;script type=&quot;math/tex&quot;&gt;F_k&lt;/script&gt;,
so it will be faster.&lt;/p&gt;

&lt;h3 id=&quot;performance&quot;&gt;Performance&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Approach&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;F_{45}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;F_{13100}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;F_{13500}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;F_{29108}&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Recursive&lt;/td&gt;
      &lt;td&gt;7440.61&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Memoization&lt;/td&gt;
      &lt;td&gt;0.034841&lt;/td&gt;
      &lt;td&gt;3.03045&lt;/td&gt;
      &lt;td&gt;3.05931&lt;/td&gt;
      &lt;td&gt;6.10806&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dynamic programming&lt;/td&gt;
      &lt;td&gt;0.000508&lt;/td&gt;
      &lt;td&gt;0.052462&lt;/td&gt;
      &lt;td&gt;0.05395&lt;/td&gt;
      &lt;td&gt;0.1069&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Closed-form&lt;/td&gt;
      &lt;td&gt;0.030075&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Matrix Algebra&lt;/td&gt;
      &lt;td&gt;0.02013&lt;/td&gt;
      &lt;td&gt;0.052985&lt;/td&gt;
      &lt;td&gt;0.052427&lt;/td&gt;
      &lt;td&gt;0.050423&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fast doubling&lt;/td&gt;
      &lt;td&gt;0.000446&lt;/td&gt;
      &lt;td&gt;0.000737&lt;/td&gt;
      &lt;td&gt;0.000785&lt;/td&gt;
      &lt;td&gt;0.000724&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The above results are the time in &lt;em&gt;millisecond&lt;/em&gt; for calculating &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;.
It will take too long time to get the results from the &lt;em&gt;recursive&lt;/em&gt; approach,
so we skip it.
The &lt;em&gt;closed-form&lt;/em&gt; approach is also ignored
since the floating point operations only work
when &lt;script type=&quot;math/tex&quot;&gt;n \leq 97&lt;/script&gt; in above implementation.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Although the performance is platform-dependent,
it still indicates that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;em&gt;fast doubling&lt;/em&gt; approach is always the fastest way
and its performance is far far better than others.&lt;/li&gt;
  &lt;li&gt;The &lt;em&gt;dynamic programming&lt;/em&gt; approach is faster than &lt;em&gt;matrix algebra&lt;/em&gt; one
when &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is small (&lt;script type=&quot;math/tex&quot;&gt;n \leq 13000&lt;/script&gt; here),
but slower when &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is large.&lt;/li&gt;
  &lt;li&gt;Therefore, if you are pretty sure you have a small &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;,
and the bottleneck of your algorithm doesn’t depend on
the &lt;em&gt;Fibonacci&lt;/em&gt; calculation, then &lt;em&gt;dynamic programming&lt;/em&gt; is acceptable
and it’s easier to implement.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This post is the end of my journey for the &lt;em&gt;Fibonacci&lt;/em&gt; calculation.
Hope you enjoyed.
All the above code are uploaded to &lt;a href=&quot;https://gist.github.com/ChunMinChang/b6325c148e8aff15b6e72dcac0aa904e&quot; title=&quot;Ways to calculate Fibonacci&quot;&gt;gist here&lt;/a&gt;.
Please clone them to play with it.&lt;/p&gt;

&lt;p&gt;I will start another journey for other interesting topics soon.
Stay tuned!&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Algorithm&quot;]" /><category term="Fibonacci" /><category term="Recursion" /><category term="Dynamic Programming" /><summary type="html">The Fibonacci number is defined as:



where .

It can be directly written into the following most common code
when we learned what the recursion is:
///////////////////////////////////////////////////////////////////////////////
// Recursive: O(2^n)
uint64_t fibonacci(unsigned int n)
{
  return (n &amp;lt;= 1) ? n : fibonacci(n-1) + fibonacci(n-2);
}


However, if you try calculating ,
then you will wait a long long time to get the result
since it has so many overlapping processes.
For example, if we calculate ,
then there are duplicated calculations(overlapping substructures) for :



The larger  is, the more overlapping processes we have.
As a result, the time-complexity is .

Memoization

To avoid that, we can use a cache to save all the results
and check it first before any calculation,
so all the  we need, for ,
will be computed just once.
Therefore, the time complexity can be shorten to .

///////////////////////////////////////////////////////////////////////////////
// Recursive with memoization: O(n)
std::vector&amp;lt;uint64_t&amp;gt; mem = { 0, 1 }; // F(k) = mem[k], F(0) = 0, F(1) = 1.
uint64_t fibonacci(unsigned int n)
{
  if (n + 1 &amp;gt; mem.size()) { // if n is not calculated yet
    mem.push_back(fibonacci(n-1) + fibonacci(n-2));
  }
  return mem[n];
}



Dynamic programming

The above implementation needs extra space to save the results,
and pay time for memory allocation.
If we iteratively calculate 
from  to , , … then we can get 
without extra memory:

The above implementation needs extra space to save the results,
and pay time for memory allocation.
If we iteratively calculate 
from  to , , …,
to ,  or , 
then we can use only three or four variables to get :

///////////////////////////////////////////////////////////////////////////////
// Dynamic programming: O(n)
uint64_t fibonacci(unsigned int n)
{
  uint64_t a = 0, b = 1; // a = F(k), b = F(k+1), k = 0 now.
  for (unsigned int k = 1 ; k &amp;lt;= n ; ++k) { // loop k from 1 to n.
    std::swap(a, b); // a = F(k+1), b = F(k)
    b += a; // b = F(k) + F(k+1) = F(k+2)
  }
  return a;
}



or

///////////////////////////////////////////////////////////////////////////////
// Dynamic programming: O(n)
uint64_t fibonacci(unsigned int n)
{
  uint64_t a = 0, b = 1, sum = 0; // a = F(0), b = F(1)
  for (unsigned int i = 1 ; i &amp;lt; n ; ++i) { // run if n &amp;gt;= 2
    sum = a + b; // sum = F(i+1)
    a = b;       // a = F(i)
    b = sum;     // b = F(i+1)
  }
  // Now, i = n, sum = F(n), a = F(n-1), b = F(n)
  return (n &amp;lt; 2) ? n : sum;
}



They also run in  with less memory consumption
than memoization approach.
Furthermore, they avoid the memory overhead for the activation records
on the stack segment/space for the recursions.
(The recursion will call itself multiple times,
so it will push multiple activation records for the same function itself,
with different arguments, into the stack segment/space
of the process loading the program.)

Closed-form

In fact, the Fibonacci number can be calculated by the following formula:



(Please read

this post
to know how it’s derived.)

///////////////////////////////////////////////////////////////////////////////
// closed-form: O(log(n))
//   Theoretically, the power of n could be done in O(log(n)), but it's
//   complicated to calculate the floating numbers.
uint64_t fibonacci(unsigned int n)
{
  // double sqrt5 = sqrt((double)5);
  double sqrt5 = 2.2360679775;
  return (pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n)) / sqrt5;
}



Its time-complexity depends on how the power of  is calculated.
It could be done in  time(we will explain it below).
However, the floating point operations limit the calculable number of ,
and it might block the performance.

Matrix Algebra

The Fibonacci numbers can be written into the following matrix:



, so it could be easily expanded by the same rule:



(Please read

this post
for more discussion.)

That is, the Fibonacci matrix turns into a perfect power.
Applying

exponentiation by squaring
:



, we could implement the above idea to:

///////////////////////////////////////////////////////////////////////////////
// Power by matrix exponentiation: O(log(n))
// Matrix A:
//  &amp;lt;---  cols: n  ---&amp;gt;
// +-                 -+
// | A11, A12, ... A1n |   ^
// | A21, A22, ... A2n |   |
// | ...               | rows: m
// | ...               |   |
// | Am1, Am2, ... Amn |   v
// +-                 -+
class Matrix
{
public:
  Matrix(unsigned int r, unsigned int c,
         std::vector&amp;lt;std::vector&amp;lt;uint64_t&amp;gt;&amp;gt; d)
    : rows(r)
    , cols(c)
    , data(d)
  {
  }

  Matrix(unsigned int r, unsigned int c)
    : rows(r)
    , cols(c)
  {
    assert(rows &amp;amp;&amp;amp; cols);
    data.resize(rows);
    for (unsigned int i = 0 ; i &amp;lt; rows ; ++i) {
      data[i].resize(cols);
    }
  }

  ~Matrix()
  {
  }

  uint64_t Read(unsigned int r, unsigned int c)
  {
    return data[r][c];
  }

  // friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Matrix&amp;amp; m)
  // {
  //   for (unsigned int i = 0; i &amp;lt; m.rows; ++i) {
  //     for (unsigned int j = 0; j &amp;lt; m.cols; ++j) {
  //       os &amp;lt;&amp;lt; m.data[i][j] &amp;lt;&amp;lt; &quot; &quot;;
  //     }
  //     os &amp;lt;&amp;lt; std::endl;
  //   }
  //   return os;
  // }

  Matrix operator*(const Matrix&amp;amp; other)
  {
    assert(cols == other.rows); // Check if they can be multiplied.

    Matrix z(rows, other.cols);
    for (unsigned int i = 0 ; i &amp;lt; rows ; ++i) {
      for (unsigned int j = 0 ; j &amp;lt; other.cols; ++j) {
        for (unsigned int k = 0 ; k &amp;lt; cols; ++k) {
          z.data[i][j] += data[i][k] * other.data[k][j];
        }
      }
    }

    return z;
  }

  // Calculate the power by fast doubling:
  //   k ^ n = (k^2) ^ (n/2)          , if n is even
  //        or k * (k^2) ^ ((k-1)/2)  , if n is odd
  Matrix pow(unsigned int n)
  {
    Matrix k(*this); // Copy constructor = Matrix x(rows, cols, data);
    Matrix r = Identity(rows);
    while (n) {
      if (/*n % 2*/n &amp;amp; 1) {
        r = r * k;
      }
      k = k * k;
      /*n /= 2*/n &amp;gt;&amp;gt;= 1;
    }
    return r;
  }

private:
  Matrix Identity(unsigned int size)
  {
    Matrix z(size, size);
    for (unsigned int i = 0 ; i &amp;lt; size ; ++i) {
      z.data[i][i] = 1;
    }
    return z;
  }

  unsigned int rows;
  unsigned int cols;
  std::vector&amp;lt;std::vector&amp;lt;uint64_t&amp;gt;&amp;gt; data;
};

// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
uint64_t fibonacci(unsigned int n)
{
  Matrix F { 2, 2, {
    { 1, 1 },
    { 1, 0 }
  } };

  // Using F.data[0][1] since n might be 0.
  // (we need to power by n - 1 if we return F.data[0][0].)
  F = F.pow(n);
  return F.Read(0, 1);
}



Its time-complexity is  by halving and halving.
Without the floating point operations,
the  could be larger than using the closed-form approach.

To make it faster, you can use native array instead of std::vector,
but you need to manage the memory usage by yourself.
Please read

this post
to know how to do it.

Fast doubling

The following equations:



can be derived by applying  to the above Fibonacci matrix:



Hence, we could calculate  by:



As a consequence, we could use 
to compute  by the following program:
(Please read

this post
to know how the code is derived.)

uint64_t fibonacci(unsigned int n)
{
  // The position of the highest bit of n.
  // So we need to loop `h` times to get the answer.
  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.
  //                               ^ 6th bit from right side
  unsigned int h = 0;
  for (unsigned int i = n ; i ; ++h, i &amp;gt;&amp;gt;= 1);

  uint64_t a = 0; // F(0) = 0
  uint64_t b = 1; // F(1) = 1
  // There is only one `1` in the bits of `mask`. The `1`'s position is same as
  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right
  // iteratively to do `AND` operation with `n` to check `n / 2^j` is odd
  // or even.
  for (unsigned int mask = 1 &amp;lt;&amp;lt; (h - 1) ; mask ; mask &amp;gt;&amp;gt;= 1) { // Run h times!
    // Let j = h-i (looping from i = 1 to i = h),
    // n_j = floor(n / 2^j) = n &amp;gt;&amp;gt; j (n_j = n when j = 0), k = floor(n_j / 2),
    // then a = F(k), b = F(k+1) now.
    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2

    if (mask &amp;amp; n) { // n_j is odd: k = (n_j-1)/2 =&amp;gt; n_j = 2k + 1
      a = d;        //   F(n_j) = F(2k + 1)
      b = c + d;    //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)
    } else {        // n_j is even: k = n_j/2 =&amp;gt; n_j = 2k
      a = c;        //   F(n_j) = F(2k)
      b = d;        //   F(n_j + 1) = F(2k + 1)
    }
  }

  return a;
}



Its time-complexity is also  by halving and halving.
In contrast to matrix algebra approach,
there is no need for using matrix
that contains the duplicated ,
so it will be faster.

Performance


  
    
      Approach
      
      
      
      
    
  
  
    
      Recursive
      7440.61
       
       
       
    
    
      Memoization
      0.034841
      3.03045
      3.05931
      6.10806
    
    
      Dynamic programming
      0.000508
      0.052462
      0.05395
      0.1069
    
    
      Closed-form
      0.030075
       
       
       
    
    
      Matrix Algebra
      0.02013
      0.052985
      0.052427
      0.050423
    
    
      Fast doubling
      0.000446
      0.000737
      0.000785
      0.000724
    
  


The above results are the time in millisecond for calculating .
It will take too long time to get the results from the recursive approach,
so we skip it.
The closed-form approach is also ignored
since the floating point operations only work
when  in above implementation.

Conclusion

Although the performance is platform-dependent,
it still indicates that:


  The fast doubling approach is always the fastest way
and its performance is far far better than others.
  The dynamic programming approach is faster than matrix algebra one
when  is small ( here),
but slower when  is large.
  Therefore, if you are pretty sure you have a small ,
and the bottleneck of your algorithm doesn’t depend on
the Fibonacci calculation, then dynamic programming is acceptable
and it’s easier to implement.


This post is the end of my journey for the Fibonacci calculation.
Hope you enjoyed.
All the above code are uploaded to gist here.
Please clone them to play with it.

I will start another journey for other interesting topics soon.
Stay tuned!</summary></entry><entry><title type="html">Calculating Fibonacci Numbers by Fast Doubling</title><link href="http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling" rel="alternate" type="text/html" title="Calculating Fibonacci Numbers by Fast Doubling" /><published>2017-08-31T00:00:00+08:00</published><updated>2017-08-31T00:00:00+08:00</updated><id>http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling</id><content type="html" xml:base="http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling">&lt;p&gt;In &lt;!-- [previous post](/post/matrix-difference-equation-for-fibonacci-sequence) --&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence&quot;&gt;previous post&lt;/a&gt;,
we learned how to calculate &lt;em&gt;Fibonacci&lt;/em&gt; numbers by &lt;em&gt;Fast Doubling&lt;/em&gt; in math.
Today, we will apply it in programming and optimize it step by step.&lt;/p&gt;

&lt;h2 id=&quot;fast-doubling&quot;&gt;Fast Doubling&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
F_{2n+1} &amp;= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &amp;= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &amp;= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &amp;= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;It’s natural to write a recursive implementation by the above definition.
In the following steps, we will implement recursive versions first,
then try converting it into iterative versions.&lt;/p&gt;

&lt;h3 id=&quot;recursive-top-down-approach&quot;&gt;Recursive (Top-down) Approach&lt;/h3&gt;

&lt;p&gt;Given a &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;, we could calculate &lt;em&gt;Fibonacci&lt;/em&gt; numbers &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; by:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n is odd: F(n) = F(((n-1)/2) + 1)^2 + F((n-1) / 2)^2
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n is even: F(n) = F(n/2) * [ 2 * F(n/2 + 1) - F(n/2) ]
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From above code, we can know that the code stack will be entered again and again,
so we need to define when to stop it.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = F(2) = 0.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Keep call itself recursively to get the answer.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Put the main body here.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We only calculate &lt;em&gt;Fibonacci&lt;/em&gt; numbers from &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;,
so we need to stop when &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(0)&lt;/code&gt; may be asked from calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(1) = fib(0)*fib(0) + fib(1)*fib(1)&lt;/code&gt;
(by setting &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;F_{2n+1} = {F_{n+1}}^2 + {F_n}^2&lt;/script&gt;,
so we also need to define &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(1) = 1&lt;/code&gt; directly,
or it will cause an endless recursion.&lt;/p&gt;

&lt;p&gt;Similarly, the &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(1)&lt;/code&gt; may be asked from calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(2) = fib(1) * [2 * fib(2) - fib(1)]&lt;/code&gt;
(by setting &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;F_{2n} = F_n \cdot (2 \cdot F_{n+1} - F_n)&lt;/script&gt;,
so &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(2) = 1&lt;/code&gt; also needs to be returned directly.&lt;/p&gt;

&lt;p&gt;As the result, the code can be written into:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Fast doubling: O(log(n))
//   Using 2n to the Fibonacci matrix above, we can derive that:
//     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]
//     F(2n+1) = F(n+1)^2 + F(n)^2
//     (and F(2n-1) = F(n)^2 + F(n-1)^2)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = F(2) = 0.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now, let we look where we could improve from this simple version.
We use duplicated &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(k)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(k + 1)&lt;/code&gt; to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;fib(n)&lt;/code&gt;.
That is, we will have two duplicated recursive processes to do the same work.
It would be a waste of the time.&lt;/p&gt;

&lt;p&gt;Another trick is that we could use &lt;code class=&quot;highlighter-rouge&quot;&gt;n = n / 2&lt;/code&gt; in both cases
(&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is odd or even) since the result of &lt;code class=&quot;highlighter-rouge&quot;&gt;n = (n - 1) / 2&lt;/code&gt; is same
as &lt;code class=&quot;highlighter-rouge&quot;&gt;n = n / 2&lt;/code&gt; in &lt;em&gt;C/C++&lt;/em&gt;’s world if &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is an &lt;strong&gt;odd&lt;/strong&gt; integer.&lt;/p&gt;

&lt;p&gt;Thus, we can rewrite the code into:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = F(2) = 1.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// k = n/2 if n is even. k = (n-1)/2 if n is odd.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;memoization&quot;&gt;Memoization&lt;/h4&gt;

&lt;p&gt;Do we save all duplicated task now? No.
Suppose we need to find &lt;script type=&quot;math/tex&quot;&gt;F_6&lt;/script&gt;, then we need to get &lt;script type=&quot;math/tex&quot;&gt;F_3, F_4&lt;/script&gt; ….&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{matrix}
 &amp; &amp; &amp; &amp; &amp; 6 &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\
 &amp; &amp; &amp; &amp; \diagup &amp; &amp; \diagdown &amp; &amp; &amp; &amp; &amp; &amp; \\
 &amp; &amp; &amp; \diagup &amp; &amp; &amp; &amp; \diagdown &amp; &amp; &amp; &amp; &amp; \\
 &amp; &amp; 3 &amp; &amp; &amp; &amp; &amp; &amp; 4 &amp; &amp; &amp; &amp; \\
 &amp; \diagup &amp; &amp; \diagdown &amp; &amp; &amp; &amp; \diagup &amp; &amp; \diagdown &amp; &amp; &amp; \\
 1 &amp; &amp; &amp; &amp; 2 &amp; &amp; 2 &amp; &amp; &amp; &amp; 3 &amp; &amp; \\
 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \diagup &amp; &amp; \diagdown &amp; \\
 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 1 &amp; &amp; &amp; &amp; 2
\end{matrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;It’s clear that we have a duplicated &lt;script type=&quot;math/tex&quot;&gt;F_1, F_2, F_3&lt;/script&gt; on above figure.
&lt;script type=&quot;math/tex&quot;&gt;F_1, F_2&lt;/script&gt; can return value directly, while &lt;script type=&quot;math/tex&quot;&gt;F_3&lt;/script&gt; can not.
Therefore, the sub-tree(sub-process) whose root is &lt;script type=&quot;math/tex&quot;&gt;F_3&lt;/script&gt; will be executed twice.&lt;/p&gt;

&lt;p&gt;The larger the &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is, the more duplicated sub-process will be executed.
To avoid the waste, we can add an &lt;em&gt;array&lt;/em&gt; to save all the calculated value.
We check the &lt;em&gt;array&lt;/em&gt; first when &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; is calculated.
If there is already a saved value in the &lt;em&gt;array&lt;/em&gt; at &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;,
then we can use it directly.
Otherwise, it will be calculated as usual.
It’s called &lt;em&gt;memoization&lt;/em&gt;.
We will save &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; as the &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; element in the &lt;em&gt;array&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In this case, the &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; is not calculated successively.
For example, to get &lt;script type=&quot;math/tex&quot;&gt;F_6&lt;/script&gt;, we only need &lt;script type=&quot;math/tex&quot;&gt;F_4, F_3, F_2, F_1, F_0&lt;/script&gt;.
We don’t need &lt;script type=&quot;math/tex&quot;&gt;F_5&lt;/script&gt;, so there is no value at the &lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt; element in the &lt;em&gt;array&lt;/em&gt;.
You can use &lt;em&gt;hash map&lt;/em&gt; instead of &lt;em&gt;array&lt;/em&gt; to avoid the waste of memory.
However, retrieving data from &lt;em&gt;array&lt;/em&gt; is faster than &lt;em&gt;hash map&lt;/em&gt;,
so we apply &lt;em&gt;array&lt;/em&gt; in our sample code:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 4 is not a fibonacci number, so using it as initialized value.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INIT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// In this case, F is not calculated successively. For example,
// To get F(6), we only need F(4), F(3), F(2), F(1), F(0) (no F(5)),
// so the other elements in F is still INIT.
// Another way is to use hash map(std::unordered_map), however,
// it will be slower.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIZE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INIT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = F(2) = 1.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// k = n/2 if n is even. k = (n-1)/2 if n is odd.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2, if n is odd.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//    F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ], if n is even.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;state-vector&quot;&gt;State vector&lt;/h4&gt;
&lt;p&gt;Although we can speed up the calculating by applying &lt;em&gt;memoization&lt;/em&gt; above,
the memory consumption with this approach grows with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;.
Is it possible to use a fixed memory no matter how big &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is?
The answer is yes. Actually, we could just use a two-elements array to do it.&lt;/p&gt;

&lt;p&gt;From the formula, we can calculate &lt;script type=&quot;math/tex&quot;&gt;[F_{2n}, F_{2n+1}]&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;[F_n, F_{n+1}]&lt;/script&gt;.
For example, to calculate &lt;script type=&quot;math/tex&quot;&gt;F_{10}&lt;/script&gt;, we need &lt;script type=&quot;math/tex&quot;&gt;F_5, F_6&lt;/script&gt;.
To calculate &lt;script type=&quot;math/tex&quot;&gt;F_5&lt;/script&gt;, we need &lt;script type=&quot;math/tex&quot;&gt;F_2, F_3&lt;/script&gt;.
To calculate &lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt;, we need &lt;script type=&quot;math/tex&quot;&gt;F_1, F_0&lt;/script&gt;.
To calculate &lt;script type=&quot;math/tex&quot;&gt;F_1&lt;/script&gt;, we need &lt;script type=&quot;math/tex&quot;&gt;F_0, F_1&lt;/script&gt;
(so we need to stop here since &lt;script type=&quot;math/tex&quot;&gt;F_1&lt;/script&gt; is the dead end).&lt;/p&gt;

&lt;p&gt;However, how do we get &lt;script type=&quot;math/tex&quot;&gt;F_6&lt;/script&gt;
when we only have &lt;script type=&quot;math/tex&quot;&gt;F_2, F_3&lt;/script&gt; to calculate &lt;script type=&quot;math/tex&quot;&gt;F_5&lt;/script&gt;?
Or how to get &lt;script type=&quot;math/tex&quot;&gt;F_3&lt;/script&gt;
when we only have &lt;script type=&quot;math/tex&quot;&gt;F_0, F_1&lt;/script&gt; to calculate &lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt; …?&lt;/p&gt;

&lt;p&gt;By applying &lt;script type=&quot;math/tex&quot;&gt;n = 2&lt;/script&gt; to formula, we can use &lt;script type=&quot;math/tex&quot;&gt;F_2, F_3&lt;/script&gt; to get &lt;script type=&quot;math/tex&quot;&gt;F_4, F_5&lt;/script&gt;.
Then we can get &lt;script type=&quot;math/tex&quot;&gt;F_6 = F_4 + F_5&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Thus, we are able to get &lt;script type=&quot;math/tex&quot;&gt;F_{10}&lt;/script&gt; by the following procedure:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    F_0 \\
    F_1
  \end{array}
\right)
@&gt;{2n+1, 2n+2}&gt;&gt;
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@&gt;{2n, 2n+1}&gt;&gt;
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@&gt;{2n+1, 2n+2}&gt;&gt;
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@&gt;{2n, 2n+1}&gt;&gt;
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}&lt;/script&gt;

&lt;p&gt;Thus, we could keep using two-elements array
for &lt;script type=&quot;math/tex&quot;&gt;\begin{bmatrix} F_n \\ F_{n+1} \end{bmatrix}&lt;/script&gt;
to compute what we want and update it step by step.&lt;/p&gt;

&lt;p&gt;But how to determine the state we should update from &lt;script type=&quot;math/tex&quot;&gt;[F_n, F_{n + 1}]&lt;/script&gt;,
&lt;script type=&quot;math/tex&quot;&gt;[F_{2n}, F_{2n + 1}]&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;[F_{2n + 1}, F_{2n + 2}]&lt;/script&gt; ?&lt;/p&gt;

&lt;p&gt;It’s simple. If &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is even, we need to find &lt;script type=&quot;math/tex&quot;&gt;F_k&lt;/script&gt;
, where &lt;script type=&quot;math/tex&quot;&gt;k = \frac{n}{2}&lt;/script&gt; since &lt;script type=&quot;math/tex&quot;&gt;n = 2x&lt;/script&gt;.
Then we can use &lt;script type=&quot;math/tex&quot;&gt;[F_k, F_{k+1}] = [F_{n/2}, F_{n/2 + 1}]&lt;/script&gt;
to calculate &lt;script type=&quot;math/tex&quot;&gt;[F_{2k}, F_{2k + 1}] = [F_n, F_{n + 1}]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Otherwise, if &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is odd, we need to find &lt;script type=&quot;math/tex&quot;&gt;F_k&lt;/script&gt;
, where &lt;script type=&quot;math/tex&quot;&gt;k = \frac{n-1}{2}&lt;/script&gt; since &lt;script type=&quot;math/tex&quot;&gt;n = 2k + 1&lt;/script&gt;.
Then we can use &lt;script type=&quot;math/tex&quot;&gt;[F_k, F_{k+1}] = [F_{(n-1)/2}, F_{(n-1)/2 + 1}]&lt;/script&gt;
to calculate &lt;script type=&quot;math/tex&quot;&gt;[F_{2k}, F_{2k+1}] = [F_{n-1}, F_n]&lt;/script&gt;
and then get &lt;script type=&quot;math/tex&quot;&gt;[F_n, F_{n + 1}]&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;[F_n, F_{n-1} + F_n]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;In summary, the procedure can be organized as follows:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;k_i&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;k_3&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;k_4&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;k_5&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;n(= k_i)&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is odd&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;v&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;v&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_{2k_{i+1}}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_4&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_0&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_{10}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_5&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_0&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_{n+1}&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_6&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_3&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F_1&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The last two rows, &lt;script type=&quot;math/tex&quot;&gt;F_n, F_{n+1}(= F_{k_i}, F_{k_i+1})&lt;/script&gt;, are the state vector
that contains our answer.&lt;/p&gt;

&lt;p&gt;The first row &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;, is the index of the first element
of the state vector &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;.
The second row indicates that whether &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is odd or not.
If &lt;script type=&quot;math/tex&quot;&gt;n(= k_i)&lt;/script&gt; is odd(recall what we discuss above),
then we need to update state from from &lt;script type=&quot;math/tex&quot;&gt;[F_{k_{i+1}}, F_{k_{i+1}+1}]&lt;/script&gt;
to &lt;script type=&quot;math/tex&quot;&gt;[F_{2k_i + 1}, F_{2k_i + 2}]&lt;/script&gt; since &lt;script type=&quot;math/tex&quot;&gt;k_{i+1} = \frac{k_i - 1}{2}&lt;/script&gt;.
The third row is used to record if we need get &lt;script type=&quot;math/tex&quot;&gt;[F_{2k_i + 1}, F_{2k_i + 2}]&lt;/script&gt;
from &lt;script type=&quot;math/tex&quot;&gt;[F_{2k_i}, F_{2k_i + 1}]&lt;/script&gt;.
Otherwise, if &lt;script type=&quot;math/tex&quot;&gt;n(= k_i)&lt;/script&gt; is even, updating state
from &lt;script type=&quot;math/tex&quot;&gt;[F_{k_{i+1}}, F_{k_{i+1}+1}]&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;[F_{2k_i}, F_{2k_i + 1}]&lt;/script&gt; directly.&lt;/p&gt;

&lt;p&gt;From the top-down perspective, to get &lt;script type=&quot;math/tex&quot;&gt;F_{10}&lt;/script&gt;, we need &lt;script type=&quot;math/tex&quot;&gt;F_5, F_6&lt;/script&gt;.
To get &lt;script type=&quot;math/tex&quot;&gt;F_5, F_6&lt;/script&gt;, we need &lt;script type=&quot;math/tex&quot;&gt;F_2, F_3&lt;/script&gt;.
To get &lt;script type=&quot;math/tex&quot;&gt;F_2, F_3&lt;/script&gt;, we need &lt;script type=&quot;math/tex&quot;&gt;F_1, F_2&lt;/script&gt;.
To get &lt;script type=&quot;math/tex&quot;&gt;F_1, F_2&lt;/script&gt;, we need &lt;script type=&quot;math/tex&quot;&gt;F_0, F_1&lt;/script&gt;.
We will demonstrate how we do it recursively below.&lt;/p&gt;

&lt;p&gt;From the bottom-up perspective, we can use &lt;script type=&quot;math/tex&quot;&gt;F_0, F_1&lt;/script&gt;
to get &lt;script type=&quot;math/tex&quot;&gt;F_0, F_1, F_2&lt;/script&gt;,
then &lt;script type=&quot;math/tex&quot;&gt;F_1, F_2&lt;/script&gt; to get &lt;script type=&quot;math/tex&quot;&gt;F_2, F_3&lt;/script&gt;,
&lt;script type=&quot;math/tex&quot;&gt;F_2, F_3&lt;/script&gt; to get &lt;script type=&quot;math/tex&quot;&gt;F_4, F_5, F_6&lt;/script&gt;,
&lt;script type=&quot;math/tex&quot;&gt;F_5, F_6&lt;/script&gt; to get &lt;script type=&quot;math/tex&quot;&gt;F_10&lt;/script&gt;.
We will demonstrate how we do it in iterative section.&lt;/p&gt;

&lt;p&gt;The recursive approach is easier to understand.
By what we summarized above, the simplest implementation will be:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Set f[0], f[1] to F(n), F(n+1).
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 4 is not a fibonacci number, so using it as initialized value.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INIT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INIT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// F(k) = F((n-1)/2)
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// F(k + 1) = F((n- )/2 + 1)
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(n-1) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// F(n) = F(2k + 1) = F(k)^2 + F(k+1)^2
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;// F(n)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                 &lt;span class=&quot;c1&quot;&gt;// F(n+1) = F(n-1) + F(n)
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// F(k) = F(n/2)
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// F(k + 1) = F(n/2 + 1)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// F(n) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// F(n + 1) = F(2k + 1) = F(k)^2 + F(k+1)^2
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above &lt;code class=&quot;highlighter-rouge&quot;&gt;fib_helper&lt;/code&gt; is quite tedious,
we can be simplify it into:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Set f[0], f[1] to F(n), F(n+1).
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(k)
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(k+1)
&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// F(2k+1) = F(k+1)^2 + F(k)^2
&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// F(n) = F(2k+1).
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(n+1) = F(n-1) + F(n) = F(2k) + F(2k+1).
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// F(n) = F(2k).
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// F(n+1) = F(2k).
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You could also replace &lt;em&gt;array&lt;/em&gt; with &lt;em&gt;std::vector&lt;/em&gt;,
so the code will looks more elegant.
However, it will be slower than using &lt;em&gt;array&lt;/em&gt; directly.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Return vector [ F(n), F(n+1) ].
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// [F(0), F(1)] = [0 , 1]
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(k)
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(k+1)
&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// F(2k+1) = F(k+1)^2 + F(k)^2
&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// [F(n), F(n+1)] = [F(2k+1), F(2k+2)] = [F(2k+1), F(2k) + F(2k+1)]
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// [F(n), F(n+1)] = [F(2k), F(2k+1)].
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;iterative-bottom-up-approach&quot;&gt;Iterative (Bottom-up) Approach&lt;/h3&gt;

&lt;p&gt;The recursive approach is implemented from the top-down perspective.
We could also do it in bottom-up way.&lt;/p&gt;

&lt;p&gt;To convert the recursive steps into an iterative loop,
we need to find the &lt;em&gt;initialized state&lt;/em&gt; and the &lt;em&gt;stop condition&lt;/em&gt;.
In the recursive approach, no matter what &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is, the final state vector
(when the recursive steps stops) is always &lt;script type=&quot;math/tex&quot;&gt;[F_0, F_1]&lt;/script&gt;,
, and it must be called from calculating the state &lt;script type=&quot;math/tex&quot;&gt;&lt;/script&gt;[F_1, F_2]&lt;script type=&quot;math/tex&quot;&gt;&lt;/script&gt;.
Recall how we calculate &lt;script type=&quot;math/tex&quot;&gt;F_{10}&lt;/script&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We recursively calculate &lt;script type=&quot;math/tex&quot;&gt;n \leftarrow \lfloor \frac{n}{2} \rfloor&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;n = 10&lt;/script&gt;,
    &lt;ul&gt;
      &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;n = \lfloor \frac{10}{2} \rfloor = 5&lt;/script&gt;,&lt;/li&gt;
      &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;n = \lfloor \frac{5}{2} \rfloor = 2&lt;/script&gt;,&lt;/li&gt;
      &lt;li&gt;then &lt;script type=&quot;math/tex&quot;&gt;n = \lfloor \frac{2}{2} \rfloor = 1&lt;/script&gt;,&lt;/li&gt;
      &lt;li&gt;then stop recursive steps when &lt;script type=&quot;math/tex&quot;&gt;n = \lfloor \frac{1}{2} \rfloor = 0&lt;/script&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Next, we get the state vector &lt;script type=&quot;math/tex&quot;&gt;[F_n, F_{n+1}]&lt;/script&gt; for &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt;,
    &lt;ul&gt;
      &lt;li&gt;then return on the same track with opposite direction
to calculate the state vector for &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt;,&lt;/li&gt;
      &lt;li&gt;then for &lt;script type=&quot;math/tex&quot;&gt;n = 2&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;then for &lt;script type=&quot;math/tex&quot;&gt;n = 5&lt;/script&gt;,&lt;/li&gt;
      &lt;li&gt;and finally get the answer for &lt;script type=&quot;math/tex&quot;&gt;n = 10&lt;/script&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    F_0 \\
    F_1
  \end{array}
\right)
@&gt;{2n+1, 2n+2}&gt;&gt;
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@&gt;{2n, 2n+1}&gt;&gt;
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@&gt;{2n+1, 2n+2}&gt;&gt;
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@&gt;{2n, 2n+1}&gt;&gt;
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}&lt;/script&gt;

&lt;p&gt;The recursive steps are used to get the track
from &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;1, 2, 5, 10&lt;/script&gt;,
then calculate &lt;script type=&quot;math/tex&quot;&gt;[F_n, F_{n+1}]&lt;/script&gt; for each &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;To remove the recursive steps, we need to have a way to compute the track.
We can use a &lt;em&gt;stack&lt;/em&gt; to track the change for &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;, starting push &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;
from &lt;script type=&quot;math/tex&quot;&gt;n = 10&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;n = 5&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;n = 2&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt;,
then the track can be get from popping them from &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Thus, the &lt;em&gt;initialized state&lt;/em&gt; is &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt;
and the &lt;em&gt;stop condition&lt;/em&gt; is to check whether the stack is empty.&lt;/p&gt;

&lt;p&gt;(Using &lt;em&gt;stack&lt;/em&gt; is one common approach to
convert recursive code into the iterative one.)&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// To compute the track from n, n/2, ..., 1, 0.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n = floor(n/2)
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n = 0 now.
&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(n)
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(n+1)
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Initializing a, b.
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = 1
&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// k = m/2, if m is even. k = (m-1)/2, if m is odd.
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// F(2k+1) = F(k)^2 + F(k+1)^2
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// m = 2k+1:
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//  F(m) = F(2k+1)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// m = 2k:
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//  F(m) = F(2k)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;//  F(m+1) = F(2k+1)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above code is a bit ugly for simulating the recursive steps like:
&lt;script type=&quot;math/tex&quot;&gt;\require{AMScd}
\underbrace{
\begin{CD}
\left(
  \begin{array}{c}
    \boldsymbol{a} = F_0 \\
    \boldsymbol{b} = F_1
  \end{array}
\right)
@&gt;{2n+1, 2n+2}&gt;&gt;
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@&gt;{2n, 2n+1}&gt;&gt;
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@&gt;{2n+1, 2n+2}&gt;&gt;
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@&gt;{2n, 2n+1}&gt;&gt;
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}
}_{loop}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;initialized state&lt;/em&gt; is usually set outside of the loop directly like below:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = 1
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    \boldsymbol{a} = F_0 \\
    \boldsymbol{b} = F_1
  \end{array}
\right)
\end{CD}
\underbrace{
\begin{CD}
@&gt;{2n+1, 2n+2}&gt;&gt;
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@&gt;{2n, 2n+1}&gt;&gt;
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@&gt;{2n+1, 2n+2}&gt;&gt;
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@&gt;{2n, 2n+1}&gt;&gt;
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}
}_{loop}&lt;/script&gt;

&lt;p&gt;Since &lt;em&gt;initialized state&lt;/em&gt; is set before the loop,
we should start the track from &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;2, 5, 10&lt;/script&gt;:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// No `s.push(n); // n = 0 now.` here!
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Therefore, the code will be:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*n /= 2*/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = 1
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// k = m/2, if m is even. k = (m-1)/2, if m is odd.
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// F(2k+1) = F(k)^2 + F(k+1)^2
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*m % 2*/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// m = 2k+1:
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;//  F(m) = F(2k+1)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// m = 2k:
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;//  F(m) = F(2k)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;//  F(m+1) = F(2k+1)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Another trick above is to replace &lt;code class=&quot;highlighter-rouge&quot;&gt;n /= 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;n &amp;gt;&amp;gt;= 1&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;m % 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;m &amp;amp; 1&lt;/code&gt;.
It will be faster a little bit.&lt;/p&gt;

&lt;h4 id=&quot;non-stack-approach&quot;&gt;Non-stack approach&lt;/h4&gt;
&lt;p&gt;Since applying &lt;code class=&quot;highlighter-rouge&quot;&gt;std::stack&lt;/code&gt; will pay for memory allocation,
so we should try not using it for better performance.&lt;/p&gt;

&lt;p&gt;The reason we need the &lt;em&gt;stack&lt;/em&gt; is to get the &lt;strong&gt;track for each &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;&lt;/strong&gt;,
where &lt;script type=&quot;math/tex&quot;&gt;n \leftarrow \lfloor \frac{n}{2} \rfloor&lt;/script&gt; until &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt;.
And the track is used to determine what state we should update
from &lt;script type=&quot;math/tex&quot;&gt;[F_n, F_{n+1}]&lt;/script&gt;, to &lt;script type=&quot;math/tex&quot;&gt;[F_{2n}, F_{2n+1}]&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;[F_{2n+1}, F_{2n+2}]&lt;/script&gt;,
by the given &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is &lt;strong&gt;even or odd&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In the above implementation,
we put the &lt;script type=&quot;math/tex&quot;&gt;n_0 = n, n_1, n_2, ..., n_j, ..., n_{t-1}, n_t = 1&lt;/script&gt;,
where &lt;script type=&quot;math/tex&quot;&gt;n_j = \lfloor \frac{n}{2^j} \rfloor&lt;/script&gt; denotes
&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is right shifted by &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; bits(&lt;code class=&quot;highlighter-rouge&quot;&gt;n_j = n &amp;gt;&amp;gt; j&lt;/code&gt;)
and &lt;script type=&quot;math/tex&quot;&gt;j \geq 1&lt;/script&gt; is an integer,
to the &lt;em&gt;stack&lt;/em&gt;, and then iteratively check &lt;script type=&quot;math/tex&quot;&gt;n_t = 1, n_{t-1}, ..., n_2, n_1, n_0 = n&lt;/script&gt;
is odd or even.
We could do it without &lt;em&gt;stack&lt;/em&gt;!
Assume the &lt;strong&gt;highest&lt;/strong&gt; 1-bit in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt;th bit from right side,
then the loop will execute &lt;script type=&quot;math/tex&quot;&gt;h = t + 1 = \log_2 n + 1&lt;/script&gt; times.
(so the time complexity is &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt;)
Therefore, we could loop &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt; times to calculate &lt;script type=&quot;math/tex&quot;&gt;F_{n_j}&lt;/script&gt;
from &lt;script type=&quot;math/tex&quot;&gt;j = t = h-1&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j = 0&lt;/script&gt;.
As the result, the code will be:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// The position of the highest bit of n.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// So we need to loop `h` times to get the answer.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Example: n = (Dec)50 = (Bin)00110010, then h = 6.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//                               ^ 6th bit from right side
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = 1
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// n_j = floor(n / 2^j) = n &amp;gt;&amp;gt; j, k = floor(n_j / 2), (n_j = n when j = 0)
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// then a = F(k), b = F(k+1) now.
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// F(2k+1) = F(k)^2 + F(k+1)^2
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n_j is odd: k = (n_j-1)/2 =&amp;gt; n_j = 2k + 1
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//   F(n_j) = F(2k+1)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k+1)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// n_j is even: k = n_j/2 =&amp;gt; n_j = 2k
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//   F(n_j) = F(2k)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//   F(n_j + 1) = F(2k + 1)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;by-bit-mask&quot;&gt;By Bit-mask&lt;/h5&gt;
&lt;p&gt;Doing &lt;em&gt;AND&lt;/em&gt; operation(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;) to the last bit of &lt;script type=&quot;math/tex&quot;&gt;n_j&lt;/script&gt; above is same as
doing &lt;em&gt;AND&lt;/em&gt; operation(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;) &lt;strong&gt;from the highest bit to the lowest bit&lt;/strong&gt;
of the &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. Thus, we could also rewrite the code into:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// The position of the highest bit of n.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// So we need to loop `h` times to get the answer.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Example: n = (Dec)50 = (Bin)00110010, then h = 6.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//                               ^ 6th bit from right side
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(1) = 1
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// There is only one `1` in the bits of `mask`. The `1`'s position is same as
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// iteratively to do `AND` operation with `n` to check `n_j` is odd or even,
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// where n_j is defined below.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Run h times!
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &amp;gt;&amp;gt; j
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (n_j = n when j = 0), k = floor(n_j / 2), then a = F(k), b = F(k+1) now.
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// F(2k+1) = F(k)^2 + F(k+1)^2
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n_j is odd: k = (n_j-1)/2 =&amp;gt; n_j = 2k + 1
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//   F(n_j) = F(2k + 1)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// n_j is even: k = n_j/2 =&amp;gt; n_j = 2k
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//   F(n_j) = F(2k)
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//   F(n_j + 1) = F(2k + 1)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All the above code are on &lt;a href=&quot;https://gist.github.com/ChunMinChang/f80ef4decca23b88df16f2f7846049b6&quot; title=&quot;Calculating Fibonacci Numbers by Fast Doubling&quot;&gt;gist here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Algorithm&quot;]" /><category term="Fibonacci" /><category term="Recursion" /><category term="Dynamic Programming" /><summary type="html">In 
previous post,
we learned how to calculate Fibonacci numbers by Fast Doubling in math.
Today, we will apply it in programming and optimize it step by step.

Fast Doubling



It’s natural to write a recursive implementation by the above definition.
In the following steps, we will implement recursive versions first,
then try converting it into iterative versions.

Recursive (Top-down) Approach

Given a , we could calculate Fibonacci numbers  by:

if (n % 2) { // n is odd: F(n) = F(((n-1)/2) + 1)^2 + F((n-1) / 2)^2
  unsigned int k = (n - 1) / 2;
  return fib(k) * fib(k) + fib(k + 1) * fib(k + 1);
} else { // n is even: F(n) = F(n/2) * [ 2 * F(n/2 + 1) - F(n/2) ]
  unsigned int k = n / 2;
  return fib(k) * [ 2 * fib(k + 1) - fib(k) ];
}



From above code, we can know that the code stack will be entered again and again,
so we need to define when to stop it.

if (n == 0) {
  return 0; // F(0) = 0.
} else if (n &amp;lt;= 2) {
  return 1; // F(1) = F(2) = 0.
} else {
  // Keep call itself recursively to get the answer.
  // Put the main body here.
}



We only calculate Fibonacci numbers from ,
so we need to stop when .
The fib(0) may be asked from calculating fib(1) = fib(0)*fib(0) + fib(1)*fib(1)
(by setting  to ,
so we also need to define fib(1) = 1 directly,
or it will cause an endless recursion.

Similarly, the fib(1) may be asked from calculating fib(2) = fib(1) * [2 * fib(2) - fib(1)]
(by setting  to ,
so fib(2) = 1 also needs to be returned directly.

As the result, the code can be written into:
///////////////////////////////////////////////////////////////////////////////
// Fast doubling: O(log(n))
//   Using 2n to the Fibonacci matrix above, we can derive that:
//     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]
//     F(2n+1) = F(n+1)^2 + F(n)^2
//     (and F(2n-1) = F(n)^2 + F(n-1)^2)
uint64_t fib(unsigned int n)
{
  if (n == 0) {
    return 0; // F(0) = 0.
  } else if (n &amp;lt;= 2) {
    return 1; // F(1) = F(2) = 0.
  }

  unsigned int k = 0;
  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
    k = (n - 1) / 2;
    return fib(k) * fib(k) + fib(k + 1) * fib(k + 1);
  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    k = n / 2;
    return fib(k) * (2 * fib(k + 1) - fib(k));
  }
}



Now, let we look where we could improve from this simple version.
We use duplicated fib(k) and fib(k + 1) to calculate fib(n).
That is, we will have two duplicated recursive processes to do the same work.
It would be a waste of the time.

Another trick is that we could use n = n / 2 in both cases
( is odd or even) since the result of n = (n - 1) / 2 is same
as n = n / 2 in C/C++’s world if n is an odd integer.

Thus, we can rewrite the code into:

uint64_t fib(unsigned int n)
{
  if (n == 0) {
    return 0; // F(0) = 0.
  } else if (n &amp;lt;= 2) {
    return 1; // F(1) = F(2) = 1.
  }

  unsigned int k = n / 2; // k = n/2 if n is even. k = (n-1)/2 if n is odd.
  uint64_t a = fib(k);
  uint64_t b = fib(k + 1);

  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
    return a * a + b * b;
  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    return a * (2 * b - a);
  }
}



Memoization

Do we save all duplicated task now? No.
Suppose we need to find , then we need to get  ….



It’s clear that we have a duplicated  on above figure.
 can return value directly, while  can not.
Therefore, the sub-tree(sub-process) whose root is  will be executed twice.

The larger the  is, the more duplicated sub-process will be executed.
To avoid the waste, we can add an array to save all the calculated value.
We check the array first when  is calculated.
If there is already a saved value in the array at ,
then we can use it directly.
Otherwise, it will be calculated as usual.
It’s called memoization.
We will save  as the  element in the array.

In this case, the  is not calculated successively.
For example, to get , we only need .
We don’t need , so there is no value at the  element in the array.
You can use hash map instead of array to avoid the waste of memory.
However, retrieving data from array is faster than hash map,
so we apply array in our sample code:

const unsigned int SIZE = 1000;
// 4 is not a fibonacci number, so using it as initialized value.
const uint64_t INIT = 4;
// In this case, F is not calculated successively. For example,
// To get F(6), we only need F(4), F(3), F(2), F(1), F(0) (no F(5)),
// so the other elements in F is still INIT.
// Another way is to use hash map(std::unordered_map), however,
// it will be slower.
uint64_t MEM[SIZE] = { [0 ... SIZE-1] = INIT };
uint64_t fib(unsigned int n)
{
  if (MEM[n] != INIT) {
    return MEM[n];
  }

  if (n == 0) {
    return (MEM[n] = 0); // F(0) = 0.
  } else if (n &amp;lt;= 2) {
    return (MEM[n] = 1); // F(1) = F(2) = 1.
  }

  unsigned int k = n / 2; // k = n/2 if n is even. k = (n-1)/2 if n is odd.
  uint64_t a = fib(k);
  uint64_t b = fib(k + 1);

  // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2, if n is odd.
  //    F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ], if n is even.
  return (MEM[n] = (n % 2) ? a * a + b * b : a * (2 * b - a));
}



State vector
Although we can speed up the calculating by applying memoization above,
the memory consumption with this approach grows with .
Is it possible to use a fixed memory no matter how big  is?
The answer is yes. Actually, we could just use a two-elements array to do it.

From the formula, we can calculate  from .
For example, to calculate , we need .
To calculate , we need .
To calculate , we need .
To calculate , we need 
(so we need to stop here since  is the dead end).

However, how do we get 
when we only have  to calculate ?
Or how to get 
when we only have  to calculate  …?

By applying  to formula, we can use  to get .
Then we can get .

Thus, we are able to get  by the following procedure:



Thus, we could keep using two-elements array
for 
to compute what we want and update it step by step.

But how to determine the state we should update from ,
 or  ?

It’s simple. If  is even, we need to find 
, where  since .
Then we can use 
to calculate .

Otherwise, if  is odd, we need to find 
, where  since .
Then we can use 
to calculate 
and then get  by .

In summary, the procedure can be organized as follows:


  
    
      
      
      
      
      
      
    
  
  
    
      
      10
      5
      2
      1
      0
    
    
       is odd
       
      v
       
      v
       
    
    
      
       
      
       
      
       
    
    
      
      
      
      
      
      
    
    
      
       
      
      
      
      
    
  


The last two rows, , are the state vector
that contains our answer.

The first row , is the index of the first element
of the state vector .
The second row indicates that whether  is odd or not.
If  is odd(recall what we discuss above),
then we need to update state from from 
to  since .
The third row is used to record if we need get 
from .
Otherwise, if  is even, updating state
from  to  directly.

From the top-down perspective, to get , we need .
To get , we need .
To get , we need .
To get , we need .
We will demonstrate how we do it recursively below.

From the bottom-up perspective, we can use 
to get ,
then  to get ,
 to get ,
 to get .
We will demonstrate how we do it in iterative section.

The recursive approach is easier to understand.
By what we summarized above, the simplest implementation will be:

// Set f[0], f[1] to F(n), F(n+1).
void fib_helper(unsigned int n, uint64_t f[]);

// 4 is not a fibonacci number, so using it as initialized value.
const uint64_t INIT = 4;

uint64_t fib(unsigned int n)
{
  uint64_t f[2] = { INIT, INIT };
  fib_helper(n, f);
  return f[0];
}

void fib_helper(unsigned int n, uint64_t f[])
{
  if (n == 0) {
    f[0] = 0; f[1] = 1;
    return;
  }

  unsigned int k = 0;
  if (n % 2) {
    k = (n - 1) / 2;
    fib_helper(k, f);
    uint64_t a = f[0];            // F(k) = F((n-1)/2)
    uint64_t b = f[1];            // F(k + 1) = F((n- )/2 + 1)
    uint64_t c = a * (2 * b - a); // F(n-1) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]
    uint64_t d = a * a + b * b;   // F(n) = F(2k + 1) = F(k)^2 + F(k+1)^2
    f[0] = d;                     // F(n)
    f[1] = c + d;                 // F(n+1) = F(n-1) + F(n)
  } else {
    k = n / 2;
    fib_helper(k, f);
    uint64_t a = f[0];            // F(k) = F(n/2)
    uint64_t b = f[1];            // F(k + 1) = F(n/2 + 1)
    f[0] = a * (2 * b - a);       // F(n) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]
    f[1] = a * a + b * b;         // F(n + 1) = F(2k + 1) = F(k)^2 + F(k+1)^2
  }
}



The above fib_helper is quite tedious,
we can be simplify it into:
// Set f[0], f[1] to F(n), F(n+1).
void fib_helper(unsigned int n, uint64_t f[])
{
  if (!n) {
    f[0] = 0;
    f[1] = 1;
    return;
  }

  fib_helper(n / 2, f);
  // k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.
  uint64_t a = f[0]; // F(k)
  uint64_t b = f[1]; // F(k+1)

  uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
  uint64_t d = a * a + b * b;   // F(2k+1) = F(k+1)^2 + F(k)^2

  if (n % 2) {    // k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).
    f[0] = d;     // F(n) = F(2k+1).
    f[1] = c + d; // F(n+1) = F(n-1) + F(n) = F(2k) + F(2k+1).
  } else {        // k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).
    f[0] = c;     // F(n) = F(2k).
    f[1] = d;     // F(n+1) = F(2k).
  }
}



You could also replace array with std::vector,
so the code will looks more elegant.
However, it will be slower than using array directly.
// Return vector [ F(n), F(n+1) ].
std::vector&amp;lt;uint64_t&amp;gt; fib_helper(unsigned int n);

uint64_t fib(unsigned int n)
{
  return fib_helper(n)[0];
}

std::vector&amp;lt;uint64_t&amp;gt; fib_helper(unsigned int n)
{
  if (!n) {
    // [F(0), F(1)] = [0 , 1]
    return { 0 , 1 };
  }

  std::vector&amp;lt;uint64_t&amp;gt; f(fib_helper(n / 2));
  // k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.
  uint64_t a = f[0]; // F(k)
  uint64_t b = f[1]; // F(k+1)

  uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
  uint64_t d = a * a + b * b;   // F(2k+1) = F(k+1)^2 + F(k)^2

  if (n % 2) { // k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).
    // [F(n), F(n+1)] = [F(2k+1), F(2k+2)] = [F(2k+1), F(2k) + F(2k+1)]
    return { d, c + d };
  } else { // k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).
    // [F(n), F(n+1)] = [F(2k), F(2k+1)].
    return { c, d };
  }
}



Iterative (Bottom-up) Approach

The recursive approach is implemented from the top-down perspective.
We could also do it in bottom-up way.

To convert the recursive steps into an iterative loop,
we need to find the initialized state and the stop condition.
In the recursive approach, no matter what  is, the final state vector
(when the recursive steps stops) is always ,
, and it must be called from calculating the state [F_1, F_2].
Recall how we calculate :


  We recursively calculate  from ,
    
      then ,
      then ,
      then ,
      then stop recursive steps when .
    
  
  Next, we get the state vector  for ,
    
      then return on the same track with opposite direction
to calculate the state vector for ,
      then for 
      then for ,
      and finally get the answer for .
    
  




The recursive steps are used to get the track
from  to ,
then calculate  for each .

To remove the recursive steps, we need to have a way to compute the track.
We can use a stack to track the change for , starting push 
from , then , , , ,
then the track can be get from popping them from  to .

Thus, the initialized state is 
and the stop condition is to check whether the stack is empty.

(Using stack is one common approach to
convert recursive code into the iterative one.)

uint64_t fib(unsigned int n)
{
  // To compute the track from n, n/2, ..., 1, 0.
  std::stack&amp;lt;unsigned int&amp;gt; s;
  while(n) {
    s.push(n);
    n /= 2; // n = floor(n/2)
  }
  s.push(n); // n = 0 now.

  uint64_t a; // F(n)
  uint64_t b; // F(n+1)
  while (!s.empty()) {
    unsigned int m = s.top(); s.pop();

    if (m == 0) { // Initializing a, b.
      a = 0; // F(0) = 0
      b = 1; // F(1) = 1
      continue;
    }

    // Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.
    // k = m/2, if m is even. k = (m-1)/2, if m is odd.
    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2

    if (m % 2) {  // m = 2k+1:
      a = d;      //  F(m) = F(2k+1)
      b = c + d;  //  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)
    } else {      // m = 2k:
      a = c;      //  F(m) = F(2k)
      b = d;      //  F(m+1) = F(2k+1)
    }
  }

  return a;
}



The above code is a bit ugly for simulating the recursive steps like:


The initialized state is usually set outside of the loop directly like below:

...
uint64_t a = 0; // F(0) = 0
uint64_t b = 1; // F(1) = 1
while (!s.empty()) {
  ...
}
...





Since initialized state is set before the loop,
we should start the track from  to :
std::stack&amp;lt;unsigned int&amp;gt; s;
while (n) {
  s.push(n);
  n /= 2;
}
// No `s.push(n); // n = 0 now.` here!



Therefore, the code will be:
uint64_t fib(unsigned int n)
{
  std::stack&amp;lt;unsigned int&amp;gt; s;
  while (n) {
    s.push(n);
    /*n /= 2*/n &amp;gt;&amp;gt;= 1;
  }

  uint64_t a = 0; // F(0) = 0
  uint64_t b = 1; // F(1) = 1
  while (!s.empty()) {
    unsigned int m = s.top(); s.pop();

    // Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.
    // k = m/2, if m is even. k = (m-1)/2, if m is odd.
    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2

    if (/*m % 2*/m &amp;amp; 1) { // m = 2k+1:
      a = d;              //  F(m) = F(2k+1)
      b = c + d;          //  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)
    } else {              // m = 2k:
      a = c;              //  F(m) = F(2k)
      b = d;              //  F(m+1) = F(2k+1)
    }
  }

  return a;
}


Another trick above is to replace n /= 2 by n &amp;gt;&amp;gt;= 1
and m % 2 by m &amp;amp; 1.
It will be faster a little bit.

Non-stack approach
Since applying std::stack will pay for memory allocation,
so we should try not using it for better performance.

The reason we need the stack is to get the track for each ,
where  until .
And the track is used to determine what state we should update
from , to  or ,
by the given  is even or odd.

In the above implementation,
we put the ,
where  denotes
 is right shifted by  bits(n_j = n &amp;gt;&amp;gt; j)
and  is an integer,
to the stack, and then iteratively check 
is odd or even.
We could do it without stack!
Assume the highest 1-bit in  is the th bit from right side,
then the loop will execute  times.
(so the time complexity is )
Therefore, we could loop  times to calculate 
from  to .
As the result, the code will be:
uint64_t fib(unsigned int n)
{
  // The position of the highest bit of n.
  // So we need to loop `h` times to get the answer.
  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.
  //                               ^ 6th bit from right side
  unsigned int h = 0;
  for (unsigned int i = n ; i ; ++h, i &amp;gt;&amp;gt;= 1);

  uint64_t a = 0; // F(0) = 0
  uint64_t b = 1; // F(1) = 1
  for (int j = h - 1 ; j &amp;gt;= 0 ; --j) {
    // n_j = floor(n / 2^j) = n &amp;gt;&amp;gt; j, k = floor(n_j / 2), (n_j = n when j = 0)
    // then a = F(k), b = F(k+1) now.
    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2

    if ((n &amp;gt;&amp;gt; j) &amp;amp; 1) { // n_j is odd: k = (n_j-1)/2 =&amp;gt; n_j = 2k + 1
      a = d;            //   F(n_j) = F(2k+1)
      b = c + d;        //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k+1)
    } else {            // n_j is even: k = n_j/2 =&amp;gt; n_j = 2k
      a = c;            //   F(n_j) = F(2k)
      b = d;            //   F(n_j + 1) = F(2k + 1)
    }
  }

  return a;
}



By Bit-mask
Doing AND operation(&amp;amp;) to the last bit of  above is same as
doing AND operation(&amp;amp;) from the highest bit to the lowest bit
of the . Thus, we could also rewrite the code into:

uint64_t fib(unsigned int n)
{
  // The position of the highest bit of n.
  // So we need to loop `h` times to get the answer.
  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.
  //                               ^ 6th bit from right side
  unsigned int h = 0;
  for (unsigned int i = n ; i ; ++h, i &amp;gt;&amp;gt;= 1);

  uint64_t a = 0; // F(0) = 0
  uint64_t b = 1; // F(1) = 1
  // There is only one `1` in the bits of `mask`. The `1`'s position is same as
  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right
  // iteratively to do `AND` operation with `n` to check `n_j` is odd or even,
  // where n_j is defined below.
  for (unsigned int mask = 1 &amp;lt;&amp;lt; (h - 1) ; mask ; mask &amp;gt;&amp;gt;= 1) { // Run h times!
    // Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &amp;gt;&amp;gt; j
    // (n_j = n when j = 0), k = floor(n_j / 2), then a = F(k), b = F(k+1) now.
    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2

    if (mask &amp;amp; n) { // n_j is odd: k = (n_j-1)/2 =&amp;gt; n_j = 2k + 1
      a = d;        //   F(n_j) = F(2k + 1)
      b = c + d;    //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)
    } else {        // n_j is even: k = n_j/2 =&amp;gt; n_j = 2k
      a = c;        //   F(n_j) = F(2k)
      b = d;        //   F(n_j + 1) = F(2k + 1)
    }
  }

  return a;
}



All the above code are on gist here.</summary></entry><entry><title type="html">Matrix Difference Equation for Fibonacci Sequence</title><link href="http://localhost:4000/post/matrix-difference-equation-for-fibonacci-sequence" rel="alternate" type="text/html" title="Matrix Difference Equation for Fibonacci Sequence" /><published>2017-08-22T00:00:00+08:00</published><updated>2017-08-22T00:00:00+08:00</updated><id>http://localhost:4000/post/matrix-difference-equation-for-fibonacci-sequence</id><content type="html" xml:base="http://localhost:4000/post/matrix-difference-equation-for-fibonacci-sequence">&lt;h2 id=&quot;recurrence-relation&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot; title=&quot;Recurrence relation&quot;&gt;Recurrence relation&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Suppose we have a difference equation defined by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_n = a \cdot x_{n - 1} + b \cdot x_{n - 2}&lt;/script&gt;

&lt;p&gt;Then,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_n &amp;= a \cdot x_{n - 1} + b \cdot x_{n - 2}
\\
x_{n - 1} &amp;= 1 \cdot x_{n - 1} + 0 \cdot x_{n - 2}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;could be written into a matrix form(&lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_difference_equation&quot; title=&quot;Matrix difference equation&quot;&gt;&lt;em&gt;matrix difference equation&lt;/em&gt;&lt;/a&gt;):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\vec{x_n} =
\begin{bmatrix} x_n \\ x_{n - 1} \end{bmatrix}
=
\begin{bmatrix} a &amp; b \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} x_{n - 1} \\ x_{n - 2} \end{bmatrix}
=
S \cdot \vec{x_{n-1}} %]]&gt;&lt;/script&gt;

&lt;p&gt;Since &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; can transit the state from &lt;script type=&quot;math/tex&quot;&gt;\vec{x_{n-1}}&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\vec{x_n}&lt;/script&gt;,
the state vector can be expanded by adding any pair &lt;script type=&quot;math/tex&quot;&gt;\vec{x_{t-1}}, \vec{x_t}&lt;/script&gt;
to the above equation.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_t, x_n &amp;= a \cdot x_{t - 1} + b \cdot x_{t - 2}, a \cdot x_{n - 1} + b \cdot x_{n - 2}
\\
x_{t - 1}, x_{n - 1} &amp;= 1 \cdot x_{t - 1} + 0 \cdot x_{t - 2}, 1 \cdot x_{n - 1} + 0 \cdot x_{n - 2}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;can be written into&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix} x_t &amp; x_n \\ x_{t - 1} &amp; x_{n - 1} \end{bmatrix}
=
\begin{bmatrix} a &amp; b \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} x_{t - 1} &amp; x_{n - 1} \\ x_{t - 2} &amp; x_{n - 2} \end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;In fact, this can be generalized.
Given &lt;script type=&quot;math/tex&quot;&gt;y_n&lt;/script&gt; by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_n = c_{n - 1} \cdot y_{n - 1} +
      c_{n - 2} \cdot y_{n - 2} +
      \cdots +
      c_0 \cdot y_0&lt;/script&gt;

&lt;p&gt;, where &lt;script type=&quot;math/tex&quot;&gt;c_k&lt;/script&gt; is constant and &lt;script type=&quot;math/tex&quot;&gt;k \in [0, n-1]&lt;/script&gt; is a integer.&lt;/p&gt;

&lt;p&gt;then we can rewritten the equations into:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\vec{y_n} =
\begin{bmatrix}
  y_n \\
  y_{n - 1} \\
  \vdots \\
  y_1
\end{bmatrix}
=
\begin{bmatrix}
  c_{n - 1} &amp; c_{n - 2} &amp; \cdots &amp; c_1 &amp; c_0 \\
  1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 \\
  \vdots \\
  0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0
\end{bmatrix}
\cdot
\begin{bmatrix}
  y_{n - 1} \\
  y_{n - 2} \\
  \vdots \\
  y_0
\end{bmatrix}
= C \cdot\ \vec{y_{n - 1}} %]]&gt;&lt;/script&gt;

&lt;p&gt;and we could expand the matrix to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
  y_{2n - 1} &amp; \cdots &amp; y_{n + 1} &amp; y_n \\
  y_{2n - 2} &amp; \cdots &amp; y_n &amp; y_{n - 1} \\
  \vdots \\
  y_n &amp; \cdots &amp; y_2 &amp; y_1
\end{bmatrix}
=
\begin{bmatrix}
  c_{n - 1} &amp; c_{n - 2} &amp; \cdots &amp; c_1 &amp; c_0 \\
  1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 \\
  \vdots \\
  0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0
\end{bmatrix}
\cdot
\begin{bmatrix}
  y_{2n - 2} &amp; \cdots &amp; y_n &amp; y_{n - 1} \\
  y_{2n - 3} &amp; \cdots &amp; y_{n - 1} &amp; y_{n - 2} \\
  \vdots \\
  y_{n - 1} &amp; \cdots &amp; y_1 &amp; y_0
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;fibonacci-sequence&quot;&gt;Fibonacci Sequence&lt;/h2&gt;

&lt;p&gt;Fibonacci number is defined by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_n = F_{n - 1} + F_{n - 2}, \text{where } F_0 = 0 \text{ and } F_1 = 0&lt;/script&gt;

&lt;p&gt;Obviously, &lt;em&gt;Fibonacci&lt;/em&gt; sequence is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot; title=&quot;Recurrence relation&quot;&gt;&lt;em&gt;difference equation&lt;/em&gt;&lt;/a&gt;
(&lt;script type=&quot;math/tex&quot;&gt;a = b = 1&lt;/script&gt; in above example) and it could be written in:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\vec{F_n} =
\begin{bmatrix} F_n \\ F_{F - 1} \end{bmatrix}
=
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_{n - 1} \\ F_{n - 2} \end{bmatrix}
=
S \cdot \vec{F_{n-1}} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;matrix-form&quot;&gt;Matrix Form&lt;/h3&gt;

&lt;p&gt;If we expand the &lt;script type=&quot;math/tex&quot;&gt;\vec{F_n}&lt;/script&gt; by taking &lt;script type=&quot;math/tex&quot;&gt;t = n + 1&lt;/script&gt; in above example,
then&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
&amp;=
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_n &amp; F_{n - 1} \\ F_{n - 1} &amp; F_{n - 2} \end{bmatrix}
\\
&amp;=
{\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^2
\cdot
\begin{bmatrix} F_{n - 1} &amp; F_{n - 2} \\ F_{n - 2} &amp; F_{n - 3} \end{bmatrix}
\\
\vdots
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} F_2 &amp; F_1 \\ F_1 &amp; F_0 \end{bmatrix}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\end{align} %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;computing-fibonacci-number-by-exponentiation&quot;&gt;Computing &lt;em&gt;Fibonacci&lt;/em&gt; number by exponentiation&lt;/h4&gt;
&lt;p&gt;By the above formula, the &lt;em&gt;Fibonacci&lt;/em&gt; number &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt;
can be calculated in &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt;.
The key is to compute the exponentiation by squaring.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  &amp; \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;I explained how to do it in my
&lt;!-- [previous post](/post/exponentiation-by-squaring) --&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/exponentiation-by-squaring&quot;&gt;previous post&lt;/a&gt;.
Please read it if you need.&lt;/p&gt;

&lt;p&gt;As a result, we can compute &lt;em&gt;Fibonacci&lt;/em&gt; number &lt;script type=&quot;math/tex&quot;&gt;F_n&lt;/script&gt; as follows:&lt;/p&gt;

&lt;h5 id=&quot;by-stdvector&quot;&gt;By &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt;&lt;/h5&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Matrix&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Matrix&amp;amp; m)
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   for (unsigned int i = 0; i &amp;lt; m.rows; ++i) {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     for (unsigned int j = 0; j &amp;lt; m.cols; ++j) {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//       os &amp;lt;&amp;lt; m.data[i][j] &amp;lt;&amp;lt; &quot; &quot;;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     }
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     os &amp;lt;&amp;lt; std::endl;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   }
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   return os;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// }
&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Check if they can be multiplied.
&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Calculate the power by fast doubling:
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   k ^ n = (k^2) ^ (n/2)          , if n is even
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//        or k x (k^2) ^ ((k-1)/2)  , if n is odd
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Copy constructor = Matrix x(rows, cols, data);
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*n % 2*/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;cm&quot;&gt;/*n /= 2*/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci_matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Using F.data[0][1] since n might be 0.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// (we need to power by n - 1 if we return F.data[0][0].)
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;by-native-array&quot;&gt;By Native Array&lt;/h5&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Matrix&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;AllocateData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// copy ctor
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AllocateData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FreeData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Matrix&amp;amp; m)
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   for (unsigned int i = 0; i &amp;lt; m.rows; ++i) {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     for (unsigned int j = 0; j &amp;lt; m.cols; ++j) {
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//       os &amp;lt;&amp;lt; m.data[i][j] &amp;lt;&amp;lt; &quot; &quot;;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     }
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     os &amp;lt;&amp;lt; std::endl;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   }
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   return os;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// }
&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// move assignment
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;FreeData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Free this data if it exists.
&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// Move original other.data to data and set other.data to nullptr.
&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// data = std::exchange(other.data, nullptr); // C++14
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Check if they can be multiplied.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Calculate the power by fast doubling:
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//   k ^ n = (k^2) ^ (n/2)          , if n is even
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//        or k x (k^2) ^ ((k-1)/2)  , if n is odd
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Copy constructor = Matrix x(rows, cols, data);
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*n % 2*/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;cm&quot;&gt;/*n /= 2*/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AllocateData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FreeData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fibonacci_matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Using F.data[0][1] since n might be 0.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// (we need to power by n - 1 if we return F.data[0][0].)
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;fast-doubling&quot;&gt;Fast Doubling&lt;/h3&gt;

&lt;p&gt;If we calculate &lt;script type=&quot;math/tex&quot;&gt;F_{2n}&lt;/script&gt; directly, we can get the equation follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\begin{bmatrix} F_{2n+1} &amp; F_{2n} \\ F_{2n} &amp; F_{2n - 1} \end{bmatrix}
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^{2n}
\\
&amp;= {\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\cdot
{\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}}^n
\\
&amp;= \begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
\cdot \begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n - 1} \end{bmatrix}
\\
&amp;=
\begin{bmatrix}
  {F_{n+1}}^2 + {F_n}^2 &amp; F_n \cdot (F_{n+1} + F_{n-1}) \\
  F_n \cdot (F_{n+1} + F_{n-1}) &amp; {F_n}^2 + {F_{n-1}}^2
\end{bmatrix}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, &lt;script type=&quot;math/tex&quot;&gt;F_{2n}, F_{2n + 1}&lt;/script&gt; can be calculated by &lt;script type=&quot;math/tex&quot;&gt;F_n, F_{n+1}&lt;/script&gt; since&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
F_{2n+1} &amp;= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &amp;= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &amp;= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &amp;= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;This two equations help us to calculate &lt;script type=&quot;math/tex&quot;&gt;F_{N}&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;O(\log N)&lt;/script&gt; time,
since &lt;script type=&quot;math/tex&quot;&gt;F_{N}&lt;/script&gt; can be derived from &lt;script type=&quot;math/tex&quot;&gt;F_{2N'}&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;F_{2N' + 1}&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;implementation&quot;&gt;implementation&lt;/h4&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////////////////////
// Fast doubling: O(log(n))
//   Using 2n to the Fibonacci matrix above, we can derive that:
//     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]
//     F(2n+1) = F(n+1)^2 + F(n)^2
//     (and F(2n-1) = F(n)^2 + F(n-1)^2)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// When n = 2: k = 1 and we want to use F(k+1) to calculate F(2k),
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// However, F(2k) = F(k+1) = F(2) is unknown then.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(0) = 0, F(1) = 1.
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// F(2) = 1
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The implementation are easy to understand
but it still has a lot of room to improve.
We will discuss it in
&lt;!-- [next post](/post/calculating-fibonacci-numbers-by-fast-doubling) --&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/calculating-fibonacci-numbers-by-fast-doubling&quot;&gt;next post&lt;/a&gt;.
Stay tuned!&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Algorithm&quot;, &quot;Math&quot;]" /><category term="Fibonacci" /><category term="Recursion" /><category term="Dynamic Programming" /><summary type="html">Recurrence relation

Suppose we have a difference equation defined by:



Then,



could be written into a matrix form(matrix difference equation):



Since  can transit the state from  to ,
the state vector can be expanded by adding any pair 
to the above equation.

For example,



can be written into



In fact, this can be generalized.
Given  by:



, where  is constant and  is a integer.

then we can rewritten the equations into:



and we could expand the matrix to



Fibonacci Sequence

Fibonacci number is defined by:



Obviously, Fibonacci sequence is a difference equation
( in above example) and it could be written in:



Matrix Form

If we expand the  by taking  in above example,
then



Computing Fibonacci number by exponentiation
By the above formula, the Fibonacci number 
can be calculated in .
The key is to compute the exponentiation by squaring.



I explained how to do it in my

previous post.
Please read it if you need.

As a result, we can compute Fibonacci number  as follows:

By std::vector
class Matrix
{
public:
  Matrix(unsigned int r, unsigned int c,
         std::vector&amp;lt;std::vector&amp;lt;uint64_t&amp;gt;&amp;gt; d)
    : rows(r)
    , cols(c)
    , data(d)
  {
  }

  Matrix(unsigned int r, unsigned int c)
    : rows(r)
    , cols(c)
  {
    assert(rows &amp;amp;&amp;amp; cols);
    data.resize(rows);
    for (unsigned int i = 0 ; i &amp;lt; rows ; ++i) {
      data[i].resize(cols);
    }
  }

  ~Matrix()
  {
  }

  uint64_t Read(unsigned int r, unsigned int c)
  {
    return data[r][c];
  }

  // friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Matrix&amp;amp; m)
  // {
  //   for (unsigned int i = 0; i &amp;lt; m.rows; ++i) {
  //     for (unsigned int j = 0; j &amp;lt; m.cols; ++j) {
  //       os &amp;lt;&amp;lt; m.data[i][j] &amp;lt;&amp;lt; &quot; &quot;;
  //     }
  //     os &amp;lt;&amp;lt; std::endl;
  //   }
  //   return os;
  // }

  Matrix operator*(const Matrix&amp;amp; other)
  {
    assert(cols == other.rows); // Check if they can be multiplied.

    Matrix z(rows, other.cols);
    for (unsigned int i = 0 ; i &amp;lt; rows ; ++i) {
      for (unsigned int j = 0 ; j &amp;lt; other.cols; ++j) {
        for (unsigned int k = 0 ; k &amp;lt; cols; ++k) {
          z.data[i][j] += data[i][k] * other.data[k][j];
        }
      }
    }

    return z;
  }

  // Calculate the power by fast doubling:
  //   k ^ n = (k^2) ^ (n/2)          , if n is even
  //        or k x (k^2) ^ ((k-1)/2)  , if n is odd
  Matrix pow(unsigned int n)
  {
    Matrix x(*this); // Copy constructor = Matrix x(rows, cols, data);
    Matrix r = Identity(rows);
    while (n) {
      if (/*n % 2*/n &amp;amp; 1) {
        r = r * x;
      }
      x = x * x;
      /*n /= 2*/n &amp;gt;&amp;gt;= 1;
    }
    return r;
  }

private:
  Matrix Identity(unsigned int size)
  {
    Matrix z(size, size);
    for (unsigned int i = 0 ; i &amp;lt; size ; ++i) {
      z.data[i][i] = 1;
    }
    return z;
  }

  unsigned int rows;
  unsigned int cols;
  std::vector&amp;lt;std::vector&amp;lt;uint64_t&amp;gt;&amp;gt; data;
};

// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
uint64_t fibonacci_matrix(unsigned int n)
{
  Matrix F { 2, 2, {
    { 1, 1 },
    { 1, 0 }
  } };

  // Using F.data[0][1] since n might be 0.
  // (we need to power by n - 1 if we return F.data[0][0].)
  F = F.pow(n);
  return F.Read(0, 1);
}



By Native Array
class Matrix
{
public:
  Matrix(unsigned int r, unsigned int c, uint64_t** d = nullptr)
    : rows(r)
    , cols(c)
    , data(d)
  {
    if (!data) {
      AllocateData();
    }
  }

  Matrix(const Matrix&amp;amp; other) // copy ctor
    : rows(other.rows)
    , cols(other.cols)
  {
    assert(!data);
    AllocateData();
    for (unsigned int i = 0 ; i &amp;lt; rows ; ++i) {
      for (unsigned int j = 0 ; j &amp;lt; cols ; ++j) {
        data[i][j] = other.data[i][j];
      }
    }
  }

  ~Matrix()
  {
    FreeData();
  }

  uint64_t Read(unsigned int r, unsigned int c)
  {
    return data[r][c];
  }

  // friend std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Matrix&amp;amp; m)
  // {
  //   for (unsigned int i = 0; i &amp;lt; m.rows; ++i) {
  //     for (unsigned int j = 0; j &amp;lt; m.cols; ++j) {
  //       os &amp;lt;&amp;lt; m.data[i][j] &amp;lt;&amp;lt; &quot; &quot;;
  //     }
  //     os &amp;lt;&amp;lt; std::endl;
  //   }
  //   return os;
  // }

  Matrix&amp;amp; operator=(Matrix&amp;amp;&amp;amp; other) noexcept // move assignment
  {
    if(this != &amp;amp;other) {
      FreeData(); // Free this data if it exists.
      // Move original other.data to data and set other.data to nullptr.
      // data = std::exchange(other.data, nullptr); // C++14
      data = other.data;
      other.data = nullptr;
    }
    return *this;
  }

  Matrix operator*(const Matrix&amp;amp; other)
  {
    assert(cols == other.rows); // Check if they can be multiplied.
    Matrix z(rows, other.cols);

    for (unsigned int i = 0 ; i &amp;lt; rows ; ++i) {
      for (unsigned int j = 0 ; j &amp;lt; other.cols; ++j) {
        for (unsigned int k = 0 ; k &amp;lt; cols; ++k) {
          z.data[i][j] += data[i][k] * other.data[k][j];
        }
      }
    }

    return z;
  }

  // Calculate the power by fast doubling:
  //   k ^ n = (k^2) ^ (n/2)          , if n is even
  //        or k x (k^2) ^ ((k-1)/2)  , if n is odd
  Matrix pow(unsigned int n)
  {
    Matrix x(*this); // Copy constructor = Matrix x(rows, cols, data);
    Matrix r = Identity(rows);
    while (n) {
      if (/*n % 2*/n &amp;amp; 1) {
        r = r * x;
      }
      x = x * x;
      /*n /= 2*/n &amp;gt;&amp;gt;= 1;
    }
    return r;
  }

private:
  Matrix Identity(unsigned int size)
  {
    Matrix z(size, size);
    for (unsigned int i = 0 ; i &amp;lt; size ; ++i) {
      z.data[i][i] = 1;
    }
    return z;
  }

  void AllocateData()
  {
    assert(!data);
    data = (uint64_t**) calloc(rows, sizeof(uint64_t*));
    for (unsigned int i = 0 ; i &amp;lt; rows ; ++i) {
      data[i] = (uint64_t*) calloc(cols, sizeof(uint64_t));
    }
  }

  void FreeData()
  {
    if (!data) {
      return;
    }

    assert(rows);
    for (unsigned int i = 0 ; i &amp;lt; rows ; ++i) {
      free(data[i]);
    }
    free(data);
    data = nullptr;
  }

  unsigned int rows;
  unsigned int cols;
  uint64_t** data = nullptr;
};

// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
uint64_t fibonacci_matrix(unsigned int n)
{
  Matrix F { 2, 2, new uint64_t*[2] {
    new uint64_t[2] { 1, 1 },
    new uint64_t[3] { 1, 0 }
  } };

  // Using F.data[0][1] since n might be 0.
  // (we need to power by n - 1 if we return F.data[0][0].)
  F = F.pow(n);
  return F.Read(0, 1);
}



Fast Doubling

If we calculate  directly, we can get the equation follows:



Thus,  can be calculated by  since



This two equations help us to calculate  in  time,
since  can be derived from  or .

implementation

///////////////////////////////////////////////////////////////////////////////
// Fast doubling: O(log(n))
//   Using 2n to the Fibonacci matrix above, we can derive that:
//     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]
//     F(2n+1) = F(n+1)^2 + F(n)^2
//     (and F(2n-1) = F(n)^2 + F(n-1)^2)
uint64_t fib(unsigned int n)
{
  // When n = 2: k = 1 and we want to use F(k+1) to calculate F(2k),
  // However, F(2k) = F(k+1) = F(2) is unknown then.
  if (n &amp;lt; 2) {
    return n; // F(0) = 0, F(1) = 1.
  } else if (n == 2) {
    return 1; // F(2) = 1
  }

  unsigned int k = 0;
  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
    k = (n - 1) / 2;
    return fib(k + 1) * fib(k + 1) + fib(k) * fib(k);
  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
    k = n / 2;
    return fib(k) * (2 * fib(k + 1) - fib(k));
  }
}


The implementation are easy to understand
but it still has a lot of room to improve.
We will discuss it in

next post.
Stay tuned!</summary></entry><entry><title type="html">Exponentiation by squaring</title><link href="http://localhost:4000/post/exponentiation-by-squaring" rel="alternate" type="text/html" title="Exponentiation by squaring" /><published>2017-08-19T00:00:00+08:00</published><updated>2017-08-19T00:00:00+08:00</updated><id>http://localhost:4000/post/exponentiation-by-squaring</id><content type="html" xml:base="http://localhost:4000/post/exponentiation-by-squaring">&lt;p&gt;What is the time complexity of the computation for &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt;?
We might intuitively think it’s &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;.
In fact, it can be done in &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt;
by &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponentiation_by_squaring&quot;&gt;exponentiation by squaring&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The key idea is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
(k^\frac{n}{2})^2,  &amp; \text{if $n$ is even} \\
k \cdot (k^\frac{n-1}{2})^2, &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  &amp; \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;By dividing &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\frac{n}{2}&lt;/script&gt; again and again,
then stop when &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt;,
we could solve &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;O(\log n)&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;top-down-approach&quot;&gt;Top-down Approach&lt;/h2&gt;

&lt;h3 id=&quot;recursive&quot;&gt;Recursive&lt;/h3&gt;
&lt;p&gt;If we apply the first conversion, we could get the following code:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above program uses two same recursions, &lt;code class=&quot;highlighter-rouge&quot;&gt;... * pow1(...) * pow1(...)&lt;/code&gt;,
as the returned value, so it will duplicate two same stacks.
On the other hand, if we apply the second conversion,
then there is no duplicated stack needed.
It could save almost half computation time of the &lt;code class=&quot;highlighter-rouge&quot;&gt;pow1&lt;/code&gt;
since it only uses half recursions than &lt;code class=&quot;highlighter-rouge&quot;&gt;pow1&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above code still could be simplified.
The result of the division &lt;script type=&quot;math/tex&quot;&gt;y = \frac{x}{2}&lt;/script&gt; is
actually &lt;script type=&quot;math/tex&quot;&gt;y = \lfloor \frac{x}{2} \rfloor&lt;/script&gt; in the world of &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;C++&lt;/em&gt;,
if &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; is an integer.&lt;/p&gt;

&lt;p&gt;That is, if &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is an &lt;strong&gt;odd&lt;/strong&gt; integer,
then the result of &lt;code class=&quot;highlighter-rouge&quot;&gt;n = (n - 1) / 2&lt;/code&gt; is same as &lt;code class=&quot;highlighter-rouge&quot;&gt;n = n / 2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Thus, the code could be simplified as follows:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// so x = (k^2)^(n/2),      if n is even
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//     or (k^2)^((n-1)/2),  if n is odd
&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// so x = k * (k^2)^((n-1)/2)
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Another trick is that We could replace &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b / 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b &amp;gt;&amp;gt; 1&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b % 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b &amp;amp; 0x01&lt;/code&gt;.
(But I guess your compiler might already do that for you.)&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;iterative&quot;&gt;Iterative&lt;/h3&gt;
&lt;p&gt;If we could rewrite a recursive algorithm into an iterative version,
it usually run faster.&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is always even, then it’s easy to calculate in a loop.
For example, when &lt;script type=&quot;math/tex&quot;&gt;k = 3, n = 8&lt;/script&gt;, we can calculate &lt;script type=&quot;math/tex&quot;&gt;k^n = 3^8&lt;/script&gt;
by &lt;script type=&quot;math/tex&quot;&gt;3^8 = (3^2)^4 = ((3^2)^2)^2 = (((3^2)^2)^2)^1&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Thus, we can find &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt; by:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_0 = 3, n_0 = 8&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = k_0^{n_0}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1 = k_0^2 = 3^2, n_1 = \frac{n_0}{2} = 4&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = k_1^{n_1}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2 = (k_1)^2 = 3^4, n_2 = \frac{n_1}{2} = 2&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = k_2^{n_2}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_3 = (k_2)^2 = 3^8, n_3 = \frac{n_2}{2} = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = k_3^{n_3}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;n_3 = 1&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;k^n = k_3^{n_3} = k_3 = 3^8&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;On the other hand, if &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is not always even,
then we need to deal with the single leading &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;
in the &lt;script type=&quot;math/tex&quot;&gt;k \cdot (k^2)^\frac{n-1}{2}&lt;/script&gt;,
which will not used to square.
For example, when &lt;script type=&quot;math/tex&quot;&gt;k = 3, n = 7&lt;/script&gt;, we can calculate &lt;script type=&quot;math/tex&quot;&gt;k^n = 3^7&lt;/script&gt;
by &lt;script type=&quot;math/tex&quot;&gt;3 \cdot (3^2)^3 = 3 \cdot (3^2 \cdot ((3^2)^2)^1)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;In this case, we need one more variable &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;
to track the single leading &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;.
That is, we can find &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt; by:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_0 = 3, n_0 = 7, r_0 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_0 \cdot k_0^{n_0}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1 = k_0^2 = 3^2, n_1 = \frac{n_0 - 1}{2} = 3, r_1 = r_0 \cdot k_0 = 3&lt;/script&gt;,
now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_1 \cdot k_1^{n_1}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2 = k_1^2 = 3^4, n_2 = \frac{n_1 - 1}{2} = 1, r_2 = r_1 \cdot k_1 = 3^3&lt;/script&gt;,
now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_2 \cdot k_2^{n_2}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;n_2 = 1&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;k^n = r_2 \cdot k_2^{n_2} = r_2 \cdot k_2 = 3^3 \cdot 3^4&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Wrapping up the above ideas, we could summarize the following code:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// The remaining part for the squaring.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; is the product of all the single leading &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;.
The loop finishes when &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt; in above code and return &lt;script type=&quot;math/tex&quot;&gt;r \cdot k&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We could see there is a duplicated &lt;code class=&quot;highlighter-rouge&quot;&gt;r * k&lt;/code&gt; in above.
If we keep looping when &lt;script type=&quot;math/tex&quot;&gt;n = 1&lt;/script&gt;, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;r = r * k&lt;/code&gt; is our final answer.
Moreover, when &lt;script type=&quot;math/tex&quot;&gt;n = 0&lt;/script&gt;, the initial &lt;code class=&quot;highlighter-rouge&quot;&gt;r = 1&lt;/code&gt; is also correct,
so the beginning &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; could be saved.
However, we will waste a little time to compute the useless &lt;code class=&quot;highlighter-rouge&quot;&gt;k = k * k&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// The `r` should be the remaining part for the squaring(in pow5).
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// However, we notice that the `r * k` is duplicated in pow5. We will get
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// the answer by `r * k` when n = 1. If we keep looping when n = 1,
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// `r` is our answer. Nevertheless, we will waste time to do `k *= k`
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// when n = 1.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;There is different angle to see the above algorithm.
Actually, we can define &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt; by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^n =
\begin{cases}
r \cdot (k^2)^\frac{n}{2}, r = 1 &amp; \text{if $n$ is even} \\
r \cdot (k^2)^\frac{n-1}{2}, r = k &amp; \text{if $n$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, we could also use &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; to find &lt;script type=&quot;math/tex&quot;&gt;k^n&lt;/script&gt;.
By the example above when &lt;script type=&quot;math/tex&quot;&gt;k = 3, n = 8&lt;/script&gt;:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_0 = 3, n_0 = 8, r_0 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_0 \cdot k_0^{n_0}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1 = k_0^2 = 3^2, n_1 = \frac{n_0}{2} = 4, r_1 = r_0 \cdot 1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_1 \cdot k_1^{n_1}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2 = (k_1)^2 = 3^4, n_2 = \frac{n_1}{2} = 2, r_2 = r_1 \cdot 1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_2 \cdot k_2^{n_2}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_3 = (k_2)^2 = 3^8, n_3 = \frac{n_2}{2} = 1, r_3 = r_2 \cdot 1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_3 \cdot k_3^{n_3}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_4 = (k_3)^2 = 3^16, n_4 = \frac{n_3 - 1}{2} = 0, r_4 = r_3 \cdot k_3 = 3^8&lt;/script&gt;,
now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_4 \cdot k_4^{n_4}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;n_4 = 0&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;k^n = r_4 = 3^8&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We could see a more general case when &lt;script type=&quot;math/tex&quot;&gt;k = 3, n = 10&lt;/script&gt;:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_0 = 3, n_0 = 10, r_0 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_0 \cdot k_0^{n_0}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_1 = k_0^2 = 3^2, n_1 = \frac{n_0}{2} = 5, r_1 = r_0 \cdot 1 = 1&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_1 \cdot k_1^{n_1}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_2 = (k_1)^2 = 3^4, n_2 = \frac{n_1 - 1}{2} = 2, r_2 = r_1 \cdot k_1 = 3^2&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_2 \cdot k_2^{n_2}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_3 = (k_2)^2 = 3^8, n_3 = \frac{n_2}{2} = 1, r_3 = r_2 \cdot 1 = 3^2&lt;/script&gt;, now &lt;script type=&quot;math/tex&quot;&gt;k^n =  r_3 \cdot k_3^{n_3}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k_4 = (k_3)^2 = 3^{16}, n_4 = \frac{n_3 - 1}{2} = 0, r_4 = r_3 \cdot k_3 = 3^{10}&lt;/script&gt;,
now &lt;script type=&quot;math/tex&quot;&gt;k^n = r_4 \cdot k_4^{n_4}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;n_4 = 0&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;k^n = r_4 = 3^{10}&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In summary, the whole process can be organized into following table:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;round &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;th&gt;4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;3^2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;3^4&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;3^8&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;3^{16}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;3^2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;3^2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;3^{10}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;By calculating &lt;script type=&quot;math/tex&quot;&gt;n_{i+1} = \lfloor \frac{n_i}{2} \rfloor&lt;/script&gt;,
&lt;script type=&quot;math/tex&quot;&gt;k_{i+1} = {k_i}^2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;r_{i+1} = r_i \cdot c_i&lt;/script&gt;,
where &lt;script type=&quot;math/tex&quot;&gt;c_i = k_i&lt;/script&gt; when &lt;script type=&quot;math/tex&quot;&gt;n_i&lt;/script&gt; is odd or &lt;script type=&quot;math/tex&quot;&gt;c_i = 1&lt;/script&gt; when &lt;script type=&quot;math/tex&quot;&gt;n_i&lt;/script&gt; is even,
we can get the answer by &lt;script type=&quot;math/tex&quot;&gt;k^n = r_j&lt;/script&gt; when &lt;script type=&quot;math/tex&quot;&gt;n_j = 0&lt;/script&gt; for some &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;As a result, the algorithm is:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// This could be saved!
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Like what we mentioned in recursive part,
If &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is an &lt;strong&gt;odd&lt;/strong&gt; integer,
then the result of &lt;code class=&quot;highlighter-rouge&quot;&gt;n = (n - 1) / 2&lt;/code&gt; is same as &lt;code class=&quot;highlighter-rouge&quot;&gt;n = n / 2&lt;/code&gt;.
nd we can also replace &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b / 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b &amp;gt;&amp;gt; 1&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b % 2&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b &amp;amp; 0x01&lt;/code&gt;.
Finally, the algorithm can be shorten as:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n % 2
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n = n / 2;
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;bottom-up-approach&quot;&gt;Bottom-up Approach&lt;/h2&gt;

&lt;p&gt;The top-down approach is to calculate the value
from &lt;script type=&quot;math/tex&quot;&gt;x = n&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;x = 0&lt;/script&gt; repeatedly,
where &lt;script type=&quot;math/tex&quot;&gt;x \leftarrow \lfloor \frac{x}{2} \rfloor&lt;/script&gt;,
and the &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;’s value is updated when &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is odd.&lt;/p&gt;

&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; is changed like:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\require{AMScd}
\begin{CD}
10
@&gt;{n = \frac{n}{2}}&gt;&gt;
5
@&gt;{n = \frac{n-1}{2}}&gt;&gt;
2
@&gt;{n = \frac{n}{2}}&gt;&gt;
1
@&gt;{n = \frac{n-1}{2}}&gt;&gt;
0
\end{CD}&lt;/script&gt;

&lt;p&gt;To convert it into bottom-up approach,
we need to run in the &lt;strong&gt;opposite&lt;/strong&gt; direction:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\require{AMScd}
\begin{CD}
0
@&gt;{n = 2n + 1}&gt;&gt;
1
@&gt;{n = 2n}&gt;&gt;
2
@&gt;{n = 2n + 1}&gt;&gt;
5
@&gt;{n = 2n}&gt;&gt;
10
\end{CD}&lt;/script&gt;

&lt;p&gt;Suppose we have &lt;script type=&quot;math/tex&quot;&gt;k^{n_j}&lt;/script&gt;,
where &lt;script type=&quot;math/tex&quot;&gt;n_j = \lfloor \frac{n_{j+1}}{2} \rfloor&lt;/script&gt;,
then we can calculate &lt;script type=&quot;math/tex&quot;&gt;k^{n_{j+1}}&lt;/script&gt; by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^{n_{j+1}} =
\begin{cases}
k^{2 n_j} = (k^{n_j})^2,  &amp; \text{if $n_{j+1}$ is even} \\
k^{2 n_j + 1} = k \cdot (k^{n_j})^2, &amp; \text{if $n_{j+1}$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;since&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
n_{j+1} =
\begin{cases}
2 n_j,  &amp; \text{if $n_{j+1}$ is even} \\
2 n_j + 1, &amp; \text{if $n_{j+1}$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, if we have the track the changing of &lt;script type=&quot;math/tex&quot;&gt;n_j&lt;/script&gt;,
then we can use a single variable &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; to calculate &lt;script type=&quot;math/tex&quot;&gt;k^{n_j} = a_j&lt;/script&gt; by&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k^{n_{j+1}} = a_{j+1} =
\begin{cases}
(k^{n_j})^2 = {a_j}^2,  &amp; \text{if $n_{j+1}$ is even} \\
k \cdot (k^{n_j})^2 = k \cdot {a_j}^2, &amp; \text{if $n_{j+1}$ is odd}
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;, where &lt;script type=&quot;math/tex&quot;&gt;n_j = 0, a_0 = 1&lt;/script&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;round &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;th&gt;4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;10&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;odd&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;v&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;v&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;k\cdot{a_0}^2=k&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;{a_1}^2=k^2&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;k\cdot{a_2}^2 = k^5&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;{a_3}^2=k^{10}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The only question now is how we could get &lt;script type=&quot;math/tex&quot;&gt;n_j&lt;/script&gt;.
The changing of &lt;script type=&quot;math/tex&quot;&gt;n_j&lt;/script&gt; here is &lt;strong&gt;opposite&lt;/strong&gt; to the changing
of the recursive approach.
Thus, if we could push all the changing in recursive approach
into a &lt;em&gt;stack&lt;/em&gt;, then we can pop them to get the opposite changing.
That is,&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// To track the variation of n.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Get the n's changing in the recursive approach.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// We lost 0 here, so we need to set the initial state for n_j = 0
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Initializing variable for n_j = 0 ...
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Get the opposite track in the recursive approach.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Get the current n_j.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Calculate our answer here ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Obviously, we have &lt;script type=&quot;math/tex&quot;&gt;h = \lceil log_2 n \rceil&lt;/script&gt; items in the &lt;em&gt;stack&lt;/em&gt;,
so the loop will run &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt; rounds (the above &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; is from &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt;).&lt;/p&gt;

&lt;p&gt;In the case for &lt;script type=&quot;math/tex&quot;&gt;n = 10&lt;/script&gt;, the bottom-up approach will run as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\require{AMScd}
\begin{CD}
0
\end{CD}
\underbrace{
\begin{CD}
@&gt;{n = 2n + 1}&gt;&gt;
1
@&gt;{n = 2n}&gt;&gt;
2
@&gt;{n = 2n + 1}&gt;&gt;
5
@&gt;{n = 2n}&gt;&gt;
10
\end{CD}
}_{loop}&lt;/script&gt;

&lt;p&gt;To calculate our answer,
we need to add a variable &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;
to keep tracking the &lt;script type=&quot;math/tex&quot;&gt;k^{n_j} = a_j&lt;/script&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*n /= 2*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a = k^0 = 1
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Let y = floor(x/2), y = x/2 if x is even, y = (x-1)/2 if x is odd.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// then a = k^y now.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a = (k^y)^2 = k^(2y)
&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// x is even:
&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;//   a = k^x = k^(2y)
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*x % 2*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// x is odd:
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//   a = k^x = k^(2y+1) = k * k^(2y)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To get even or odd the &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; is, the &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; is checked iteratively,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;x = n &amp;gt;&amp;gt; j&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt; is the times we have looped,
by &lt;code class=&quot;highlighter-rouge&quot;&gt;x &amp;amp; 1&lt;/code&gt; in the &lt;code class=&quot;highlighter-rouge&quot;&gt;while (!s.empty())&lt;/code&gt;.
In other word, we are actually checking
from the &lt;strong&gt;lowest bit to highest bit&lt;/strong&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Thus, the code could be rewritten into:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pow9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// The position of the highest bit of n.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// So we need to loop `h` times to get the answer.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Example: n = (Dec)50 = (Bin)00110010, then h = 6.
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//                               ^ 6th bit from right side
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a = k^0 = 1
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// There is only one `1` in the bits of `mask`. The `1`'s position is same as
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// iteratively to do `AND` operation with `n` to check `n_j` is odd or even,
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// where n_j is defined below.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Run h times!
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &amp;gt;&amp;gt; j
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (n_j = n when j = 0), x = floor(n_j / 2), then a = k^x now.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a = (k^x)^2 = k^(2x)
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// n_j is even: x = n_j / 2 =&amp;gt; n_j = 2x
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//   a = k^(n_j) = k^(2x)
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n_j is odd: x = (n_j - 1) / 2 =&amp;gt; n_j = 2x + 1
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;//   a = k^(n_j) = k^(2x+1) = k * k^(2x)
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All the above code are on &lt;a href=&quot;https://gist.github.com/ChunMinChang/9753c72e2441343e14757f5a9ac95a98&quot; title=&quot;Exponentiation by squaring&quot;&gt;gist here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Algorithm&quot;]" /><category term="Recursion" /><category term="Dynamic Programming" /><summary type="html">What is the time complexity of the computation for ?
We might intuitively think it’s .
In fact, it can be done in 
by exponentiation by squaring.

The key idea is:



or



By dividing  to  again and again,
then stop when ,
we could solve  in .

Top-down Approach

Recursive
If we apply the first conversion, we could get the following code:

uint64_t pow1(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  if (n % 2) {
    return k * pow1(k, (n - 1) / 2) * pow1(k, (n - 1) / 2);
  } else {
    return pow1(k, n / 2) * pow1(k, n / 2);
  }
}



The above program uses two same recursions, ... * pow1(...) * pow1(...),
as the returned value, so it will duplicate two same stacks.
On the other hand, if we apply the second conversion,
then there is no duplicated stack needed.
It could save almost half computation time of the pow1
since it only uses half recursions than pow1.

uint64_t pow2(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  if (n % 2) {
    return k * pow2(k * k, (n - 1) / 2);
  } else {
    return pow2(k * k, n / 2);
  }
}



The above code still could be simplified.
The result of the division  is
actually  in the world of C and C++,
if  is an integer.

That is, if n is an odd integer,
then the result of n = (n - 1) / 2 is same as n = n / 2.

Thus, the code could be simplified as follows:

uint64_t pow3(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  uint64_t x = pow3(k * k, n / 2);
  // so x = (k^2)^(n/2),      if n is even
  //     or (k^2)^((n-1)/2),  if n is odd

  if (n % 2) {
    x = x * k; // so x = k * (k^2)^((n-1)/2)
  }
  return x;
}



Another trick is that We could replace a = b / 2 by a = b &amp;gt;&amp;gt; 1
and a = b % 2 by a = b &amp;amp; 0x01.
(But I guess your compiler might already do that for you.)

uint64_t pow4(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  uint64_t x = pow4(k * k, n &amp;gt;&amp;gt; 1);
  return (n &amp;amp; 1) ? x * k : x;
}



Iterative
If we could rewrite a recursive algorithm into an iterative version,
it usually run faster.

If  is always even, then it’s easy to calculate in a loop.
For example, when , we can calculate 
by .

Thus, we can find  by:

  , now 
  , now 
  , now 
  , now 
  , so 


On the other hand, if  is not always even,
then we need to deal with the single leading 
in the ,
which will not used to square.
For example, when , we can calculate 
by .

In this case, we need one more variable 
to track the single leading .
That is, we can find  by:

  , now 
  ,
now 
  ,
now 
  , so 


Wrapping up the above ideas, we could summarize the following code:
uint64_t pow5(unsigned int k, unsigned int n)
{
  if (!n) {
    return 1;
  }

  uint64_t r = 1; // The remaining part for the squaring.
  while (n &amp;gt; 1) {
    if (n % 2) {
      r *= k;
      k *= k;
      n = (n - 1) / 2;
    } else {
      k *= k;
      n = n / 2;
    }
  }

  return r * k;
}



The  is the product of all the single leading .
The loop finishes when  in above code and return .

We could see there is a duplicated r * k in above.
If we keep looping when , then the r = r * k is our final answer.
Moreover, when , the initial r = 1 is also correct,
so the beginning if could be saved.
However, we will waste a little time to compute the useless k = k * k.

uint64_t pow6(unsigned int k, unsigned int n)
{
  // The `r` should be the remaining part for the squaring(in pow5).
  // However, we notice that the `r * k` is duplicated in pow5. We will get
  // the answer by `r * k` when n = 1. If we keep looping when n = 1,
  // `r` is our answer. Nevertheless, we will waste time to do `k *= k`
  // when n = 1.
  uint64_t r = 1;

  while (n) {
    if (n % 2) {
      r *= k;
      k *= k;
      n = (n - 1) / 2;
    } else {
      k *= k;
      n = n / 2;
    }
  }

  return r;
}



There is different angle to see the above algorithm.
Actually, we can define  by:



Thus, we could also use  to find .
By the example above when :

  , now 
  , now 
  , now 
  , now 
  ,
now 
  , so 


We could see a more general case when :

  , now 
  , now 
  , now 
  , now 
  ,
now 
  , so 


In summary, the whole process can be organized into following table:


  
    
      round 
      0
      1
      2
      3
      4
    
  
  
    
      
      
      
      
      
      
    
    
      
      
      
      
      
      
    
    
      
      
      
      
      
      
    
  


By calculating ,
 and ,
where  when  is odd or  when  is even,
we can get the answer by  when  for some .

As a result, the algorithm is:

uint64_t pow6(unsigned int k, unsigned int n)
{
  uint64_t r = 1;

  while (n) {
    if (n % 2) {
      r *= k;
      k *= k;
      n = (n - 1) / 2;
    } else {
      r *= 1; // This could be saved!
      k *= k;
      n = n / 2;
    }
  }

  return r;
}



Like what we mentioned in recursive part,
If n is an odd integer,
then the result of n = (n - 1) / 2 is same as n = n / 2.
nd we can also replace a = b / 2 by a = b &amp;gt;&amp;gt; 1
and a = b % 2 by a = b &amp;amp; 0x01.
Finally, the algorithm can be shorten as:

uint64_t pow7(unsigned int k, unsigned int n)
{
  uint64_t r = 1;
  while (n) {
    if (n &amp;amp; 1) { // n % 2
      r *= k;
    }
    k *= k;
    n &amp;gt;&amp;gt;= 1; // n = n / 2;
  }

  return r;
}



Bottom-up Approach

The top-down approach is to calculate the value
from  to  repeatedly,
where ,
and the ’s value is updated when  is odd.

The  is changed like:



To convert it into bottom-up approach,
we need to run in the opposite direction:



Suppose we have ,
where ,
then we can calculate  by:



since



Thus, if we have the track the changing of ,
then we can use a single variable  to calculate  by



, where .


  
    
      round 
      0
      1
      2
      3
      4
    
  
  
    
      
      
      
      
      
      
    
    
      odd
       
      v
       
      v
       
    
    
      
      
      
      
      
      
    
  


The only question now is how we could get .
The changing of  here is opposite to the changing
of the recursive approach.
Thus, if we could push all the changing in recursive approach
into a stack, then we can pop them to get the opposite changing.
That is,

// To track the variation of n.
std::stack&amp;lt;unsigned int&amp;gt; s;

// Get the n's changing in the recursive approach.
while(n) {
  s.push(n);
  n = n / 2;
}
// We lost 0 here, so we need to set the initial state for n_j = 0

// Initializing variable for n_j = 0 ...

// Get the opposite track in the recursive approach.
while (!s.empty()) {
  unsigned int x = s.top(); s.pop(); // Get the current n_j.
  // Calculate our answer here ...
}



Obviously, we have  items in the stack,
so the loop will run  rounds (the above  is from  to ).

In the case for , the bottom-up approach will run as follows:



To calculate our answer,
we need to add a variable 
to keep tracking the :

uint64_t pow8(unsigned int k, unsigned int n)
{
  std::stack&amp;lt;unsigned int&amp;gt; s;
  while(n) {
    s.push(n);
    n &amp;gt;&amp;gt;= 1/*n /= 2*/;
  }

  uint64_t a = 1; // a = k^0 = 1
  while (!s.empty()) {
    unsigned int x = s.top(); s.pop();
    // Let y = floor(x/2), y = x/2 if x is even, y = (x-1)/2 if x is odd.
    // then a = k^y now.
    a *= a; // a = (k^y)^2 = k^(2y)
                  // x is even:
                  //   a = k^x = k^(2y)
    if (x &amp;amp; 1 /*x % 2*/) {  // x is odd:
      a *= k;     //   a = k^x = k^(2y+1) = k * k^(2y)
    }
  }

  return a;
}



To get even or odd the x is, the x is checked iteratively,
where x = n &amp;gt;&amp;gt; j and j is the times we have looped,
by x &amp;amp; 1 in the while (!s.empty()).
In other word, we are actually checking
from the lowest bit to highest bit of x.

Thus, the code could be rewritten into:

uint64_t pow9(unsigned int k, unsigned int n)
{
  // The position of the highest bit of n.
  // So we need to loop `h` times to get the answer.
  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.
  //                               ^ 6th bit from right side
  unsigned int h = 0;
  for (unsigned int i = n ; i ; ++h, i &amp;gt;&amp;gt;= 1);

  uint64_t a = 1; // a = k^0 = 1
  // There is only one `1` in the bits of `mask`. The `1`'s position is same as
  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right
  // iteratively to do `AND` operation with `n` to check `n_j` is odd or even,
  // where n_j is defined below.
  for (unsigned int mask = 1 &amp;lt;&amp;lt; (h - 1) ; mask ; mask &amp;gt;&amp;gt;= 1) { // Run h times!
    // Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &amp;gt;&amp;gt; j
    // (n_j = n when j = 0), x = floor(n_j / 2), then a = k^x now.
    a *= a; // a = (k^x)^2 = k^(2x)
    // n_j is even: x = n_j / 2 =&amp;gt; n_j = 2x
    //   a = k^(n_j) = k^(2x)
    if (n &amp;amp; mask) { // n_j is odd: x = (n_j - 1) / 2 =&amp;gt; n_j = 2x + 1
      a *= k;       //   a = k^(n_j) = k^(2x+1) = k * k^(2x)
    }
  }

  return a;
}



All the above code are on gist here.</summary></entry><entry><title type="html">Closed Form for the Fibonacci Sequence</title><link href="http://localhost:4000/post/closed-form-for-the-fibonacci-sequence" rel="alternate" type="text/html" title="Closed Form for the Fibonacci Sequence" /><published>2017-08-13T00:00:00+08:00</published><updated>2017-08-13T00:00:00+08:00</updated><id>http://localhost:4000/post/closed-form-for-the-fibonacci-sequence</id><content type="html" xml:base="http://localhost:4000/post/closed-form-for-the-fibonacci-sequence">&lt;p&gt;The &lt;em&gt;Fibonacci&lt;/em&gt; number can be defined as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_n = F_{n-1} + F_{n-2}&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;F_0 = 0, F_1 = 1&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Assume &lt;script type=&quot;math/tex&quot;&gt;F_n = s \cdot r^n&lt;/script&gt;,
then &lt;script type=&quot;math/tex&quot;&gt;F_n = F_{n-1} + F_{n-2}&lt;/script&gt; can be rewritten into:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;s \cdot r^n = s \cdot r^{n-1} + s \cdot r^{n-2}&lt;/script&gt;

&lt;p&gt;Thus,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;s \cdot r^{n-2} \cdot (r^2 - r - 1) = 0&lt;/script&gt;

&lt;p&gt;and &lt;script type=&quot;math/tex&quot;&gt;r = \frac{1\pm \sqrt{5}}{2}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;p = \frac{1 + \sqrt{5}}{2}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;r = \frac{1 - \sqrt{5}}{2}&lt;/script&gt;,
and &lt;script type=&quot;math/tex&quot;&gt;x_k = u \cdot p^k + v \cdot q^k&lt;/script&gt;,
we now show that &lt;script type=&quot;math/tex&quot;&gt;x_k&lt;/script&gt; is also a solution for &lt;script type=&quot;math/tex&quot;&gt;F_k&lt;/script&gt;.
That is, we need to show &lt;script type=&quot;math/tex&quot;&gt;x_k = x_{k-1} + x_{k-2}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_{k-1} + x_{k-2}
&amp;= u \cdot p^{k-1} + v \cdot q^{k-1} + u \cdot p^{k-2} + v \cdot q^{k-2} \\
&amp;= u \cdot p^{k-2} \cdot (1 + p) + v \cdot q^{k-2} \cdot (1 + q) \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Since &lt;script type=&quot;math/tex&quot;&gt;r + 1 = r^2(\text{by } r^2 - r - 1 = 0)&lt;/script&gt;,
we know &lt;script type=&quot;math/tex&quot;&gt;p + 1 = p^2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q + 1 = q^2&lt;/script&gt;
Thus,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_{k-1} + x_{k-2}
&amp;= u \cdot p^{k-2} \cdot (1 + p) + v \cdot q^{k-2} \cdot (1 + q) \\
&amp;= u \cdot p^{k-2} \cdot p^2 + v \cdot q^{k-2} \cdot q^2 \\
&amp;= u \cdot p^k + v \cdot q^k \\
&amp;= x_k
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Next, if we take &lt;script type=&quot;math/tex&quot;&gt;x_k&lt;/script&gt; as our closed form for the &lt;em&gt;Fibonacci&lt;/em&gt; number,
we also need to know what &lt;script type=&quot;math/tex&quot;&gt;u, v&lt;/script&gt; are.
Fortunately, by the definition, we already know &lt;script type=&quot;math/tex&quot;&gt;F_0 = 0, F_1 = 1&lt;/script&gt;,
so&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_0 &amp;= 0 = u \cdot p^0+ v \cdot q^0 = u + v \\
x_1 &amp;= 1 = u \cdot p + v \cdot q
= u \cdot \frac{1 + \sqrt{5}}{2} + v \cdot \frac{1 - \sqrt{5}}{2} \\
\Rightarrow 2 &amp;= u + u \cdot \sqrt{5} + v - v \cdot \sqrt{5} \\
&amp;= (u + v) + \sqrt{5} \cdot (u - v) \\
&amp;= \sqrt{5} \cdot (u - v)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;By &lt;script type=&quot;math/tex&quot;&gt;u + v = 0&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;u - v = \frac{2}{\sqrt{5}}&lt;/script&gt;, we know that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
u &amp;= \frac{1}{\sqrt{5}} \\
v &amp;= \frac{-1}{\sqrt{5}}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;As a result,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x_k &amp;= u \cdot p^k + v \cdot q^k \\
&amp;= \frac{1}{\sqrt{5}} \cdot (\frac{1 + \sqrt{5}}{2})^k - \frac{1}{\sqrt{5}} \cdot (\frac{1 - \sqrt{5}}{2})^k \\
&amp;= \frac{1}{\sqrt{5}} \cdot [ (\frac{1 + \sqrt{5}}{2})^k -  (\frac{1 - \sqrt{5}}{2})^k ]
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;graph&quot;&gt;Graph&lt;/h2&gt;
&lt;p&gt;See the online &lt;a href=&quot;https://www.wolframalpha.com/input/?i=(((1%2Bsqrt(5))%2F2)%5Ex+-+((1-sqrt(5))%2F2)%5Ex)%2Fsqrt(5)&quot;&gt;graph here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;questions&quot;&gt;Questions&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Why we assume &lt;script type=&quot;math/tex&quot;&gt;F_n = s \cdot r^n&lt;/script&gt;?&lt;/li&gt;
  &lt;li&gt;Why we use &lt;script type=&quot;math/tex&quot;&gt;F_n = u \cdot p^n + v \cdot q^n&lt;/script&gt;
instead of &lt;script type=&quot;math/tex&quot;&gt;F_n = s \cdot r^n&lt;/script&gt; as our closed form?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;http://math.ucr.edu/~res/math153/history07a.pdf&lt;/li&gt;
  &lt;li&gt;http://gozips.uakron.edu/~crm23/fibonacci/fibonacci.htm&lt;/li&gt;
  &lt;li&gt;https://math.stackexchange.com/questions/65011/prove-this-formula-for-the-fibonacci-sequence&lt;/li&gt;
  &lt;li&gt;http://mathproofs.blogspot.tw/2005/04/nth-term-of-fibonacci-sequence.html&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Math" /><category term="Fibonacci" /><summary type="html">The Fibonacci number can be defined as:



where .

Assume ,
then  can be rewritten into:



Thus,



and 

Let , ,
and ,
we now show that  is also a solution for .
That is, we need to show .

Proof:



Since ,
we know  and 
Thus,



Next, if we take  as our closed form for the Fibonacci number,
we also need to know what  are.
Fortunately, by the definition, we already know ,
so



By  and , we know that



As a result,



Graph
See the online graph here

Questions

  Why we assume ?
  Why we use 
instead of  as our closed form?


References

  http://math.ucr.edu/~res/math153/history07a.pdf
  http://gozips.uakron.edu/~crm23/fibonacci/fibonacci.htm
  https://math.stackexchange.com/questions/65011/prove-this-formula-for-the-fibonacci-sequence
  http://mathproofs.blogspot.tw/2005/04/nth-term-of-fibonacci-sequence.html</summary></entry><entry><title type="html">The Misuse of RefPtr</title><link href="http://localhost:4000/post/the-misuse-of-refptr" rel="alternate" type="text/html" title="The Misuse of RefPtr" /><published>2017-08-08T00:00:00+08:00</published><updated>2017-08-08T00:00:00+08:00</updated><id>http://localhost:4000/post/the-misuse-of-refptr</id><content type="html" xml:base="http://localhost:4000/post/the-misuse-of-refptr">&lt;p&gt;In &lt;!--[last post](/post/refptr-v-s-shared-ptr)--&gt;
&lt;a href=&quot;https://chunminchang.github.io/blog/post/refptr-v-s-shared-ptr&quot;&gt;previous post&lt;/a&gt;,
I introduced the &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt; that can keep tracking the references to the
object &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; and the references are counted by object &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;Today, I will note my misuse of it several weeks ago.
This is also why I want to write the posts about &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-behavior-i-want&quot;&gt;What behavior I want&lt;/h2&gt;
&lt;p&gt;The following behavior is what I want when I was implementing one patch
for Firefox:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A list containing all of the solders.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Put the `s` into the list.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// The `s` is destroyed, so it should be removed from the list now.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and we will put the &lt;code class=&quot;highlighter-rouge&quot;&gt;Solder&lt;/code&gt; instance into the &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt; when
it’s created and remove it when it’s destroyed.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Remove&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;why-it-doesnt-work&quot;&gt;Why it doesn’t work&lt;/h2&gt;
&lt;p&gt;This is a wrong pattern to meet our expectation.
The solders in the list will &lt;strong&gt;only&lt;/strong&gt; be destroyed and removed from the list
when the whole program is ended.
The solders are only removed from the list in its deconstructor.
However, whenever the &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Solder&amp;gt; s(new Solder())&lt;/code&gt;
is deconstructed (by &lt;code class=&quot;highlighter-rouge&quot;&gt;~RefPtr&lt;/code&gt;) in the main function,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;~Solder()&lt;/code&gt; won’t be called
since there must be one another &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Solder&amp;gt; some&lt;/code&gt; in the list
referencing the solder.
Thus, the &lt;code class=&quot;highlighter-rouge&quot;&gt;~Solder()&lt;/code&gt; is only be called
when the element in the list is decontructed.&lt;/p&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample code&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;// $ g++ test.cpp --std=c++11
#include &amp;quot;RefPtr.h&amp;quot;
#include &amp;lt;algorithm&amp;gt;  // std::remove
#include &amp;lt;cassert&amp;gt;    // assert
#include &amp;lt;iostream&amp;gt;   // std::cout, std::endl
#include &amp;lt;vector&amp;gt;     // std::vector

///////////////////////////////////////////////////////////////////////////////
// Solder Interface
class Solder: public ReferenceCount
{
public:
  Solder(int n);
  ~Solder();
  int CountOff(); // Report the number.

private:
  int number;
};

///////////////////////////////////////////////////////////////////////////////
// Squad Interface
class Squad
{
public:
  static void Add(Solder* s);
  static void Remove(Solder* s);
  static void CountOff(); // Call all of the solders.
  static unsigned int Size();
private:
  static std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; members;
};

///////////////////////////////////////////////////////////////////////////////
// Solder Implementation
Solder::Solder(int n)
  : number(n)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is created.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Add(this);
}

Solder::~Solder()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Remove(this);
}

int
Solder::CountOff()
{
  return number;
}

///////////////////////////////////////////////////////////////////////////////
// Squad Implementation
std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; Squad::members;

/* static */ void
Squad::Add(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Add Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; to members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.push_back(s);
}

/* static */ void
Squad::Remove(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Remove Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; from members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.erase(std::remove(members.begin(), members.end(), s), members.end());
}

/* static */ void
Squad::CountOff()
{
  for (auto&amp;amp; m: members) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; m-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; is here!&amp;quot; &amp;lt;&amp;lt; std::endl;
  }
}

/* static */ unsigned int
Squad::Size()
{
  return members.size();
}

///////////////////////////////////////////////////////////////////////////////
// *** Wrong example to use RefPtr ***
//   We will put the Solder instances into the squad when they are created,
//   and remove the instances from the squad when they are destroyed.
//   We expect the following behavior.
//
//   List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l;
//   {
//     RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put s into the list
//   }
//   // s is destroyed and removed from the list, so list is empty now.
int main()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Creating a solder and put it into squad.&amp;quot; &amp;lt;&amp;lt; std::endl;

  {
    RefPtr&amp;lt;Solder&amp;gt; s(new Solder(1));
    Squad::CountOff();
    // There should be one solder in the squad now.
    assert(Squad::Size() == 1 &amp;amp;&amp;amp; s-&amp;gt;GetCount() == 2);
  }

  std::cout &amp;lt;&amp;lt; &amp;quot;Solder should be removed from squad and destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  // In our mind, we expect there is no solder in the squad now.
  assert(Squad::Size() == 0); // Comment this to check the below one.
  // But it&amp;#39;s wrong. The correct status of the memebers is:
  // assert(Squad::Size() == 1);

  // In our expectation, we expect the solder 1 will be destroyed and removed
  // from the sqaud when the program is running out of &amp;#39;}&amp;#39; above.
  // At that time, the ~RefPtr() will be called and check whether we need to
  // release the solder 1. However, since we still have a reference to solder 1
  // in the members list of the squal, the reference count to solder 1 is not 0.
  // Therefore, it won&amp;#39;t be removed!

  // Actually,
  // ------------------------------------
  // List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; list
  // Solder()
  // {
  //   Add &amp;#39;this&amp;#39; into the list
  // }
  // ~Solder()
  // {
  //   Remove &amp;#39;this&amp;#39; from the list
  // }
  // ------------------------------------
  // is a wrong pattern to meet our expectation.
  // The solders in the list will only be destroyed and removed from the list
  // when the whole program is ended. The solders are only removed from
  // the list in its deconstructor. However, whenever the
  // RefPtr&amp;lt;Solder&amp;gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,
  // the ~Solder() won&amp;#39;t be called since there must be one another
  // RefPtr&amp;lt;Solder&amp;gt; in the list referencing the solder.
  // Thus, the ~Solder() is only be called when the element in the list is
  // decontructed.

  return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1.js?file=misuse.cpp&quot;&gt; &lt;/script&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Common&quot;]" /><category term="C/C++" /><category term="Smart Pointer" /><category term="Firefox" /><summary type="html">In 
previous post,
I introduced the RefPtr&amp;lt;T&amp;gt; that can keep tracking the references to the
object T and the references are counted by object T itself.

Today, I will note my misuse of it several weeks ago.
This is also why I want to write the posts about RefPtr&amp;lt;T&amp;gt;.

What behavior I want
The following behavior is what I want when I was implementing one patch
for Firefox:

List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l; // A list containing all of the solders.
{
  RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put the `s` into the list.
}
// The `s` is destroyed, so it should be removed from the list now.



and we will put the Solder instance into the l when
it’s created and remove it when it’s destroyed.

Solder()
{
  Add this into `l`
}
~Solder()
{
  Remove this from `l`
}



Why it doesn’t work
This is a wrong pattern to meet our expectation.
The solders in the list will only be destroyed and removed from the list
when the whole program is ended.
The solders are only removed from the list in its deconstructor.
However, whenever the RefPtr&amp;lt;Solder&amp;gt; s(new Solder())
is deconstructed (by ~RefPtr) in the main function,
the ~Solder() won’t be called
since there must be one another RefPtr&amp;lt;Solder&amp;gt; some in the list
referencing the solder.
Thus, the ~Solder() is only be called
when the element in the list is decontructed.

Sample code
// $ g++ test.cpp --std=c++11
#include &amp;quot;RefPtr.h&amp;quot;
#include &amp;lt;algorithm&amp;gt;  // std::remove
#include &amp;lt;cassert&amp;gt;    // assert
#include &amp;lt;iostream&amp;gt;   // std::cout, std::endl
#include &amp;lt;vector&amp;gt;     // std::vector

///////////////////////////////////////////////////////////////////////////////
// Solder Interface
class Solder: public ReferenceCount
{
public:
  Solder(int n);
  ~Solder();
  int CountOff(); // Report the number.

private:
  int number;
};

///////////////////////////////////////////////////////////////////////////////
// Squad Interface
class Squad
{
public:
  static void Add(Solder* s);
  static void Remove(Solder* s);
  static void CountOff(); // Call all of the solders.
  static unsigned int Size();
private:
  static std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; members;
};

///////////////////////////////////////////////////////////////////////////////
// Solder Implementation
Solder::Solder(int n)
  : number(n)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is created.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Add(this);
}

Solder::~Solder()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; is destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  Squad::Remove(this);
}

int
Solder::CountOff()
{
  return number;
}

///////////////////////////////////////////////////////////////////////////////
// Squad Implementation
std::vector&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; Squad::members;

/* static */ void
Squad::Add(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Add Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; to members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.push_back(s);
}

/* static */ void
Squad::Remove(Solder* s)
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Remove Solder &amp;quot; &amp;lt;&amp;lt; s-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; from members.&amp;quot; &amp;lt;&amp;lt; std::endl;
  members.erase(std::remove(members.begin(), members.end(), s), members.end());
}

/* static */ void
Squad::CountOff()
{
  for (auto&amp;amp; m: members) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Solder &amp;quot; &amp;lt;&amp;lt; m-&amp;gt;CountOff() &amp;lt;&amp;lt; &amp;quot; is here!&amp;quot; &amp;lt;&amp;lt; std::endl;
  }
}

/* static */ unsigned int
Squad::Size()
{
  return members.size();
}

///////////////////////////////////////////////////////////////////////////////
// *** Wrong example to use RefPtr ***
//   We will put the Solder instances into the squad when they are created,
//   and remove the instances from the squad when they are destroyed.
//   We expect the following behavior.
//
//   List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; l;
//   {
//     RefPtr&amp;lt;Solder&amp;gt; s(new Solder(99)); // Put s into the list
//   }
//   // s is destroyed and removed from the list, so list is empty now.
int main()
{
  std::cout &amp;lt;&amp;lt; &amp;quot;Creating a solder and put it into squad.&amp;quot; &amp;lt;&amp;lt; std::endl;

  {
    RefPtr&amp;lt;Solder&amp;gt; s(new Solder(1));
    Squad::CountOff();
    // There should be one solder in the squad now.
    assert(Squad::Size() == 1 &amp;amp;&amp;amp; s-&amp;gt;GetCount() == 2);
  }

  std::cout &amp;lt;&amp;lt; &amp;quot;Solder should be removed from squad and destroyed.&amp;quot; &amp;lt;&amp;lt; std::endl;
  // In our mind, we expect there is no solder in the squad now.
  assert(Squad::Size() == 0); // Comment this to check the below one.
  // But it&amp;#39;s wrong. The correct status of the memebers is:
  // assert(Squad::Size() == 1);

  // In our expectation, we expect the solder 1 will be destroyed and removed
  // from the sqaud when the program is running out of &amp;#39;}&amp;#39; above.
  // At that time, the ~RefPtr() will be called and check whether we need to
  // release the solder 1. However, since we still have a reference to solder 1
  // in the members list of the squal, the reference count to solder 1 is not 0.
  // Therefore, it won&amp;#39;t be removed!

  // Actually,
  // ------------------------------------
  // List&amp;lt;RefPtr&amp;lt;Solder&amp;gt;&amp;gt; list
  // Solder()
  // {
  //   Add &amp;#39;this&amp;#39; into the list
  // }
  // ~Solder()
  // {
  //   Remove &amp;#39;this&amp;#39; from the list
  // }
  // ------------------------------------
  // is a wrong pattern to meet our expectation.
  // The solders in the list will only be destroyed and removed from the list
  // when the whole program is ended. The solders are only removed from
  // the list in its deconstructor. However, whenever the
  // RefPtr&amp;lt;Solder&amp;gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,
  // the ~Solder() won&amp;#39;t be called since there must be one another
  // RefPtr&amp;lt;Solder&amp;gt; in the list referencing the solder.
  // Thus, the ~Solder() is only be called when the element in the list is
  // decontructed.

  return 0;
}</summary></entry><entry><title type="html">RefPtr v.s. shared_ptr</title><link href="http://localhost:4000/post/refptr-v-s-shared-ptr" rel="alternate" type="text/html" title="RefPtr v.s. shared_ptr" /><published>2017-07-31T00:00:00+08:00</published><updated>2017-07-31T00:00:00+08:00</updated><id>http://localhost:4000/post/refptr-v-s-shared-ptr</id><content type="html" xml:base="http://localhost:4000/post/refptr-v-s-shared-ptr">&lt;p&gt;When I tried to replace Mozilla’s &lt;a href=&quot;http://searchfox.org/mozilla-central/source/mfbt/RefPtr.h&quot; title=&quot;RefPtr&quot;&gt;RefPtr&lt;/a&gt; with standard C++
smart-pointer to note one of my misusage of it,
I used &lt;em&gt;std::shard_ptr&lt;/em&gt; to do it.
However, it didn’t work since there is a huge difference between
Mozilla’s &lt;a href=&quot;http://searchfox.org/mozilla-central/source/mfbt/RefPtr.h&quot; title=&quot;RefPtr&quot;&gt;RefPtr&lt;/a&gt; and the &lt;em&gt;std::shard_ptr&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I’ve never noticed that because I never use smart-pointer
before I worked for Mozilla.
So it’s a perfect chance for me to get closer to look at their difference.&lt;/p&gt;

&lt;h2 id=&quot;reference-count&quot;&gt;Reference count&lt;/h2&gt;
&lt;p&gt;Although they’re both using reference-count to track object
and manage objects’ life-time by the count,
they are counting on different things.&lt;/p&gt;

&lt;p&gt;Suppose we have reference-counted pointers &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;T&amp;gt;&lt;/code&gt;,
we will call it like &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;Foo&amp;gt; p(new Foo(...))&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;refptr&quot;&gt;&lt;em&gt;RefPtr&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;When using &lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt;&lt;/code&gt;,
the total reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo&lt;/code&gt; objects.
That’s see an example below.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Foo must provide reference-counted interface.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// The total references will be counted on Foo object f.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of f is 1 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of f is 2 now.  
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the reference count of f is back to 1 now since p2 is destroyed.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;stdshard_ptr&quot;&gt;&lt;em&gt;std::shard_ptr&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;When using &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;T&amp;gt;&lt;/code&gt;,
the total reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&lt;/code&gt; itself.
That’s see an example below.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Bar does NOT need to provide reference-counted interface.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p1 is 1 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p1 and p2 is 2 now.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the reference count of p1 is back to 1 now since p2 is destroyed.
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the reference count of p3 is 1 now.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Even worse, the above program will cause an error:
&lt;strong&gt;pointer being freed was not allocated&lt;/strong&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;p1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;p3&lt;/code&gt; both control the life-time of &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.
When &lt;code class=&quot;highlighter-rouge&quot;&gt;p1&lt;/code&gt; is destroyed, its reference-count is down to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;,
so it will deallocate &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.
Nevertheless, When &lt;code class=&quot;highlighter-rouge&quot;&gt;p3&lt;/code&gt; is destroyed,
its reference-count is also down to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;,
so it will deallocate &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; &lt;strong&gt;again&lt;/strong&gt; and cause an error:
&lt;strong&gt;Freeing an already-freed object&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Thus, using&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;to replace the following pattern should save your life.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// This is a bad pattern!
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shard_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample code&lt;/h2&gt;
&lt;p&gt;That’s see the example-implementation of these two smart-pointers.
Again, the key difference between &lt;em&gt;RefPtr&lt;/em&gt; and &lt;em&gt;std::shard_ptr&lt;/em&gt; is&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RefPtr&amp;lt;T&amp;gt; p(new T(...))&lt;/code&gt;:
the reference is counted on the newed &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; object
so the &lt;code class=&quot;highlighter-rouge&quot;&gt;class T&lt;/code&gt; must provide &lt;em&gt;reference-counted&lt;/em&gt; interface.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))&lt;/code&gt;:
the reference is counted on the &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt; itself.&lt;/li&gt;
&lt;/ul&gt;

&lt;noscript&gt;&lt;pre&gt;#ifndef REFPTR_H
#define REFPTR_H

#include &amp;lt;cassert&amp;gt;

#define DEBUG
#ifdef DEBUG
#ifdef NDEBUG
#undef NDEBUG
#endif // NDEBUG
#include &amp;lt;iostream&amp;gt;
#endif // DEBUG

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Interface
class ReferenceCount
{
public:
  void AddRef();
  void Release();
  unsigned int GetCount();
  bool IsShared();

protected:
  ReferenceCount();
  // Disallow copy constructor
  ReferenceCount(const ReferenceCount&amp;amp; rhs) = delete;
  // ReferenceCount&amp;amp; operator=(const ReferenceCount&amp;amp; rhs);
  virtual ~ReferenceCount();

private:
  unsigned int count;
};

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Implementation
ReferenceCount::ReferenceCount()
  : count(0)
{
}

// ReferenceCount::ReferenceCount(const ReferenceCount&amp;amp; rhs)
//   : count(0)
// {
// }

ReferenceCount::~ReferenceCount()
{
}

// ReferenceCount&amp;amp;
// ReferenceCount::&amp;amp; operator=(const ReferenceCount&amp;amp; rhs)
// {
//   return this;
// }

void
ReferenceCount::AddRef()
{
  ++count;
}

void
ReferenceCount::Release()
{
  if (!--count) {
#ifdef DEBUG
    fprintf(stderr, &amp;quot;Release %s @ %p\n&amp;quot;, typeid(*this).name() + 1,this);
#endif
    delete this;
  }
}

unsigned int
ReferenceCount::GetCount()
{
  return count;
}

bool
ReferenceCount::IsShared()
{
  return count &amp;gt; 1;
}

///////////////////////////////////////////////////////////////////////////////
// RefPtr Interface
//   pointee must support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class RefPtr
{
public:
  // Default constructor
  RefPtr(T* realPtr = nullptr);

  // Copy constructor
  RefPtr(const RefPtr&amp;amp; rhs);

  ~RefPtr();

  RefPtr&amp;amp; operator=(const RefPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  bool operator==(const RefPtr&amp;amp; rhs);

  bool operator==(const T* rawPtr);

private:
  T *pointee;
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// RefPtr Implementation
template&amp;lt;class T&amp;gt;
void
RefPtr&amp;lt;T&amp;gt;::Init()
{
  if (!pointee) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p\n&amp;quot;, typeid(T).name() + 1, pointee);
#endif
  pointee-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(T* realPtr)
  : pointee(realPtr)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(const RefPtr&amp;amp; rhs)
  : pointee(rhs.pointee)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::~RefPtr()
{
  if (!pointee) {
    return;
  }
  pointee-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator=(const RefPtr&amp;amp; rhs)
{
  if (pointee != rhs.pointee) {
    if (pointee) {
      pointee-&amp;gt;Release();
    }
    pointee = rhs.pointee;
    Init();
  }

  return *this;
}

template&amp;lt;class T&amp;gt;
T*
RefPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(pointee);
  return pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(pointee);
  return *pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const RefPtr&amp;amp; rhs)
{
  return pointee == rhs.pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const T* rawPtr)
{
  return pointee == rawPtr;
}

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Interface
//   pointee doesn&amp;#39;t need to support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class SharedPtr
{
public:
  // Default constructor
  SharedPtr(T* realPtr = nullptr);

  // Copy constructor
  SharedPtr(const SharedPtr&amp;amp; rhs);

  ~SharedPtr();

  SharedPtr&amp;amp; operator=(const SharedPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  // Gives clients access to IsShared() and GetCount()
  ReferenceCount&amp;amp; GetCounter()
  {
    return *counter;
  }

private:
  ///////////////////////////////
  // The references are counted inside SharedPtr instead of in the pointee!
  struct Counter: public ReferenceCount {
    Counter(T* realPtr = nullptr)
      : pointee(realPtr) {}
    ~Counter() { delete pointee; }
    T *pointee;
  };

  Counter *counter;
  ///////////////////////////////
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Implementation
template&amp;lt;class T&amp;gt;
void
SharedPtr&amp;lt;T&amp;gt;::Init()
{
  if (!counter) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p\n&amp;quot;, typeid(counter).name() + 1, counter);
#endif
  counter-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(T* realPtr)
  : counter(new Counter(realPtr))
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(const SharedPtr&amp;amp; rhs)
  : counter(rhs.counter)
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::~SharedPtr()
{
  counter-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator=(const SharedPtr&amp;amp; rhs)
{
  if (counter != rhs.counter) {
    counter-&amp;gt;Release();
    counter = rhs.counter;
    Init();
  }
  return *this;
}
template&amp;lt;class T&amp;gt;
T*
SharedPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(counter-&amp;gt;pointee);
  return counter-&amp;gt;pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(counter-&amp;gt;pointee);
  return *(counter-&amp;gt;pointee);
}

#endif // REFPTR_H&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1.js?file=RefPtr.h&quot;&gt; &lt;/script&gt;

&lt;p&gt;You can look &lt;a href=&quot;https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1&quot; title=&quot;RefPtr and SharedPtr&quot;&gt;here&lt;/a&gt; to see how to use it.&lt;/p&gt;

&lt;p&gt;The above code is referenced from &lt;a href=&quot;http://www.aristeia.com/BookErrata/M29Source.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="[&quot;Common&quot;]" /><category term="C/C++" /><category term="Smart Pointer" /><category term="Firefox" /><summary type="html">When I tried to replace Mozilla’s RefPtr with standard C++
smart-pointer to note one of my misusage of it,
I used std::shard_ptr to do it.
However, it didn’t work since there is a huge difference between
Mozilla’s RefPtr and the std::shard_ptr

I’ve never noticed that because I never use smart-pointer
before I worked for Mozilla.
So it’s a perfect chance for me to get closer to look at their difference.

Reference count
Although they’re both using reference-count to track object
and manage objects’ life-time by the count,
they are counting on different things.

Suppose we have reference-counted pointers RefPtr&amp;lt;T&amp;gt;
and std::shard_ptr&amp;lt;T&amp;gt;,
we will call it like RefPtr&amp;lt;Foo&amp;gt; p(new Foo(...))
and std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...))

RefPtr
When using RefPtr&amp;lt;T&amp;gt;,
the total reference is counted on the Foo objects.
That’s see an example below.
// Foo must provide reference-counted interface.
Foo* f = new Foo(...) // The total references will be counted on Foo object f.
RefPtr&amp;lt;Foo&amp;gt; p1(f) // the reference count of f is 1 now.
{
  RefPtr&amp;lt;Foo&amp;gt; p2(f) // the reference count of f is 2 now.  
}
// the reference count of f is back to 1 now since p2 is destroyed.



std::shard_ptr
When using std::shard_ptr&amp;lt;T&amp;gt;,
the total reference is counted on the std::shard_ptr itself.
That’s see an example below.
// Bar does NOT need to provide reference-counted interface.
Bar* b = new Bar(...)
std::shard_ptr&amp;lt;Bar&amp;gt; p1(f) // the reference count of p1 is 1 now.
{
  std::shard_ptr&amp;lt;Bar&amp;gt; p2(p1) // the reference count of p1 and p2 is 2 now.
}
// the reference count of p1 is back to 1 now since p2 is destroyed.

std::shard_ptr&amp;lt;Bar&amp;gt; p3(b) // the reference count of p3 is 1 now.


Even worse, the above program will cause an error:
pointer being freed was not allocated.
The p1 and p3 both control the life-time of b.
When p1 is destroyed, its reference-count is down to 0,
so it will deallocate b.
Nevertheless, When p3 is destroyed,
its reference-count is also down to 0,
so it will deallocate b again and cause an error:
Freeing an already-freed object

Thus, using
std::shard_ptr&amp;lt;Bar&amp;gt; p(new Bar(...))


to replace the following pattern should save your life.
// This is a bad pattern!
Bar* b = new Bar(...)
std::shard_ptr&amp;lt;Bar&amp;gt; p(f)



Sample code
That’s see the example-implementation of these two smart-pointers.
Again, the key difference between RefPtr and std::shard_ptr is

  RefPtr&amp;lt;T&amp;gt; p(new T(...)):
the reference is counted on the newed T object
so the class T must provide reference-counted interface.
  std::shard_ptr&amp;lt;Bar&amp;gt; q(new Bar(...)):
the reference is counted on the q itself.


#ifndef REFPTR_H
#define REFPTR_H

#include &amp;lt;cassert&amp;gt;

#define DEBUG
#ifdef DEBUG
#ifdef NDEBUG
#undef NDEBUG
#endif // NDEBUG
#include &amp;lt;iostream&amp;gt;
#endif // DEBUG

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Interface
class ReferenceCount
{
public:
  void AddRef();
  void Release();
  unsigned int GetCount();
  bool IsShared();

protected:
  ReferenceCount();
  // Disallow copy constructor
  ReferenceCount(const ReferenceCount&amp;amp; rhs) = delete;
  // ReferenceCount&amp;amp; operator=(const ReferenceCount&amp;amp; rhs);
  virtual ~ReferenceCount();

private:
  unsigned int count;
};

///////////////////////////////////////////////////////////////////////////////
// ReferenceCount Implementation
ReferenceCount::ReferenceCount()
  : count(0)
{
}

// ReferenceCount::ReferenceCount(const ReferenceCount&amp;amp; rhs)
//   : count(0)
// {
// }

ReferenceCount::~ReferenceCount()
{
}

// ReferenceCount&amp;amp;
// ReferenceCount::&amp;amp; operator=(const ReferenceCount&amp;amp; rhs)
// {
//   return this;
// }

void
ReferenceCount::AddRef()
{
  ++count;
}

void
ReferenceCount::Release()
{
  if (!--count) {
#ifdef DEBUG
    fprintf(stderr, &amp;quot;Release %s @ %p &amp;quot;, typeid(*this).name() + 1,this);
#endif
    delete this;
  }
}

unsigned int
ReferenceCount::GetCount()
{
  return count;
}

bool
ReferenceCount::IsShared()
{
  return count &amp;gt; 1;
}

///////////////////////////////////////////////////////////////////////////////
// RefPtr Interface
//   pointee must support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class RefPtr
{
public:
  // Default constructor
  RefPtr(T* realPtr = nullptr);

  // Copy constructor
  RefPtr(const RefPtr&amp;amp; rhs);

  ~RefPtr();

  RefPtr&amp;amp; operator=(const RefPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  bool operator==(const RefPtr&amp;amp; rhs);

  bool operator==(const T* rawPtr);

private:
  T *pointee;
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// RefPtr Implementation
template&amp;lt;class T&amp;gt;
void
RefPtr&amp;lt;T&amp;gt;::Init()
{
  if (!pointee) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p &amp;quot;, typeid(T).name() + 1, pointee);
#endif
  pointee-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(T* realPtr)
  : pointee(realPtr)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::RefPtr(const RefPtr&amp;amp; rhs)
  : pointee(rhs.pointee)
{
  Init();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;::~RefPtr()
{
  if (!pointee) {
    return;
  }
  pointee-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
RefPtr&amp;lt;T&amp;gt;&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator=(const RefPtr&amp;amp; rhs)
{
  if (pointee != rhs.pointee) {
    if (pointee) {
      pointee-&amp;gt;Release();
    }
    pointee = rhs.pointee;
    Init();
  }

  return *this;
}

template&amp;lt;class T&amp;gt;
T*
RefPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(pointee);
  return pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
RefPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(pointee);
  return *pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const RefPtr&amp;amp; rhs)
{
  return pointee == rhs.pointee;
}

template&amp;lt;class T&amp;gt;
bool
RefPtr&amp;lt;T&amp;gt;::operator==(const T* rawPtr)
{
  return pointee == rawPtr;
}

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Interface
//   pointee doesn&amp;#39;t need to support the ReferenceCount interface
template&amp;lt;typename T&amp;gt;
class SharedPtr
{
public:
  // Default constructor
  SharedPtr(T* realPtr = nullptr);

  // Copy constructor
  SharedPtr(const SharedPtr&amp;amp; rhs);

  ~SharedPtr();

  SharedPtr&amp;amp; operator=(const SharedPtr&amp;amp; rhs);

  T* operator-&amp;gt;() const;

  T&amp;amp; operator*() const;

  // Gives clients access to IsShared() and GetCount()
  ReferenceCount&amp;amp; GetCounter()
  {
    return *counter;
  }

private:
  ///////////////////////////////
  // The references are counted inside SharedPtr instead of in the pointee!
  struct Counter: public ReferenceCount {
    Counter(T* realPtr = nullptr)
      : pointee(realPtr) {}
    ~Counter() { delete pointee; }
    T *pointee;
  };

  Counter *counter;
  ///////////////////////////////
  void Init();
};

///////////////////////////////////////////////////////////////////////////////
// SharedPtr Implementation
template&amp;lt;class T&amp;gt;
void
SharedPtr&amp;lt;T&amp;gt;::Init()
{
  if (!counter) {
    return;
  }
#ifdef DEBUG
  fprintf(stderr, &amp;quot;Reference counting for %s @ %p &amp;quot;, typeid(counter).name() + 1, counter);
#endif
  counter-&amp;gt;AddRef();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(T* realPtr)
  : counter(new Counter(realPtr))
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::SharedPtr(const SharedPtr&amp;amp; rhs)
  : counter(rhs.counter)
{
  Init();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;::~SharedPtr()
{
  counter-&amp;gt;Release();
}

template&amp;lt;class T&amp;gt;
SharedPtr&amp;lt;T&amp;gt;&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator=(const SharedPtr&amp;amp; rhs)
{
  if (counter != rhs.counter) {
    counter-&amp;gt;Release();
    counter = rhs.counter;
    Init();
  }
  return *this;
}
template&amp;lt;class T&amp;gt;
T*
SharedPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{
  assert(counter-&amp;gt;pointee);
  return counter-&amp;gt;pointee;
}

template&amp;lt;class T&amp;gt;
T&amp;amp;
SharedPtr&amp;lt;T&amp;gt;::operator*() const
{
  assert(counter-&amp;gt;pointee);
  return *(counter-&amp;gt;pointee);
}

#endif // REFPTR_H


You can look here to see how to use it.

The above code is referenced from here</summary></entry><entry><title type="html">Development Notes for Mozilla</title><link href="http://localhost:4000/post/development-notes-for-mozilla" rel="alternate" type="text/html" title="Development Notes for Mozilla" /><published>2017-07-19T00:00:00+08:00</published><updated>2017-07-19T00:00:00+08:00</updated><id>http://localhost:4000/post/development-notes-for-mozilla</id><content type="html" xml:base="http://localhost:4000/post/development-notes-for-mozilla">&lt;p&gt;The following are some of my notes to develop the mozilla products.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.penflip.com/Chun-Min/mozilla-newbie-notes&quot; title=&quot;Mozilla Newbie Notes&quot;&gt;Basic knowledge&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;XPCOM&lt;/li&gt;
      &lt;li&gt;WebIDL&lt;/li&gt;
      &lt;li&gt;Mochitest&lt;/li&gt;
      &lt;li&gt;others&lt;/li&gt;
      &lt;li&gt;&lt;del&gt;Firefox OS&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1S4njAbl4tSFCrJ3cnE30L4PcYeWdvY-1wcghX2mWNOE/edit?usp=sharing&quot; title=&quot;IPDL&quot;&gt;IPDL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1o9qeSucSDAJO94TmZmebxRnGepY7MVy-MeVGqyaIO0s/edit?usp=sharing&quot; title=&quot;Firefox (System) Add-on&quot;&gt;(System) Add-on&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1eDjlmBdBrECQ_vXve0HgzmBilgL8HwHrcFQz9puGGr0/edit?usp=sharing&quot; title=&quot;Message Manager&quot;&gt;Message Manager&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1zxanY8xDioeIrfPyuzx9QDgggO1pC8erqhcL30gL7Wc/edit?usp=sharing&quot; title=&quot;Keyboard Event Dispatch&quot;&gt;Keyboard Event Dispatch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/15iXd4ZXy9Y1uKdXkuFsdoqXAzw7Y4pUFKlDaNiAFkb0/edit?usp=sharing&quot; title=&quot;JPAKE over TLS&quot;&gt;JPAKE over TLS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Chun-Min Chang</name><email>chun.m.chang@gmail.com</email></author><category term="Mozilla" /><category term="Firefox" /><category term="Fennec" /><summary type="html">The following are some of my notes to develop the mozilla products.


  Basic knowledge
    
      XPCOM
      WebIDL
      Mochitest
      others
      Firefox OS
    
  
  IPDL
  (System) Add-on
  Message Manager
  Keyboard Event Dispatch
  JPAKE over TLS</summary></entry></feed>
