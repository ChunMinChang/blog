<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">


<meta name="keywords" content="Fibonacci">


<!-- Begin Jekyll SEO tag v1.3.3 -->
<title>Calculating Fibonacci Numbers by Fast Doubling - Peak Up</title>
<meta property="og:title" content="Calculating Fibonacci Numbers by Fast Doubling" />
<meta name="description" content="In previous post,we learned how to calculate Fibonacci numbers by Fast Doubling in math.Today, we will apply it in programming and optimize it step by step.Fast DoublingIt’s natural to write a recursive implementation by the above definition.In the following steps, we will implement recursive versions first,then try converting it into iterative versions.Recursive (Top-down) ApproachGiven a , we could calculate Fibonacci numbers  by:if (n % 2) { // n is odd: F(n) = F(((n-1)/2) + 1)^2 + F((n-1) / 2)^2  unsigned int k = (n - 1) / 2;  return fib(k) * fib(k) + fib(k + 1) * fib(k + 1);} else { // n is even: F(n) = F(n/2) * [ 2 * F(n/2 + 1) - F(n/2) ]  unsigned int k = n / 2;  return fib(k) * [ 2 * fib(k + 1) - fib(k) ];}From above code, we can know that the code stack will be entered again and again,so we need to define when to stop it.if (n == 0) {  return 0; // F(0) = 0.} else if (n &lt;= 2) {  return 1; // F(1) = F(2) = 0.} else {  // Keep call itself recursively to get the answer.  // Put the main body here.}We only calculate Fibonacci numbers from ,so we need to stop when .The fib(0) may be asked from calculating fib(1) = fib(0)*fib(0) + fib(1)*fib(1)(by setting  to ,so we also need to define fib(1) = 1 directly,or it will cause an endless recursion.Similarly, the fib(1) may be asked from calculating fib(2) = fib(1) * [2 * fib(2) - fib(1)](by setting  to ,so fib(2) = 1 also needs to be returned directly.As the result, the code can be written into:///////////////////////////////////////////////////////////////////////////////// Fast doubling: O(log(n))//   Using 2n to the Fibonacci matrix above, we can derive that://     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]//     F(2n+1) = F(n+1)^2 + F(n)^2//     (and F(2n-1) = F(n)^2 + F(n-1)^2)uint64_t fib(unsigned int n){  if (n == 0) {    return 0; // F(0) = 0.  } else if (n &lt;= 2) {    return 1; // F(1) = F(2) = 0.  }  unsigned int k = 0;  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2    k = (n - 1) / 2;    return fib(k) * fib(k) + fib(k + 1) * fib(k + 1);  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    k = n / 2;    return fib(k) * (2 * fib(k + 1) - fib(k));  }}Now, let we look where we could improve from this simple version.We use duplicated fib(k) and fib(k + 1) to calculate fib(n).That is, we will have two duplicated recursive processes to do the same work.It would be a waste of the time.Another trick is that we could use n = n / 2 in both cases( is odd or even) since the result of n = (n - 1) / 2 is sameas n = n / 2 in C/C++’s world if n is an odd integer.Thus, we can rewrite the code into:uint64_t fib(unsigned int n){  if (n == 0) {    return 0; // F(0) = 0.  } else if (n &lt;= 2) {    return 1; // F(1) = F(2) = 1.  }  unsigned int k = n / 2; // k = n/2 if n is even. k = (n-1)/2 if n is odd.  uint64_t a = fib(k);  uint64_t b = fib(k + 1);  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2    return a * a + b * b;  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    return a * (2 * b - a);  }}MemoizationDo we save all duplicated task now? No.Suppose we need to find , then we need to get  ….It’s clear that we have a duplicated  on above figure. can return value directly, while  can not.Therefore, the sub-tree(sub-process) whose root is  will be executed twice.The larger the  is, the more duplicated sub-process will be executed.To avoid the waste, we can add an array to save all the calculated value.We check the array first when  is calculated.If there is already a saved value in the array at ,then we can use it directly.Otherwise, it will be calculated as usual.It’s called memoization.We will save  as the  element in the array.In this case, the  is not calculated successively.For example, to get , we only need .We don’t need , so there is no value at the  element in the array.You can use hash map instead of array to avoid the waste of memory.However, retrieving data from array is faster than hash map,so we apply array in our sample code:const unsigned int SIZE = 1000;// 4 is not a fibonacci number, so using it as initialized value.const uint64_t INIT = 4;// In this case, F is not calculated successively. For example,// To get F(6), we only need F(4), F(3), F(2), F(1), F(0) (no F(5)),// so the other elements in F is still INIT.// Another way is to use hash map(std::unordered_map), however,// it will be slower.uint64_t MEM[SIZE] = { [0 ... SIZE-1] = INIT };uint64_t fib(unsigned int n){  if (MEM[n] != INIT) {    return MEM[n];  }  if (n == 0) {    return (MEM[n] = 0); // F(0) = 0.  } else if (n &lt;= 2) {    return (MEM[n] = 1); // F(1) = F(2) = 1.  }  unsigned int k = n / 2; // k = n/2 if n is even. k = (n-1)/2 if n is odd.  uint64_t a = fib(k);  uint64_t b = fib(k + 1);  // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2, if n is odd.  //    F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ], if n is even.  return (MEM[n] = (n % 2) ? a * a + b * b : a * (2 * b - a));}State vectorAlthough we can speed up the calculating by applying memoization above,the memory consumption with this approach grows with .Is it possible to use a fixed memory no matter how big  is?The answer is yes. Actually, we could just use a two-elements array to do it.From the formula, we can calculate  from .For example, to calculate , we need .To calculate , we need .To calculate , we need .To calculate , we need (so we need to stop here since  is the dead end).However, how do we get when we only have  to calculate ?Or how to get when we only have  to calculate  …?By applying  to formula, we can use  to get .Then we can get .Thus, we are able to get  by the following procedure:Thus, we could keep using two-elements arrayfor to compute what we want and update it step by step.But how to determine the state we should update from , or  ?It’s simple. If  is even, we need to find , where  since .Then we can use to calculate .Otherwise, if  is odd, we need to find , where  since .Then we can use to calculate and then get  by .In summary, the procedure can be organized as follows:                                                                  10      5      2      1      0               is odd             v             v                                                                                                                                                     The last two rows, , are the state vectorthat contains our answer.The first row , is the index of the first elementof the state vector .The second row indicates that whether  is odd or not.If  is odd(recall what we discuss above),then we need to update state from from to  since .The third row is used to record if we need get from .Otherwise, if  is even, updating statefrom  to  directly.From the top-down perspective, to get , we need .To get , we need .To get , we need .To get , we need .We will demonstrate how we do it recursively below.From the bottom-up perspective, we can use to get ,then  to get , to get , to get .We will demonstrate how we do it in iterative section.The recursive approach is easier to understand.By what we summarized above, the simplest implementation will be:// Set f[0], f[1] to F(n), F(n+1).void fib_helper(unsigned int n, uint64_t f[]);// 4 is not a fibonacci number, so using it as initialized value.const uint64_t INIT = 4;uint64_t fib(unsigned int n){  uint64_t f[2] = { INIT, INIT };  fib_helper(n, f);  return f[0];}void fib_helper(unsigned int n, uint64_t f[]){  if (n == 0) {    f[0] = 0; f[1] = 1;    return;  }  unsigned int k = 0;  if (n % 2) {    k = (n - 1) / 2;    fib_helper(k, f);    uint64_t a = f[0];            // F(k) = F((n-1)/2)    uint64_t b = f[1];            // F(k + 1) = F((n- )/2 + 1)    uint64_t c = a * (2 * b - a); // F(n-1) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]    uint64_t d = a * a + b * b;   // F(n) = F(2k + 1) = F(k)^2 + F(k+1)^2    f[0] = d;                     // F(n)    f[1] = c + d;                 // F(n+1) = F(n-1) + F(n)  } else {    k = n / 2;    fib_helper(k, f);    uint64_t a = f[0];            // F(k) = F(n/2)    uint64_t b = f[1];            // F(k + 1) = F(n/2 + 1)    f[0] = a * (2 * b - a);       // F(n) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]    f[1] = a * a + b * b;         // F(n + 1) = F(2k + 1) = F(k)^2 + F(k+1)^2  }}The above fib_helper is quite tedious,we can be simplify it into:// Set f[0], f[1] to F(n), F(n+1).void fib_helper(unsigned int n, uint64_t f[]){  if (!n) {    f[0] = 0;    f[1] = 1;    return;  }  fib_helper(n / 2, f);  // k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.  uint64_t a = f[0]; // F(k)  uint64_t b = f[1]; // F(k+1)  uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]  uint64_t d = a * a + b * b;   // F(2k+1) = F(k+1)^2 + F(k)^2  if (n % 2) {    // k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).    f[0] = d;     // F(n) = F(2k+1).    f[1] = c + d; // F(n+1) = F(n-1) + F(n) = F(2k) + F(2k+1).  } else {        // k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).    f[0] = c;     // F(n) = F(2k).    f[1] = d;     // F(n+1) = F(2k).  }}You could also replace array with std::vector,so the code will looks more elegant.However, it will be slower than using array directly.// Return vector [ F(n), F(n+1) ].std::vector&lt;uint64_t&gt; fib_helper(unsigned int n);uint64_t fib(unsigned int n){  return fib_helper(n)[0];}std::vector&lt;uint64_t&gt; fib_helper(unsigned int n){  if (!n) {    // [F(0), F(1)] = [0 , 1]    return { 0 , 1 };  }  std::vector&lt;uint64_t&gt; f(fib_helper(n / 2));  // k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.  uint64_t a = f[0]; // F(k)  uint64_t b = f[1]; // F(k+1)  uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]  uint64_t d = a * a + b * b;   // F(2k+1) = F(k+1)^2 + F(k)^2  if (n % 2) { // k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).    // [F(n), F(n+1)] = [F(2k+1), F(2k+2)] = [F(2k+1), F(2k) + F(2k+1)]    return { d, c + d };  } else { // k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).    // [F(n), F(n+1)] = [F(2k), F(2k+1)].    return { c, d };  }}Iterative (Bottom-up) ApproachThe recursive approach is implemented from the top-down perspective.We could also do it in bottom-up way.To convert the recursive steps into an iterative loop,we need to find the initialized state and the stop condition.In the recursive approach, no matter what  is, the final state vector(when the recursive steps stops) is always ,, and it must be called from calculating the state [F_1, F_2].Recall how we calculate :  We recursively calculate  from ,          then ,      then ,      then ,      then stop recursive steps when .        Next, we get the state vector  for ,          then return on the same track with opposite directionto calculate the state vector for ,      then for       then for ,      and finally get the answer for .      The recursive steps are used to get the trackfrom  to ,then calculate  for each .To remove the recursive steps, we need to have a way to compute the track.We can use a stack to track the change for , starting push from , then , , , ,then the track can be get from popping them from  to .Thus, the initialized state is and the stop condition is to check whether the stack is empty.(Using stack is one common approach toconvert recursive code into the iterative one.)uint64_t fib(unsigned int n){  // To compute the track from n, n/2, ..., 1, 0.  std::stack&lt;unsigned int&gt; s;  while(n) {    s.push(n);    n /= 2; // n = floor(n/2)  }  s.push(n); // n = 0 now.  uint64_t a; // F(n)  uint64_t b; // F(n+1)  while (!s.empty()) {    unsigned int m = s.top(); s.pop();    if (m == 0) { // Initializing a, b.      a = 0; // F(0) = 0      b = 1; // F(1) = 1      continue;    }    // Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.    // k = m/2, if m is even. k = (m-1)/2, if m is odd.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (m % 2) {  // m = 2k+1:      a = d;      //  F(m) = F(2k+1)      b = c + d;  //  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)    } else {      // m = 2k:      a = c;      //  F(m) = F(2k)      b = d;      //  F(m+1) = F(2k+1)    }  }  return a;}The above code is a bit ugly for simulating the recursive steps like:The initialized state is usually set outside of the loop directly like below:...uint64_t a = 0; // F(0) = 0uint64_t b = 1; // F(1) = 1while (!s.empty()) {  ...}...Since initialized state is set before the loop,we should start the track from  to :std::stack&lt;unsigned int&gt; s;while (n) {  s.push(n);  n /= 2;}// No `s.push(n); // n = 0 now.` here!Therefore, the code will be:uint64_t fib(unsigned int n){  std::stack&lt;unsigned int&gt; s;  while (n) {    s.push(n);    /*n /= 2*/n &gt;&gt;= 1;  }  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  while (!s.empty()) {    unsigned int m = s.top(); s.pop();    // Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.    // k = m/2, if m is even. k = (m-1)/2, if m is odd.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (/*m % 2*/m &amp; 1) { // m = 2k+1:      a = d;              //  F(m) = F(2k+1)      b = c + d;          //  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)    } else {              // m = 2k:      a = c;              //  F(m) = F(2k)      b = d;              //  F(m+1) = F(2k+1)    }  }  return a;}Another trick above is to replace n /= 2 by n &gt;&gt;= 1and m % 2 by m &amp; 1.It will be faster a little bit.Non-stack approachSince applying std::stack will pay for memory allocation,so we should try not using it for better performance.The reason we need the stack is to get the track for each ,where  until .And the track is used to determine what state we should updatefrom , to  or ,by the given  is even or odd.In the above implementation,we put the ,where  denotes is right shifted by  bits(n_j = n &gt;&gt; j)and  is an integer,to the stack, and then iteratively check is odd or even.We could do it without stack!Assume the highest 1-bit in  is the th bit from right side,then the loop will execute  times.(so the time complexity is )Therefore, we could loop  times to calculate from  to .As the result, the code will be:uint64_t fib(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  for (int j = h - 1 ; j &gt;= 0 ; --j) {    // n_j = floor(n / 2^j) = n &gt;&gt; j, k = floor(n_j / 2), (n_j = n when j = 0)    // then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if ((n &gt;&gt; j) &amp; 1) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;            //   F(n_j) = F(2k+1)      b = c + d;        //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k+1)    } else {            // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;            //   F(n_j) = F(2k)      b = d;            //   F(n_j + 1) = F(2k + 1)    }  }  return a;}By Bit-maskDoing AND operation(&amp;) to the last bit of  above is same asdoing AND operation(&amp;) from the highest bit to the lowest bitof the . Thus, we could also rewrite the code into:uint64_t fib(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  // There is only one `1` in the bits of `mask`. The `1`&#39;s position is same as  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right  // iteratively to do `AND` operation with `n` to check `n_j` is odd or even,  // where n_j is defined below.  for (unsigned int mask = 1 &lt;&lt; (h - 1) ; mask ; mask &gt;&gt;= 1) { // Run h times!    // Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &gt;&gt; j    // (n_j = n when j = 0), k = floor(n_j / 2), then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (mask &amp; n) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;        //   F(n_j) = F(2k + 1)      b = c + d;    //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)    } else {        // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;        //   F(n_j) = F(2k)      b = d;        //   F(n_j + 1) = F(2k + 1)    }  }  return a;}All the above code are on gist here." />
<meta property="og:description" content="In previous post,we learned how to calculate Fibonacci numbers by Fast Doubling in math.Today, we will apply it in programming and optimize it step by step.Fast DoublingIt’s natural to write a recursive implementation by the above definition.In the following steps, we will implement recursive versions first,then try converting it into iterative versions.Recursive (Top-down) ApproachGiven a , we could calculate Fibonacci numbers  by:if (n % 2) { // n is odd: F(n) = F(((n-1)/2) + 1)^2 + F((n-1) / 2)^2  unsigned int k = (n - 1) / 2;  return fib(k) * fib(k) + fib(k + 1) * fib(k + 1);} else { // n is even: F(n) = F(n/2) * [ 2 * F(n/2 + 1) - F(n/2) ]  unsigned int k = n / 2;  return fib(k) * [ 2 * fib(k + 1) - fib(k) ];}From above code, we can know that the code stack will be entered again and again,so we need to define when to stop it.if (n == 0) {  return 0; // F(0) = 0.} else if (n &lt;= 2) {  return 1; // F(1) = F(2) = 0.} else {  // Keep call itself recursively to get the answer.  // Put the main body here.}We only calculate Fibonacci numbers from ,so we need to stop when .The fib(0) may be asked from calculating fib(1) = fib(0)*fib(0) + fib(1)*fib(1)(by setting  to ,so we also need to define fib(1) = 1 directly,or it will cause an endless recursion.Similarly, the fib(1) may be asked from calculating fib(2) = fib(1) * [2 * fib(2) - fib(1)](by setting  to ,so fib(2) = 1 also needs to be returned directly.As the result, the code can be written into:///////////////////////////////////////////////////////////////////////////////// Fast doubling: O(log(n))//   Using 2n to the Fibonacci matrix above, we can derive that://     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]//     F(2n+1) = F(n+1)^2 + F(n)^2//     (and F(2n-1) = F(n)^2 + F(n-1)^2)uint64_t fib(unsigned int n){  if (n == 0) {    return 0; // F(0) = 0.  } else if (n &lt;= 2) {    return 1; // F(1) = F(2) = 0.  }  unsigned int k = 0;  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2    k = (n - 1) / 2;    return fib(k) * fib(k) + fib(k + 1) * fib(k + 1);  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    k = n / 2;    return fib(k) * (2 * fib(k + 1) - fib(k));  }}Now, let we look where we could improve from this simple version.We use duplicated fib(k) and fib(k + 1) to calculate fib(n).That is, we will have two duplicated recursive processes to do the same work.It would be a waste of the time.Another trick is that we could use n = n / 2 in both cases( is odd or even) since the result of n = (n - 1) / 2 is sameas n = n / 2 in C/C++’s world if n is an odd integer.Thus, we can rewrite the code into:uint64_t fib(unsigned int n){  if (n == 0) {    return 0; // F(0) = 0.  } else if (n &lt;= 2) {    return 1; // F(1) = F(2) = 1.  }  unsigned int k = n / 2; // k = n/2 if n is even. k = (n-1)/2 if n is odd.  uint64_t a = fib(k);  uint64_t b = fib(k + 1);  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2    return a * a + b * b;  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    return a * (2 * b - a);  }}MemoizationDo we save all duplicated task now? No.Suppose we need to find , then we need to get  ….It’s clear that we have a duplicated  on above figure. can return value directly, while  can not.Therefore, the sub-tree(sub-process) whose root is  will be executed twice.The larger the  is, the more duplicated sub-process will be executed.To avoid the waste, we can add an array to save all the calculated value.We check the array first when  is calculated.If there is already a saved value in the array at ,then we can use it directly.Otherwise, it will be calculated as usual.It’s called memoization.We will save  as the  element in the array.In this case, the  is not calculated successively.For example, to get , we only need .We don’t need , so there is no value at the  element in the array.You can use hash map instead of array to avoid the waste of memory.However, retrieving data from array is faster than hash map,so we apply array in our sample code:const unsigned int SIZE = 1000;// 4 is not a fibonacci number, so using it as initialized value.const uint64_t INIT = 4;// In this case, F is not calculated successively. For example,// To get F(6), we only need F(4), F(3), F(2), F(1), F(0) (no F(5)),// so the other elements in F is still INIT.// Another way is to use hash map(std::unordered_map), however,// it will be slower.uint64_t MEM[SIZE] = { [0 ... SIZE-1] = INIT };uint64_t fib(unsigned int n){  if (MEM[n] != INIT) {    return MEM[n];  }  if (n == 0) {    return (MEM[n] = 0); // F(0) = 0.  } else if (n &lt;= 2) {    return (MEM[n] = 1); // F(1) = F(2) = 1.  }  unsigned int k = n / 2; // k = n/2 if n is even. k = (n-1)/2 if n is odd.  uint64_t a = fib(k);  uint64_t b = fib(k + 1);  // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2, if n is odd.  //    F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ], if n is even.  return (MEM[n] = (n % 2) ? a * a + b * b : a * (2 * b - a));}State vectorAlthough we can speed up the calculating by applying memoization above,the memory consumption with this approach grows with .Is it possible to use a fixed memory no matter how big  is?The answer is yes. Actually, we could just use a two-elements array to do it.From the formula, we can calculate  from .For example, to calculate , we need .To calculate , we need .To calculate , we need .To calculate , we need (so we need to stop here since  is the dead end).However, how do we get when we only have  to calculate ?Or how to get when we only have  to calculate  …?By applying  to formula, we can use  to get .Then we can get .Thus, we are able to get  by the following procedure:Thus, we could keep using two-elements arrayfor to compute what we want and update it step by step.But how to determine the state we should update from , or  ?It’s simple. If  is even, we need to find , where  since .Then we can use to calculate .Otherwise, if  is odd, we need to find , where  since .Then we can use to calculate and then get  by .In summary, the procedure can be organized as follows:                                                                  10      5      2      1      0               is odd             v             v                                                                                                                                                     The last two rows, , are the state vectorthat contains our answer.The first row , is the index of the first elementof the state vector .The second row indicates that whether  is odd or not.If  is odd(recall what we discuss above),then we need to update state from from to  since .The third row is used to record if we need get from .Otherwise, if  is even, updating statefrom  to  directly.From the top-down perspective, to get , we need .To get , we need .To get , we need .To get , we need .We will demonstrate how we do it recursively below.From the bottom-up perspective, we can use to get ,then  to get , to get , to get .We will demonstrate how we do it in iterative section.The recursive approach is easier to understand.By what we summarized above, the simplest implementation will be:// Set f[0], f[1] to F(n), F(n+1).void fib_helper(unsigned int n, uint64_t f[]);// 4 is not a fibonacci number, so using it as initialized value.const uint64_t INIT = 4;uint64_t fib(unsigned int n){  uint64_t f[2] = { INIT, INIT };  fib_helper(n, f);  return f[0];}void fib_helper(unsigned int n, uint64_t f[]){  if (n == 0) {    f[0] = 0; f[1] = 1;    return;  }  unsigned int k = 0;  if (n % 2) {    k = (n - 1) / 2;    fib_helper(k, f);    uint64_t a = f[0];            // F(k) = F((n-1)/2)    uint64_t b = f[1];            // F(k + 1) = F((n- )/2 + 1)    uint64_t c = a * (2 * b - a); // F(n-1) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]    uint64_t d = a * a + b * b;   // F(n) = F(2k + 1) = F(k)^2 + F(k+1)^2    f[0] = d;                     // F(n)    f[1] = c + d;                 // F(n+1) = F(n-1) + F(n)  } else {    k = n / 2;    fib_helper(k, f);    uint64_t a = f[0];            // F(k) = F(n/2)    uint64_t b = f[1];            // F(k + 1) = F(n/2 + 1)    f[0] = a * (2 * b - a);       // F(n) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]    f[1] = a * a + b * b;         // F(n + 1) = F(2k + 1) = F(k)^2 + F(k+1)^2  }}The above fib_helper is quite tedious,we can be simplify it into:// Set f[0], f[1] to F(n), F(n+1).void fib_helper(unsigned int n, uint64_t f[]){  if (!n) {    f[0] = 0;    f[1] = 1;    return;  }  fib_helper(n / 2, f);  // k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.  uint64_t a = f[0]; // F(k)  uint64_t b = f[1]; // F(k+1)  uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]  uint64_t d = a * a + b * b;   // F(2k+1) = F(k+1)^2 + F(k)^2  if (n % 2) {    // k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).    f[0] = d;     // F(n) = F(2k+1).    f[1] = c + d; // F(n+1) = F(n-1) + F(n) = F(2k) + F(2k+1).  } else {        // k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).    f[0] = c;     // F(n) = F(2k).    f[1] = d;     // F(n+1) = F(2k).  }}You could also replace array with std::vector,so the code will looks more elegant.However, it will be slower than using array directly.// Return vector [ F(n), F(n+1) ].std::vector&lt;uint64_t&gt; fib_helper(unsigned int n);uint64_t fib(unsigned int n){  return fib_helper(n)[0];}std::vector&lt;uint64_t&gt; fib_helper(unsigned int n){  if (!n) {    // [F(0), F(1)] = [0 , 1]    return { 0 , 1 };  }  std::vector&lt;uint64_t&gt; f(fib_helper(n / 2));  // k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.  uint64_t a = f[0]; // F(k)  uint64_t b = f[1]; // F(k+1)  uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]  uint64_t d = a * a + b * b;   // F(2k+1) = F(k+1)^2 + F(k)^2  if (n % 2) { // k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).    // [F(n), F(n+1)] = [F(2k+1), F(2k+2)] = [F(2k+1), F(2k) + F(2k+1)]    return { d, c + d };  } else { // k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).    // [F(n), F(n+1)] = [F(2k), F(2k+1)].    return { c, d };  }}Iterative (Bottom-up) ApproachThe recursive approach is implemented from the top-down perspective.We could also do it in bottom-up way.To convert the recursive steps into an iterative loop,we need to find the initialized state and the stop condition.In the recursive approach, no matter what  is, the final state vector(when the recursive steps stops) is always ,, and it must be called from calculating the state [F_1, F_2].Recall how we calculate :  We recursively calculate  from ,          then ,      then ,      then ,      then stop recursive steps when .        Next, we get the state vector  for ,          then return on the same track with opposite directionto calculate the state vector for ,      then for       then for ,      and finally get the answer for .      The recursive steps are used to get the trackfrom  to ,then calculate  for each .To remove the recursive steps, we need to have a way to compute the track.We can use a stack to track the change for , starting push from , then , , , ,then the track can be get from popping them from  to .Thus, the initialized state is and the stop condition is to check whether the stack is empty.(Using stack is one common approach toconvert recursive code into the iterative one.)uint64_t fib(unsigned int n){  // To compute the track from n, n/2, ..., 1, 0.  std::stack&lt;unsigned int&gt; s;  while(n) {    s.push(n);    n /= 2; // n = floor(n/2)  }  s.push(n); // n = 0 now.  uint64_t a; // F(n)  uint64_t b; // F(n+1)  while (!s.empty()) {    unsigned int m = s.top(); s.pop();    if (m == 0) { // Initializing a, b.      a = 0; // F(0) = 0      b = 1; // F(1) = 1      continue;    }    // Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.    // k = m/2, if m is even. k = (m-1)/2, if m is odd.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (m % 2) {  // m = 2k+1:      a = d;      //  F(m) = F(2k+1)      b = c + d;  //  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)    } else {      // m = 2k:      a = c;      //  F(m) = F(2k)      b = d;      //  F(m+1) = F(2k+1)    }  }  return a;}The above code is a bit ugly for simulating the recursive steps like:The initialized state is usually set outside of the loop directly like below:...uint64_t a = 0; // F(0) = 0uint64_t b = 1; // F(1) = 1while (!s.empty()) {  ...}...Since initialized state is set before the loop,we should start the track from  to :std::stack&lt;unsigned int&gt; s;while (n) {  s.push(n);  n /= 2;}// No `s.push(n); // n = 0 now.` here!Therefore, the code will be:uint64_t fib(unsigned int n){  std::stack&lt;unsigned int&gt; s;  while (n) {    s.push(n);    /*n /= 2*/n &gt;&gt;= 1;  }  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  while (!s.empty()) {    unsigned int m = s.top(); s.pop();    // Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.    // k = m/2, if m is even. k = (m-1)/2, if m is odd.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (/*m % 2*/m &amp; 1) { // m = 2k+1:      a = d;              //  F(m) = F(2k+1)      b = c + d;          //  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)    } else {              // m = 2k:      a = c;              //  F(m) = F(2k)      b = d;              //  F(m+1) = F(2k+1)    }  }  return a;}Another trick above is to replace n /= 2 by n &gt;&gt;= 1and m % 2 by m &amp; 1.It will be faster a little bit.Non-stack approachSince applying std::stack will pay for memory allocation,so we should try not using it for better performance.The reason we need the stack is to get the track for each ,where  until .And the track is used to determine what state we should updatefrom , to  or ,by the given  is even or odd.In the above implementation,we put the ,where  denotes is right shifted by  bits(n_j = n &gt;&gt; j)and  is an integer,to the stack, and then iteratively check is odd or even.We could do it without stack!Assume the highest 1-bit in  is the th bit from right side,then the loop will execute  times.(so the time complexity is )Therefore, we could loop  times to calculate from  to .As the result, the code will be:uint64_t fib(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  for (int j = h - 1 ; j &gt;= 0 ; --j) {    // n_j = floor(n / 2^j) = n &gt;&gt; j, k = floor(n_j / 2), (n_j = n when j = 0)    // then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if ((n &gt;&gt; j) &amp; 1) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;            //   F(n_j) = F(2k+1)      b = c + d;        //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k+1)    } else {            // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;            //   F(n_j) = F(2k)      b = d;            //   F(n_j + 1) = F(2k + 1)    }  }  return a;}By Bit-maskDoing AND operation(&amp;) to the last bit of  above is same asdoing AND operation(&amp;) from the highest bit to the lowest bitof the . Thus, we could also rewrite the code into:uint64_t fib(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  // There is only one `1` in the bits of `mask`. The `1`&#39;s position is same as  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right  // iteratively to do `AND` operation with `n` to check `n_j` is odd or even,  // where n_j is defined below.  for (unsigned int mask = 1 &lt;&lt; (h - 1) ; mask ; mask &gt;&gt;= 1) { // Run h times!    // Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &gt;&gt; j    // (n_j = n when j = 0), k = floor(n_j / 2), then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (mask &amp; n) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;        //   F(n_j) = F(2k + 1)      b = c + d;    //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)    } else {        // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;        //   F(n_j) = F(2k)      b = d;        //   F(n_j + 1) = F(2k + 1)    }  }  return a;}All the above code are on gist here." />
<link rel="canonical" href="http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling" />
<meta property="og:url" content="http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling" />
<meta property="og:site_name" content="Peak Up" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-31T00:00:00+08:00" />
<link rel="next" href="http://localhost:4000/post/master-fibonacci" title="Master Fibonacci" />
<link rel="prev" href="http://localhost:4000/post/matrix-difference-equation-for-fibonacci-sequence" title="Matrix Difference Equation for Fibonacci Sequence" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Calculating Fibonacci Numbers by Fast Doubling",
    "datePublished": "2017-08-31T00:00:00+08:00",
    "description": "In previous post,we learned how to calculate Fibonacci numbers by Fast Doubling in math.Today, we will apply it in programming and optimize it step by step.Fast DoublingIt’s natural to write a recursive implementation by the above definition.In the following steps, we will implement recursive versions first,then try converting it into iterative versions.Recursive (Top-down) ApproachGiven a , we could calculate Fibonacci numbers  by:if (n % 2) { // n is odd: F(n) = F(((n-1)/2) + 1)^2 + F((n-1) / 2)^2  unsigned int k = (n - 1) / 2;  return fib(k) * fib(k) + fib(k + 1) * fib(k + 1);} else { // n is even: F(n) = F(n/2) * [ 2 * F(n/2 + 1) - F(n/2) ]  unsigned int k = n / 2;  return fib(k) * [ 2 * fib(k + 1) - fib(k) ];}From above code, we can know that the code stack will be entered again and again,so we need to define when to stop it.if (n == 0) {  return 0; // F(0) = 0.} else if (n &lt;= 2) {  return 1; // F(1) = F(2) = 0.} else {  // Keep call itself recursively to get the answer.  // Put the main body here.}We only calculate Fibonacci numbers from ,so we need to stop when .The fib(0) may be asked from calculating fib(1) = fib(0)*fib(0) + fib(1)*fib(1)(by setting  to ,so we also need to define fib(1) = 1 directly,or it will cause an endless recursion.Similarly, the fib(1) may be asked from calculating fib(2) = fib(1) * [2 * fib(2) - fib(1)](by setting  to ,so fib(2) = 1 also needs to be returned directly.As the result, the code can be written into:///////////////////////////////////////////////////////////////////////////////// Fast doubling: O(log(n))//   Using 2n to the Fibonacci matrix above, we can derive that://     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]//     F(2n+1) = F(n+1)^2 + F(n)^2//     (and F(2n-1) = F(n)^2 + F(n-1)^2)uint64_t fib(unsigned int n){  if (n == 0) {    return 0; // F(0) = 0.  } else if (n &lt;= 2) {    return 1; // F(1) = F(2) = 0.  }  unsigned int k = 0;  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2    k = (n - 1) / 2;    return fib(k) * fib(k) + fib(k + 1) * fib(k + 1);  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    k = n / 2;    return fib(k) * (2 * fib(k + 1) - fib(k));  }}Now, let we look where we could improve from this simple version.We use duplicated fib(k) and fib(k + 1) to calculate fib(n).That is, we will have two duplicated recursive processes to do the same work.It would be a waste of the time.Another trick is that we could use n = n / 2 in both cases( is odd or even) since the result of n = (n - 1) / 2 is sameas n = n / 2 in C/C++’s world if n is an odd integer.Thus, we can rewrite the code into:uint64_t fib(unsigned int n){  if (n == 0) {    return 0; // F(0) = 0.  } else if (n &lt;= 2) {    return 1; // F(1) = F(2) = 1.  }  unsigned int k = n / 2; // k = n/2 if n is even. k = (n-1)/2 if n is odd.  uint64_t a = fib(k);  uint64_t b = fib(k + 1);  if (n % 2) { // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2    return a * a + b * b;  } else { // By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    return a * (2 * b - a);  }}MemoizationDo we save all duplicated task now? No.Suppose we need to find , then we need to get  ….It’s clear that we have a duplicated  on above figure. can return value directly, while  can not.Therefore, the sub-tree(sub-process) whose root is  will be executed twice.The larger the  is, the more duplicated sub-process will be executed.To avoid the waste, we can add an array to save all the calculated value.We check the array first when  is calculated.If there is already a saved value in the array at ,then we can use it directly.Otherwise, it will be calculated as usual.It’s called memoization.We will save  as the  element in the array.In this case, the  is not calculated successively.For example, to get , we only need .We don’t need , so there is no value at the  element in the array.You can use hash map instead of array to avoid the waste of memory.However, retrieving data from array is faster than hash map,so we apply array in our sample code:const unsigned int SIZE = 1000;// 4 is not a fibonacci number, so using it as initialized value.const uint64_t INIT = 4;// In this case, F is not calculated successively. For example,// To get F(6), we only need F(4), F(3), F(2), F(1), F(0) (no F(5)),// so the other elements in F is still INIT.// Another way is to use hash map(std::unordered_map), however,// it will be slower.uint64_t MEM[SIZE] = { [0 ... SIZE-1] = INIT };uint64_t fib(unsigned int n){  if (MEM[n] != INIT) {    return MEM[n];  }  if (n == 0) {    return (MEM[n] = 0); // F(0) = 0.  } else if (n &lt;= 2) {    return (MEM[n] = 1); // F(1) = F(2) = 1.  }  unsigned int k = n / 2; // k = n/2 if n is even. k = (n-1)/2 if n is odd.  uint64_t a = fib(k);  uint64_t b = fib(k + 1);  // By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2, if n is odd.  //    F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ], if n is even.  return (MEM[n] = (n % 2) ? a * a + b * b : a * (2 * b - a));}State vectorAlthough we can speed up the calculating by applying memoization above,the memory consumption with this approach grows with .Is it possible to use a fixed memory no matter how big  is?The answer is yes. Actually, we could just use a two-elements array to do it.From the formula, we can calculate  from .For example, to calculate , we need .To calculate , we need .To calculate , we need .To calculate , we need (so we need to stop here since  is the dead end).However, how do we get when we only have  to calculate ?Or how to get when we only have  to calculate  …?By applying  to formula, we can use  to get .Then we can get .Thus, we are able to get  by the following procedure:Thus, we could keep using two-elements arrayfor to compute what we want and update it step by step.But how to determine the state we should update from , or  ?It’s simple. If  is even, we need to find , where  since .Then we can use to calculate .Otherwise, if  is odd, we need to find , where  since .Then we can use to calculate and then get  by .In summary, the procedure can be organized as follows:                                                                  10      5      2      1      0               is odd             v             v                                                                                                                                                     The last two rows, , are the state vectorthat contains our answer.The first row , is the index of the first elementof the state vector .The second row indicates that whether  is odd or not.If  is odd(recall what we discuss above),then we need to update state from from to  since .The third row is used to record if we need get from .Otherwise, if  is even, updating statefrom  to  directly.From the top-down perspective, to get , we need .To get , we need .To get , we need .To get , we need .We will demonstrate how we do it recursively below.From the bottom-up perspective, we can use to get ,then  to get , to get , to get .We will demonstrate how we do it in iterative section.The recursive approach is easier to understand.By what we summarized above, the simplest implementation will be:// Set f[0], f[1] to F(n), F(n+1).void fib_helper(unsigned int n, uint64_t f[]);// 4 is not a fibonacci number, so using it as initialized value.const uint64_t INIT = 4;uint64_t fib(unsigned int n){  uint64_t f[2] = { INIT, INIT };  fib_helper(n, f);  return f[0];}void fib_helper(unsigned int n, uint64_t f[]){  if (n == 0) {    f[0] = 0; f[1] = 1;    return;  }  unsigned int k = 0;  if (n % 2) {    k = (n - 1) / 2;    fib_helper(k, f);    uint64_t a = f[0];            // F(k) = F((n-1)/2)    uint64_t b = f[1];            // F(k + 1) = F((n- )/2 + 1)    uint64_t c = a * (2 * b - a); // F(n-1) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]    uint64_t d = a * a + b * b;   // F(n) = F(2k + 1) = F(k)^2 + F(k+1)^2    f[0] = d;                     // F(n)    f[1] = c + d;                 // F(n+1) = F(n-1) + F(n)  } else {    k = n / 2;    fib_helper(k, f);    uint64_t a = f[0];            // F(k) = F(n/2)    uint64_t b = f[1];            // F(k + 1) = F(n/2 + 1)    f[0] = a * (2 * b - a);       // F(n) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]    f[1] = a * a + b * b;         // F(n + 1) = F(2k + 1) = F(k)^2 + F(k+1)^2  }}The above fib_helper is quite tedious,we can be simplify it into:// Set f[0], f[1] to F(n), F(n+1).void fib_helper(unsigned int n, uint64_t f[]){  if (!n) {    f[0] = 0;    f[1] = 1;    return;  }  fib_helper(n / 2, f);  // k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.  uint64_t a = f[0]; // F(k)  uint64_t b = f[1]; // F(k+1)  uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]  uint64_t d = a * a + b * b;   // F(2k+1) = F(k+1)^2 + F(k)^2  if (n % 2) {    // k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).    f[0] = d;     // F(n) = F(2k+1).    f[1] = c + d; // F(n+1) = F(n-1) + F(n) = F(2k) + F(2k+1).  } else {        // k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).    f[0] = c;     // F(n) = F(2k).    f[1] = d;     // F(n+1) = F(2k).  }}You could also replace array with std::vector,so the code will looks more elegant.However, it will be slower than using array directly.// Return vector [ F(n), F(n+1) ].std::vector&lt;uint64_t&gt; fib_helper(unsigned int n);uint64_t fib(unsigned int n){  return fib_helper(n)[0];}std::vector&lt;uint64_t&gt; fib_helper(unsigned int n){  if (!n) {    // [F(0), F(1)] = [0 , 1]    return { 0 , 1 };  }  std::vector&lt;uint64_t&gt; f(fib_helper(n / 2));  // k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.  uint64_t a = f[0]; // F(k)  uint64_t b = f[1]; // F(k+1)  uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]  uint64_t d = a * a + b * b;   // F(2k+1) = F(k+1)^2 + F(k)^2  if (n % 2) { // k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).    // [F(n), F(n+1)] = [F(2k+1), F(2k+2)] = [F(2k+1), F(2k) + F(2k+1)]    return { d, c + d };  } else { // k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).    // [F(n), F(n+1)] = [F(2k), F(2k+1)].    return { c, d };  }}Iterative (Bottom-up) ApproachThe recursive approach is implemented from the top-down perspective.We could also do it in bottom-up way.To convert the recursive steps into an iterative loop,we need to find the initialized state and the stop condition.In the recursive approach, no matter what  is, the final state vector(when the recursive steps stops) is always ,, and it must be called from calculating the state [F_1, F_2].Recall how we calculate :  We recursively calculate  from ,          then ,      then ,      then ,      then stop recursive steps when .        Next, we get the state vector  for ,          then return on the same track with opposite directionto calculate the state vector for ,      then for       then for ,      and finally get the answer for .      The recursive steps are used to get the trackfrom  to ,then calculate  for each .To remove the recursive steps, we need to have a way to compute the track.We can use a stack to track the change for , starting push from , then , , , ,then the track can be get from popping them from  to .Thus, the initialized state is and the stop condition is to check whether the stack is empty.(Using stack is one common approach toconvert recursive code into the iterative one.)uint64_t fib(unsigned int n){  // To compute the track from n, n/2, ..., 1, 0.  std::stack&lt;unsigned int&gt; s;  while(n) {    s.push(n);    n /= 2; // n = floor(n/2)  }  s.push(n); // n = 0 now.  uint64_t a; // F(n)  uint64_t b; // F(n+1)  while (!s.empty()) {    unsigned int m = s.top(); s.pop();    if (m == 0) { // Initializing a, b.      a = 0; // F(0) = 0      b = 1; // F(1) = 1      continue;    }    // Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.    // k = m/2, if m is even. k = (m-1)/2, if m is odd.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (m % 2) {  // m = 2k+1:      a = d;      //  F(m) = F(2k+1)      b = c + d;  //  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)    } else {      // m = 2k:      a = c;      //  F(m) = F(2k)      b = d;      //  F(m+1) = F(2k+1)    }  }  return a;}The above code is a bit ugly for simulating the recursive steps like:The initialized state is usually set outside of the loop directly like below:...uint64_t a = 0; // F(0) = 0uint64_t b = 1; // F(1) = 1while (!s.empty()) {  ...}...Since initialized state is set before the loop,we should start the track from  to :std::stack&lt;unsigned int&gt; s;while (n) {  s.push(n);  n /= 2;}// No `s.push(n); // n = 0 now.` here!Therefore, the code will be:uint64_t fib(unsigned int n){  std::stack&lt;unsigned int&gt; s;  while (n) {    s.push(n);    /*n /= 2*/n &gt;&gt;= 1;  }  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  while (!s.empty()) {    unsigned int m = s.top(); s.pop();    // Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.    // k = m/2, if m is even. k = (m-1)/2, if m is odd.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (/*m % 2*/m &amp; 1) { // m = 2k+1:      a = d;              //  F(m) = F(2k+1)      b = c + d;          //  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)    } else {              // m = 2k:      a = c;              //  F(m) = F(2k)      b = d;              //  F(m+1) = F(2k+1)    }  }  return a;}Another trick above is to replace n /= 2 by n &gt;&gt;= 1and m % 2 by m &amp; 1.It will be faster a little bit.Non-stack approachSince applying std::stack will pay for memory allocation,so we should try not using it for better performance.The reason we need the stack is to get the track for each ,where  until .And the track is used to determine what state we should updatefrom , to  or ,by the given  is even or odd.In the above implementation,we put the ,where  denotes is right shifted by  bits(n_j = n &gt;&gt; j)and  is an integer,to the stack, and then iteratively check is odd or even.We could do it without stack!Assume the highest 1-bit in  is the th bit from right side,then the loop will execute  times.(so the time complexity is )Therefore, we could loop  times to calculate from  to .As the result, the code will be:uint64_t fib(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  for (int j = h - 1 ; j &gt;= 0 ; --j) {    // n_j = floor(n / 2^j) = n &gt;&gt; j, k = floor(n_j / 2), (n_j = n when j = 0)    // then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if ((n &gt;&gt; j) &amp; 1) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;            //   F(n_j) = F(2k+1)      b = c + d;        //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k+1)    } else {            // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;            //   F(n_j) = F(2k)      b = d;            //   F(n_j + 1) = F(2k + 1)    }  }  return a;}By Bit-maskDoing AND operation(&amp;) to the last bit of  above is same asdoing AND operation(&amp;) from the highest bit to the lowest bitof the . Thus, we could also rewrite the code into:uint64_t fib(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  // There is only one `1` in the bits of `mask`. The `1`&#39;s position is same as  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right  // iteratively to do `AND` operation with `n` to check `n_j` is odd or even,  // where n_j is defined below.  for (unsigned int mask = 1 &lt;&lt; (h - 1) ; mask ; mask &gt;&gt;= 1) { // Run h times!    // Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &gt;&gt; j    // (n_j = n when j = 0), k = floor(n_j / 2), then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (mask &amp; n) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;        //   F(n_j) = F(2k + 1)      b = c + d;    //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)    } else {        // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;        //   F(n_j) = F(2k)      b = d;        //   F(n_j + 1) = F(2k + 1)    }  }  return a;}All the above code are on gist here.",
    "logo": "http://localhost:4000mountain.png",
    "url": "http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling"
  }
</script>
<!-- End Jekyll SEO tag -->

<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Peak Up" />

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
    crossorigin="anonymous">

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/style.css" />
<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/syntax.css" />


<!--Load Mathjax-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
        MathJax.Hub.Config({
            config: ["MMLorHTML.js"],
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: false
            },
            TeX: {
                TagSide: "right",
                TagIndent: ".8em",
                MultLineWidth: "85%",
                equationNumbers: {
                   autoNumber: "AMS",
                },
                unicode: {
                   fonts: "STIXGeneral,'Arial Unicode MS'"
                }
            },
            showProcessingMessages: false
        });
</script>



<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/favicons/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/favicons/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/favicons/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/favicons/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post-template" itemscope itemtype="http://schema.org/WebPage">

    
<div class="search-wrapper">
    <div class="search-form">
        <input type="text" id="search-input" class="search-field" placeholder="Search...">
        <i id="search-close" class="fa fa-times-circle"></i>
        <h4>Search results</h4>
        <ul id="results-container" class="search-results post-list">
        </ul>
        <!-- /.search-results -->
    </div>
    <!-- /.search-form -->
</div>
<!-- ./search-wrapper -->


<div id="fade"></div>
<a id="slide" class="animated fade">
    <i class="fa fa-bars" aria-hidden="true"></i>
</a>
<aside id="sidebar">
    <nav id="navigation">
        <h2>MENU</h2>
        <hr>
        <ul> 
            <li>
                <a href="http://localhost:4000/"><!-- <i class="fa fa-home"></i>&nbsp;-->Home</a>  </li>
            
            <li>
                <a href="http://localhost:4000/categories"><!-- <i class="fa fa-sitemap"></i>&nbsp;-->Categories</a>  </li>
            
            <li>
                <a href="http://localhost:4000/tags"><!-- <i class="fa fa-tags"></i>&nbsp;-->Tags</a>  </li>
            
            <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
        </ul>
    </nav>
</aside>


<header id="masthead" class="blog-background overlay align-center align-middle animated from-bottom" style="background-image: url(http://localhost:4000/images/background/taiwan_1.jpg)"
    itemscope itemtype="http://schema.org/Organization">



    <button class="menu-button animated fade dosearch">
        <i class="fa fa-search"></i>
    </button>



    <div class="inner">
        <div class="container">
            <a class="brand" href="http://localhost:4000/" itemprop="url">
                <img itemprop="logo" src="http://localhost:4000/images/mountain.png" alt="Peak Up Logo" />
                <h1 class="blog-title light" itemprop="name">
                    Peak Up
                </h1>
            </a>
        </div>
    </div>



    <div class="decor-wrapper">
        <svg id="header-decor" class="decor bottom" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 100 L50 50 L0 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 100 L50 50 L100 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 100 L50 50 L0 66.6" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 100 L50 50 L100 66.6" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>

</header>


    <div id="main" class="content" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
        <div class="container">
            <div class="row">
                <article class="post col-md-8 col-md-offset-2 hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
                
                
                
                

                    <header class="post-header entry-header">

                    

                    
                        <h1 class="post-title text-center hyper lighter bordered-bottom entry-title" itemprop="headline">
                        
                            
                        
                        
                        

                        
                            Calculating Fibonacci Numbers by Fast Doubling
                        </h1>
                    

                        <div class="cursive" style="color: #000; font-style:italic;"></div>

                            <div class="post-info text-center small">
                            
                                <span class="entry-date date published updated">
                            
                            
                                    <time datetime="2017-08-31T00:00:00+08:00" class="post-time" itemprop="datePublished">31 Aug 2017</time>
                                </span>
                            

                                in <span class="post-tags">

                            
                                    <a href="http://localhost:4000/categories/index.html#AlgorithmMath" data-toggle="tooltip" title="Other posts from the Algorithm category" rel="tag">Algorithm</a>
                                
                                    &nbsp;&bull;&nbsp;
                                
                            
                                    <a href="http://localhost:4000/categories/index.html#AlgorithmMath" data-toggle="tooltip" title="Other posts from the Math category" rel="tag">Math</a>
                                
                            
                                </span>
                            
                            &nbsp;
                                <span class="post-tags"><i class="fa fa-clock-o"></i>&nbsp;

                            

                            
                                    <span class="time">19.844444444444445</span> minutes read
                            
                                
                            

                                </span>
                            
                            </div>

                    </header>

                    <div class="post-body bordered-bottom" itemprop="description">
                    

                        <p>In <!-- [previous post](/post/matrix-difference-equation-for-fibonacci-sequence) -->
<a href="https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence">previous post</a>,
we learned how to calculate <em>Fibonacci</em> numbers by <em>Fast Doubling</em> in math.
Today, we will apply it in programming and optimize it step by step.</p>

<h2 id="fast-doubling">Fast Doubling</h2>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
F_{2n+1} &= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]></script>

<p>It’s natural to write a recursive implementation by the above definition.
In the following steps, we will implement recursive versions first,
then try converting it into iterative versions.</p>

<h3 id="recursive-top-down-approach">Recursive (Top-down) Approach</h3>

<p>Given a <script type="math/tex">n</script>, we could calculate <em>Fibonacci</em> numbers <script type="math/tex">F_n</script> by:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n is odd: F(n) = F(((n-1)/2) + 1)^2 + F((n-1) / 2)^2
</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// n is even: F(n) = F(n/2) * [ 2 * F(n/2 + 1) - F(n/2) ]
</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>

<p>From above code, we can know that the code stack will be entered again and again,
so we need to define when to stop it.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0.
</span><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = F(2) = 0.
</span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// Keep call itself recursively to get the answer.
</span>  <span class="c1">// Put the main body here.
</span><span class="p">}</span>
</code></pre>
</div>

<p>We only calculate <em>Fibonacci</em> numbers from <script type="math/tex">0</script>,
so we need to stop when <script type="math/tex">n = 0</script>.
The <code class="highlighter-rouge">fib(0)</code> may be asked from calculating <code class="highlighter-rouge">fib(1) = fib(0)*fib(0) + fib(1)*fib(1)</code>
(by setting <script type="math/tex">n = 0</script> to <script type="math/tex">F_{2n+1} = {F_{n+1}}^2 + {F_n}^2</script>,
so we also need to define <code class="highlighter-rouge">fib(1) = 1</code> directly,
or it will cause an endless recursion.</p>

<p>Similarly, the <code class="highlighter-rouge">fib(1)</code> may be asked from calculating <code class="highlighter-rouge">fib(2) = fib(1) * [2 * fib(2) - fib(1)]</code>
(by setting <script type="math/tex">n = 1</script> to <script type="math/tex">F_{2n} = F_n \cdot (2 \cdot F_{n+1} - F_n)</script>,
so <code class="highlighter-rouge">fib(2) = 1</code> also needs to be returned directly.</p>

<p>As the result, the code can be written into:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////
// Fast doubling: O(log(n))
//   Using 2n to the Fibonacci matrix above, we can derive that:
//     F(2n)   = F(n) * [ 2 * F(n+1) – F(n) ]
//     F(2n+1) = F(n+1)^2 + F(n)^2
//     (and F(2n-1) = F(n)^2 + F(n-1)^2)
</span><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0.
</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = F(2) = 0.
</span>  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
</span>    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>    <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Now, let we look where we could improve from this simple version.
We use duplicated <code class="highlighter-rouge">fib(k)</code> and <code class="highlighter-rouge">fib(k + 1)</code> to calculate <code class="highlighter-rouge">fib(n)</code>.
That is, we will have two duplicated recursive processes to do the same work.
It would be a waste of the time.</p>

<p>Another trick is that we could use <code class="highlighter-rouge">n = n / 2</code> in both cases
(<script type="math/tex">n</script> is odd or even) since the result of <code class="highlighter-rouge">n = (n - 1) / 2</code> is same
as <code class="highlighter-rouge">n = n / 2</code> in <em>C/C++</em>’s world if <code class="highlighter-rouge">n</code> is an <strong>odd</strong> integer.</p>

<p>Thus, we can rewrite the code into:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0.
</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = F(2) = 1.
</span>  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// k = n/2 if n is even. k = (n-1)/2 if n is odd.
</span>  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2
</span>    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// By F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="memoization">Memoization</h4>

<p>Do we save all duplicated task now? No.
Suppose we need to find <script type="math/tex">F_6</script>, then we need to get <script type="math/tex">F_3, F_4</script> ….</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{matrix}
 & & & & & 6 & & & & & & & \\
 & & & & \diagup & & \diagdown & & & & & & \\
 & & & \diagup & & & & \diagdown & & & & & \\
 & & 3 & & & & & & 4 & & & & \\
 & \diagup & & \diagdown & & & & \diagup & & \diagdown & & & \\
 1 & & & & 2 & & 2 & & & & 3 & & \\
 & & & & & & & & & \diagup & & \diagdown & \\
 & & & & & & & & 1 & & & & 2
\end{matrix} %]]></script>

<p>It’s clear that we have a duplicated <script type="math/tex">F_1, F_2, F_3</script> on above figure.
<script type="math/tex">F_1, F_2</script> can return value directly, while <script type="math/tex">F_3</script> can not.
Therefore, the sub-tree(sub-process) whose root is <script type="math/tex">F_3</script> will be executed twice.</p>

<p>The larger the <script type="math/tex">n</script> is, the more duplicated sub-process will be executed.
To avoid the waste, we can add an <em>array</em> to save all the calculated value.
We check the <em>array</em> first when <script type="math/tex">F_n</script> is calculated.
If there is already a saved value in the <em>array</em> at <script type="math/tex">n</script>,
then we can use it directly.
Otherwise, it will be calculated as usual.
It’s called <em>memoization</em>.
We will save <script type="math/tex">F_n</script> as the <script type="math/tex">n</script> element in the <em>array</em>.</p>

<p>In this case, the <script type="math/tex">F_n</script> is not calculated successively.
For example, to get <script type="math/tex">F_6</script>, we only need <script type="math/tex">F_4, F_3, F_2, F_1, F_0</script>.
We don’t need <script type="math/tex">F_5</script>, so there is no value at the <script type="math/tex">5</script> element in the <em>array</em>.
You can use <em>hash map</em> instead of <em>array</em> to avoid the waste of memory.
However, retrieving data from <em>array</em> is faster than <em>hash map</em>,
so we apply <em>array</em> in our sample code:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="c1">// 4 is not a fibonacci number, so using it as initialized value.
</span><span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">INIT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">// In this case, F is not calculated successively. For example,
// To get F(6), we only need F(4), F(3), F(2), F(1), F(0) (no F(5)),
// so the other elements in F is still INIT.
// Another way is to use hash map(std::unordered_map), however,
// it will be slower.
</span><span class="kt">uint64_t</span> <span class="n">MEM</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INIT</span> <span class="p">};</span>
<span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INIT</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// F(0) = 0.
</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// F(1) = F(2) = 1.
</span>  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// k = n/2 if n is even. k = (n-1)/2 if n is odd.
</span>  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// By F(n) = F(2k+1) = F(k+1)^2 + F(k)^2, if n is odd.
</span>  <span class="c1">//    F(n) = F(2k) = F(k) * [ 2 * F(k+1) – F(k) ], if n is even.
</span>  <span class="k">return</span> <span class="p">(</span><span class="n">MEM</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">:</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">));</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="state-vector">State vector</h4>
<p>Although we can speed up the calculating by applying <em>memoization</em> above,
the memory consumption with this approach grows with <script type="math/tex">n</script>.
Is it possible to use a fixed memory no matter how big <script type="math/tex">n</script> is?
The answer is yes. Actually, we could just use a two-elements array to do it.</p>

<p>From the formula, we can calculate <script type="math/tex">[F_{2n}, F_{2n+1}]</script> from <script type="math/tex">[F_n, F_{n+1}]</script>.
For example, to calculate <script type="math/tex">F_{10}</script>, we need <script type="math/tex">F_5, F_6</script>.
To calculate <script type="math/tex">F_5</script>, we need <script type="math/tex">F_2, F_3</script>.
To calculate <script type="math/tex">F_2</script>, we need <script type="math/tex">F_1, F_0</script>.
To calculate <script type="math/tex">F_1</script>, we need <script type="math/tex">F_0, F_1</script>
(so we need to stop here since <script type="math/tex">F_1</script> is the dead end).</p>

<p>However, how do we get <script type="math/tex">F_6</script>
when we only have <script type="math/tex">F_2, F_3</script> to calculate <script type="math/tex">F_5</script>?
Or how to get <script type="math/tex">F_3</script>
when we only have <script type="math/tex">F_0, F_1</script> to calculate <script type="math/tex">F_2</script> …?</p>

<p>By applying <script type="math/tex">n = 2</script> to formula, we can use <script type="math/tex">F_2, F_3</script> to get <script type="math/tex">F_4, F_5</script>.
Then we can get <script type="math/tex">F_6 = F_4 + F_5</script>.</p>

<p>Thus, we are able to get <script type="math/tex">F_{10}</script> by the following procedure:</p>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    F_0 \\
    F_1
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}</script>

<p>Thus, we could keep using two-elements array
for <script type="math/tex">\begin{bmatrix} F_n \\ F_{n+1} \end{bmatrix}</script>
to compute what we want and update it step by step.</p>

<p>But how to determine the state we should update from <script type="math/tex">[F_n, F_{n + 1}]</script>,
<script type="math/tex">[F_{2n}, F_{2n + 1}]</script> or <script type="math/tex">[F_{2n + 1}, F_{2n + 2}]</script> ?</p>

<p>It’s simple. If <script type="math/tex">n</script> is even, we need to find <script type="math/tex">F_k</script>
, where <script type="math/tex">k = \frac{n}{2}</script> since <script type="math/tex">n = 2x</script>.
Then we can use <script type="math/tex">[F_k, F_{k+1}] = [F_{n/2}, F_{n/2 + 1}]</script>
to calculate <script type="math/tex">[F_{2k}, F_{2k + 1}] = [F_n, F_{n + 1}]</script>.</p>

<p>Otherwise, if <script type="math/tex">n</script> is odd, we need to find <script type="math/tex">F_k</script>
, where <script type="math/tex">k = \frac{n-1}{2}</script> since <script type="math/tex">n = 2k + 1</script>.
Then we can use <script type="math/tex">[F_k, F_{k+1}] = [F_{(n-1)/2}, F_{(n-1)/2 + 1}]</script>
to calculate <script type="math/tex">[F_{2k}, F_{2k+1}] = [F_{n-1}, F_n]</script>
and then get <script type="math/tex">[F_n, F_{n + 1}]</script> by <script type="math/tex">[F_n, F_{n-1} + F_n]</script>.</p>

<p>In summary, the procedure can be organized as follows:</p>

<table>
  <thead>
    <tr>
      <th><script type="math/tex">k_i</script></th>
      <th><script type="math/tex">k_1</script></th>
      <th><script type="math/tex">k_2</script></th>
      <th><script type="math/tex">k_3</script></th>
      <th><script type="math/tex">k_4</script></th>
      <th><script type="math/tex">k_5</script></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><script type="math/tex">n(= k_i)</script></td>
      <td>10</td>
      <td>5</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td><script type="math/tex">n</script> is odd</td>
      <td> </td>
      <td>v</td>
      <td> </td>
      <td>v</td>
      <td> </td>
    </tr>
    <tr>
      <td><script type="math/tex">F_{2k_{i+1}}</script></td>
      <td> </td>
      <td><script type="math/tex">F_4</script></td>
      <td> </td>
      <td><script type="math/tex">F_0</script></td>
      <td> </td>
    </tr>
    <tr>
      <td><script type="math/tex">F_n</script></td>
      <td><script type="math/tex">F_{10}</script></td>
      <td><script type="math/tex">F_5</script></td>
      <td><script type="math/tex">F_2</script></td>
      <td><script type="math/tex">F_1</script></td>
      <td><script type="math/tex">F_0</script></td>
    </tr>
    <tr>
      <td><script type="math/tex">F_{n+1}</script></td>
      <td> </td>
      <td><script type="math/tex">F_6</script></td>
      <td><script type="math/tex">F_3</script></td>
      <td><script type="math/tex">F_2</script></td>
      <td><script type="math/tex">F_1</script></td>
    </tr>
  </tbody>
</table>

<p>The last two rows, <script type="math/tex">F_n, F_{n+1}(= F_{k_i}, F_{k_i+1})</script>, are the state vector
that contains our answer.</p>

<p>The first row <script type="math/tex">n</script>, is the index of the first element
of the state vector <script type="math/tex">F_n</script>.
The second row indicates that whether <script type="math/tex">n</script> is odd or not.
If <script type="math/tex">n(= k_i)</script> is odd(recall what we discuss above),
then we need to update state from from <script type="math/tex">[F_{k_{i+1}}, F_{k_{i+1}+1}]</script>
to <script type="math/tex">[F_{2k_i + 1}, F_{2k_i + 2}]</script> since <script type="math/tex">k_{i+1} = \frac{k_i - 1}{2}</script>.
The third row is used to record if we need get <script type="math/tex">[F_{2k_i + 1}, F_{2k_i + 2}]</script>
from <script type="math/tex">[F_{2k_i}, F_{2k_i + 1}]</script>.
Otherwise, if <script type="math/tex">n(= k_i)</script> is even, updating state
from <script type="math/tex">[F_{k_{i+1}}, F_{k_{i+1}+1}]</script> to <script type="math/tex">[F_{2k_i}, F_{2k_i + 1}]</script> directly.</p>

<p>From the top-down perspective, to get <script type="math/tex">F_{10}</script>, we need <script type="math/tex">F_5, F_6</script>.
To get <script type="math/tex">F_5, F_6</script>, we need <script type="math/tex">F_2, F_3</script>.
To get <script type="math/tex">F_2, F_3</script>, we need <script type="math/tex">F_1, F_2</script>.
To get <script type="math/tex">F_1, F_2</script>, we need <script type="math/tex">F_0, F_1</script>.
We will demonstrate how we do it recursively below.</p>

<p>From the bottom-up perspective, we can use <script type="math/tex">F_0, F_1</script>
to get <script type="math/tex">F_0, F_1, F_2</script>,
then <script type="math/tex">F_1, F_2</script> to get <script type="math/tex">F_2, F_3</script>,
<script type="math/tex">F_2, F_3</script> to get <script type="math/tex">F_4, F_5, F_6</script>,
<script type="math/tex">F_5, F_6</script> to get <script type="math/tex">F_10</script>.
We will demonstrate how we do it in iterative section.</p>

<p>The recursive approach is easier to understand.
By what we summarized above, the simplest implementation will be:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Set f[0], f[1] to F(n), F(n+1).
</span><span class="kt">void</span> <span class="n">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">f</span><span class="p">[]);</span>

<span class="c1">// 4 is not a fibonacci number, so using it as initialized value.
</span><span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">INIT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">INIT</span><span class="p">,</span> <span class="n">INIT</span> <span class="p">};</span>
  <span class="n">fib_helper</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">f</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">fib_helper</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>            <span class="c1">// F(k) = F((n-1)/2)
</span>    <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>            <span class="c1">// F(k + 1) = F((n- )/2 + 1)
</span>    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(n-1) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]
</span>    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(n) = F(2k + 1) = F(k)^2 + F(k+1)^2
</span>    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>                     <span class="c1">// F(n)
</span>    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>                 <span class="c1">// F(n+1) = F(n-1) + F(n)
</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">fib_helper</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>            <span class="c1">// F(k) = F(n/2)
</span>    <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>            <span class="c1">// F(k + 1) = F(n/2 + 1)
</span>    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>       <span class="c1">// F(n) = F(2k) = F(k) * [2 * F(k + 1) - F(k)]
</span>    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>         <span class="c1">// F(n + 1) = F(2k + 1) = F(k)^2 + F(k+1)^2
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The above <code class="highlighter-rouge">fib_helper</code> is quite tedious,
we can be simplify it into:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Set f[0], f[1] to F(n), F(n+1).
</span><span class="kt">void</span> <span class="nf">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">f</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">fib_helper</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="c1">// k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.
</span>  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// F(k)
</span>  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// F(k+1)
</span>
  <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>  <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k+1)^2 + F(k)^2
</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).
</span>    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// F(n) = F(2k+1).
</span>    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// F(n+1) = F(n-1) + F(n) = F(2k) + F(2k+1).
</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        <span class="c1">// k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).
</span>    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>     <span class="c1">// F(n) = F(2k).
</span>    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// F(n+1) = F(2k).
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>You could also replace <em>array</em> with <em>std::vector</em>,
so the code will looks more elegant.
However, it will be slower than using <em>array</em> directly.</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Return vector [ F(n), F(n+1) ].
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">fib_helper</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">fib_helper</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// [F(0), F(1)] = [0 , 1]
</span>    <span class="k">return</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">fib_helper</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
  <span class="c1">// k = floor(n/2), so k = n / 2 if n is even, k = (n - 1) / 2 if n is odd.
</span>  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// F(k)
</span>  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// F(k+1)
</span>
  <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>  <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k+1)^2 + F(k)^2
</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// k = (n - 1) / 2, so F(2k) = F(n-1), F(2k+1) = F(n).
</span>    <span class="c1">// [F(n), F(n+1)] = [F(2k+1), F(2k+2)] = [F(2k+1), F(2k) + F(2k+1)]
</span>    <span class="k">return</span> <span class="p">{</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span> <span class="p">};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// k = n / 2, so F(2k) = F(n), F(2k+1) = F(n+1).
</span>    <span class="c1">// [F(n), F(n+1)] = [F(2k), F(2k+1)].
</span>    <span class="k">return</span> <span class="p">{</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="iterative-bottom-up-approach">Iterative (Bottom-up) Approach</h3>

<p>The recursive approach is implemented from the top-down perspective.
We could also do it in bottom-up way.</p>

<p>To convert the recursive steps into an iterative loop,
we need to find the <em>initialized state</em> and the <em>stop condition</em>.
In the recursive approach, no matter what <script type="math/tex">n</script> is, the final state vector
(when the recursive steps stops) is always <script type="math/tex">[F_0, F_1]</script>,
, and it must be called from calculating the state <script type="math/tex"></script>[F_1, F_2]<script type="math/tex"></script>.
Recall how we calculate <script type="math/tex">F_{10}</script>:</p>

<ul>
  <li>We recursively calculate <script type="math/tex">n \leftarrow \lfloor \frac{n}{2} \rfloor</script> from <script type="math/tex">n = 10</script>,
    <ul>
      <li>then <script type="math/tex">n = \lfloor \frac{10}{2} \rfloor = 5</script>,</li>
      <li>then <script type="math/tex">n = \lfloor \frac{5}{2} \rfloor = 2</script>,</li>
      <li>then <script type="math/tex">n = \lfloor \frac{2}{2} \rfloor = 1</script>,</li>
      <li>then stop recursive steps when <script type="math/tex">n = \lfloor \frac{1}{2} \rfloor = 0</script>.</li>
    </ul>
  </li>
  <li>Next, we get the state vector <script type="math/tex">[F_n, F_{n+1}]</script> for <script type="math/tex">n = 0</script>,
    <ul>
      <li>then return on the same track with opposite direction
to calculate the state vector for <script type="math/tex">n = 1</script>,</li>
      <li>then for <script type="math/tex">n = 2</script></li>
      <li>then for <script type="math/tex">n = 5</script>,</li>
      <li>and finally get the answer for <script type="math/tex">n = 10</script>.</li>
    </ul>
  </li>
</ul>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    F_0 \\
    F_1
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}</script>

<p>The recursive steps are used to get the track
from <script type="math/tex">n = 0</script> to <script type="math/tex">1, 2, 5, 10</script>,
then calculate <script type="math/tex">[F_n, F_{n+1}]</script> for each <script type="math/tex">n</script>.</p>

<p>To remove the recursive steps, we need to have a way to compute the track.
We can use a <em>stack</em> to track the change for <script type="math/tex">n</script>, starting push <script type="math/tex">n</script>
from <script type="math/tex">n = 10</script>, then <script type="math/tex">n = 5</script>, <script type="math/tex">n = 2</script>, <script type="math/tex">n = 1</script>, <script type="math/tex">n = 0</script>,
then the track can be get from popping them from <script type="math/tex">0</script> to <script type="math/tex">10</script>.</p>

<p>Thus, the <em>initialized state</em> is <script type="math/tex">n = 0</script>
and the <em>stop condition</em> is to check whether the stack is empty.</p>

<p>(Using <em>stack</em> is one common approach to
convert recursive code into the iterative one.)</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// To compute the track from n, n/2, ..., 1, 0.
</span>  <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// n = floor(n/2)
</span>  <span class="p">}</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// n = 0 now.
</span>
  <span class="kt">uint64_t</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// F(n)
</span>  <span class="kt">uint64_t</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// F(n+1)
</span>  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Initializing a, b.
</span>      <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0
</span>      <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1
</span>      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.
</span>    <span class="c1">// k = m/2, if m is even. k = (m-1)/2, if m is odd.
</span>    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// m = 2k+1:
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>      <span class="c1">//  F(m) = F(2k+1)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>  <span class="c1">//  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>      <span class="c1">// m = 2k:
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>      <span class="c1">//  F(m) = F(2k)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>      <span class="c1">//  F(m+1) = F(2k+1)
</span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The above code is a bit ugly for simulating the recursive steps like:
<script type="math/tex">\require{AMScd}
\underbrace{
\begin{CD}
\left(
  \begin{array}{c}
    \boldsymbol{a} = F_0 \\
    \boldsymbol{b} = F_1
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}
}_{loop}</script></p>

<p>The <em>initialized state</em> is usually set outside of the loop directly like below:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="p">...</span>
<span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0
</span><span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1
</span><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre>
</div>

<script type="math/tex; mode=display">\require{AMScd}
\begin{CD}
\left(
  \begin{array}{c}
    \boldsymbol{a} = F_0 \\
    \boldsymbol{b} = F_1
  \end{array}
\right)
\end{CD}
\underbrace{
\begin{CD}
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_1 \\
    F_2
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_2 \\
    F_3
  \end{array}
\right)
@>{2n+1, 2n+2}>>
\left(
  \begin{array}{c}
    F_5 \\
    F_6
  \end{array}
\right)
@>{2n, 2n+1}>>
\left(
  \begin{array}{c}
    F_{10} \\
    F_{11}
  \end{array}
\right)
\end{CD}
}_{loop}</script>

<p>Since <em>initialized state</em> is set before the loop,
we should start the track from <script type="math/tex">n = 1</script> to <script type="math/tex">2, 5, 10</script>:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// No `s.push(n); // n = 0 now.` here!
</span></code></pre>
</div>

<p>Therefore, the code will be:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="cm">/*n /= 2*/</span><span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0
</span>  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1
</span>  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="c1">// Let k = floor(m/2), so `a` is F(k) and `b` is F(k+1) now.
</span>    <span class="c1">// k = m/2, if m is even. k = (m-1)/2, if m is odd.
</span>    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2
</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/*m % 2*/</span><span class="n">m</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// m = 2k+1:
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>              <span class="c1">//  F(m) = F(2k+1)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>          <span class="c1">//  F(m+1) = F(m) + F(m-1) = F(2k+1) + F(2k)
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>              <span class="c1">// m = 2k:
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>              <span class="c1">//  F(m) = F(2k)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>              <span class="c1">//  F(m+1) = F(2k+1)
</span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Another trick above is to replace <code class="highlighter-rouge">n /= 2</code> by <code class="highlighter-rouge">n &gt;&gt;= 1</code>
and <code class="highlighter-rouge">m % 2</code> by <code class="highlighter-rouge">m &amp; 1</code>.
It will be faster a little bit.</p>

<h4 id="non-stack-approach">Non-stack approach</h4>
<p>Since applying <code class="highlighter-rouge">std::stack</code> will pay for memory allocation,
so we should try not using it for better performance.</p>

<p>The reason we need the <em>stack</em> is to get the <strong>track for each <script type="math/tex">n</script></strong>,
where <script type="math/tex">n \leftarrow \lfloor \frac{n}{2} \rfloor</script> until <script type="math/tex">n = 1</script>.
And the track is used to determine what state we should update
from <script type="math/tex">[F_n, F_{n+1}]</script>, to <script type="math/tex">[F_{2n}, F_{2n+1}]</script> or <script type="math/tex">[F_{2n+1}, F_{2n+2}]</script>,
by the given <script type="math/tex">n</script> is <strong>even or odd</strong>.</p>

<p>In the above implementation,
we put the <script type="math/tex">n_0 = n, n_1, n_2, ..., n_j, ..., n_{t-1}, n_t = 1</script>,
where <script type="math/tex">n_j = \lfloor \frac{n}{2^j} \rfloor</script> denotes
<script type="math/tex">n</script> is right shifted by <script type="math/tex">j</script> bits(<code class="highlighter-rouge">n_j = n &gt;&gt; j</code>)
and <script type="math/tex">j \geq 1</script> is an integer,
to the <em>stack</em>, and then iteratively check <script type="math/tex">n_t = 1, n_{t-1}, ..., n_2, n_1, n_0 = n</script>
is odd or even.
We could do it without <em>stack</em>!
Assume the <strong>highest</strong> 1-bit in <script type="math/tex">n</script> is the <script type="math/tex">h</script>th bit from right side,
then the loop will execute <script type="math/tex">h = t + 1 = \log_2 n + 1</script> times.
(so the time complexity is <script type="math/tex">O(\log n)</script>)
Therefore, we could loop <script type="math/tex">h</script> times to calculate <script type="math/tex">F_{n_j}</script>
from <script type="math/tex">j = t = h-1</script> to <script type="math/tex">j = 0</script>.
As the result, the code will be:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The position of the highest bit of n.
</span>  <span class="c1">// So we need to loop `h` times to get the answer.
</span>  <span class="c1">// Example: n = (Dec)50 = (Bin)00110010, then h = 6.
</span>  <span class="c1">//                               ^ 6th bit from right side
</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">++</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0
</span>  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// n_j = floor(n / 2^j) = n &gt;&gt; j, k = floor(n_j / 2), (n_j = n when j = 0)
</span>    <span class="c1">// then a = F(k), b = F(k+1) now.
</span>    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2
</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>            <span class="c1">//   F(n_j) = F(2k+1)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k+1)
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>            <span class="c1">// n_j is even: k = n_j/2 =&gt; n_j = 2k
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>            <span class="c1">//   F(n_j) = F(2k)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>            <span class="c1">//   F(n_j + 1) = F(2k + 1)
</span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h5 id="by-bit-mask">By Bit-mask</h5>
<p>Doing <em>AND</em> operation(<code class="highlighter-rouge">&amp;</code>) to the last bit of <script type="math/tex">n_j</script> above is same as
doing <em>AND</em> operation(<code class="highlighter-rouge">&amp;</code>) <strong>from the highest bit to the lowest bit</strong>
of the <script type="math/tex">n</script>. Thus, we could also rewrite the code into:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The position of the highest bit of n.
</span>  <span class="c1">// So we need to loop `h` times to get the answer.
</span>  <span class="c1">// Example: n = (Dec)50 = (Bin)00110010, then h = 6.
</span>  <span class="c1">//                               ^ 6th bit from right side
</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">++</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0
</span>  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1
</span>  <span class="c1">// There is only one `1` in the bits of `mask`. The `1`'s position is same as
</span>  <span class="c1">// the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right
</span>  <span class="c1">// iteratively to do `AND` operation with `n` to check `n_j` is odd or even,
</span>  <span class="c1">// where n_j is defined below.
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="n">mask</span> <span class="p">;</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Run h times!
</span>    <span class="c1">// Let j = h-i (looping from i = 1 to i = h), n_j = floor(n / 2^j) = n &gt;&gt; j
</span>    <span class="c1">// (n_j = n when j = 0), k = floor(n_j / 2), then a = F(k), b = F(k+1) now.
</span>    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j) = F(2k + 1)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        <span class="c1">// n_j is even: k = n_j/2 =&gt; n_j = 2k
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>        <span class="c1">//   F(n_j) = F(2k)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j + 1) = F(2k + 1)
</span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>All the above code are on <a href="https://gist.github.com/ChunMinChang/f80ef4decca23b88df16f2f7846049b6" title="Calculating Fibonacci Numbers by Fast Doubling">gist here</a>.</p>



                        <br>

                    
                    
                        <div class="entry-tags text-center">
                            <i class="fa fa-tags"></i>&nbsp;
                                Tagged with 
                            
                                <a href="http://localhost:4000/tags/index.html#Fibonacci" data-toggle="tooltip" title="Posts tagged with Fibonacci" rel="tag">Fibonacci</a>

                                
                            
                        </div>
                    
                    </div>

                    <footer class="post-footer entry-meta">
                    
                        <div class="post-share text-center">
    <p class="light small">
        Share this post
    </p>
    <ul class="social-mini">
        <li>
            <a href="https://twitter.com/intent/tweet?text=Calculating+Fibonacci+Numbers+by+Fast+Doubling%20http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling%20via%20&#64;"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" data-toggle="tooltip"
                title="Share on Twitter" itemprop="Twitter">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"
                data-toggle="tooltip" title="Share on Facebook" itemprop="Facebook">
                <i class="fa fa-facebook"></i>
            </a>
        </li>
        <li>
            <a href="https://plus.google.com/share?url=http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;"
                data-toggle="tooltip" title="Share on Google plus" itemprop="GooglePlus">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
    </ul>
</div>
                    

                        <div class="post-author text-center">
	<img src="http://localhost:4000/images/chunmin.jpg" alt="Chun-Min Chang's photo" itemprop="image" class="post-avatar img-circle img-responsive" />
	<h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="http://schema.org/Person">
		By <span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About Chun-Min Chang" itemprop="url">Chun-Min Chang</a></span>
	</h4>
	<p>I am a self-directed learner and a maker who enjoys building products from original ideas.</p>
</div> 
                        
                    
                        <div id="disqus_thread"></div><!-- /#disqus_thread -->
                    
                    </footer>

                </article>
            </div>
        </div>
    </div>

    
<footer id="footer" class="blog-background overlay text-center align-middle animated from-top" style="background-image: url(http://localhost:4000/images/background/taiwan_1.jpg)">


    <div class="inner">
        <div class="container">
            <ul class="social-icons">
                    
                <li>
                    <a href="https://www.linkedin.com/in/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on LinkedIn" target="_blank">
                        <i class="fa fa-linkedin"></i>
                    </a>
                </li>
                   
                <li>
                    <a href="http://github.com/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on Github" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </li>
                
            </ul>
            <div>
                <a href="http://localhost:4000/about/">Chun-Min Chang</a> &copy; 2017 &bull;
                All rights reserved.
            </div>
            <ul class="menu-items">
                
                <li>
                    
                    <a href="http://localhost:4000/"><i class="fa fa-home"></i>&nbsp;Home</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/categories"><i class="fa fa-sitemap"></i>&nbsp;Categories</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/tags"><i class="fa fa-tags"></i>&nbsp;Tags</a>&nbsp;&bull;
                    
                </li>
                
                <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
            </ul>
        </div>
    </div>

    
    <div class="decor-wrapper">
        <svg id="footer-decor" class="decor top" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 0 L50 50 L0 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 0 L50 50 L100 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 0 L50 50 L0 33.3" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 0 L50 50 L100 33.3" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>
    

</footer>


    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ="
  crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.12.4.min.js"><\/script>')</script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
  crossorigin="anonymous"></script>

<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jekyll-search.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.fitvids.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.waypoints.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/main.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/script.js"></script>
<script type='text/javascript'>$(document).ready(function(){$(".time").text(function(a,b){return Math.round(parseFloat(b))})});</script>

<script type="text/javascript">

/*      Slides       */

$("a#slide").click(function(){
    $("#sidebar,body,a#slide,#fade").addClass("slide")
});

$("#fade,#header,#posts-container").click(function(){
    $("#sidebar,body,a#slide,#fade").removeClass("slide")
});

$("a#click-filter").click(function(){
    $("#slide-filter").slideToggle("medium");
    $("#slide-pages").slideOut("medium");
});

$("a#click-pages").click(function(){
    $("#slide-pages").slideToggle("medium");
    $("#slide-filter").slideOut("medium");
});

/*      End-Slides      */

</script>


<!-- Jekyll Simple Search option -->
<script>

   SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: 'http://localhost:4000/assets/json/search.json',
        searchResultTemplate: '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
        noResultsText: '<p>Nothing found.</p>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $("#search-close"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


 


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'chunminchang-blog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        
</body>
</html>
