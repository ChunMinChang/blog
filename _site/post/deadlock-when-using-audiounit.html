<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">


<meta name="keywords" content="CoreAudio">


<!-- Begin Jekyll SEO tag v1.3.3 -->
<title>Deadlock when using AudioUnit - Peak Up</title>
<meta property="og:title" content="Deadlock when using AudioUnit" />
<meta name="description" content="There was a deadlock occured when we tried to integrate my implementationfor audio 5.1 into Firefox.You can see the bug here.It only happens on OSX.After analysis,I wrote a test to prevent others from getting into the same problem.The test is added to cubeb,which is our cross-platform audio library for Firefox.We reproduced a simpler version of the deadlock)in the test.However, the code is not easy enough for those who are not familir with cubeb,so I wrote a general version to highlight the issue toeveryone who uses AudioUnit in their audio backend.You can find the code on gist here// Deadlock//// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held// by another thread, without releasing mutex_AU, then it will cause a// deadlock when another thread holding the mutex M requests to use AudioUnit.//// The following figure illustrates the deadlock described above:////    (Thread A)     holds//  data_callback &lt;---------- mutext_AudioUnit(mutex_AU)//      |                            ^//      |                            |//      | request                    | request//      |                            |//      v           holds            |//   mutex_M -------------------&gt; Thread B#include &lt;assert.h&gt;               // for assert#include &lt;pthread.h&gt;              // for pthread#include &lt;signal.h&gt;               // for signal#include &lt;unistd.h&gt;               // for sleep, usleep#include &quot;AudioStream.h&quot;          // for AudioStream#include &quot;utils.h&quot;                // for LOG#include &quot;OwnedCriticalSection.h&quot; // for OwnedCriticalSection// The signal alias for calling our thread killer.#define CALL_THREAD_KILLER SIGUSR1const unsigned int kFequency = 44100;const unsigned int kChannels = 2;// If we apply ERRORCHECK mode, then we can&#39;t unlock a mutex locked by a// different thread.// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);OwnedCriticalSection gMutex;using locker = std::lock_guard&lt;OwnedCriticalSection&gt;;// Indicating whether the test is passed.bool gPass = false;// Indicating whether the data callback is fired.bool gCalled = false;// Indicating whether the data callback is running.bool gCalling = false;// Indicating whether the assigned task is done.bool gTaskDone = false;// Indicating whether our pending task thread is killed by ourselves.bool gKilled = false;void killer(int aSignal){  assert(aSignal == CALL_THREAD_KILLER);  LOG(&quot;pending task thread is killed!\n&quot;);  gKilled = true;}uint64_t getThreadId(pthread_t aThread = NULL){  uint64_t tid;  // tid will be current thread id if aThread is null.  pthread_threadid_np(aThread, &amp;tid);  return tid;}// The output callback fired from audio rendering mechanism, which is on// out-of-main thread.void callback(void* aBuffer, unsigned long aFrames){  // The callback thread holds a mutex shared with AudioUnit.  gCalling = true;  uint64_t id = getThreadId();  !gCalled &amp;&amp; LOG(&quot;Output callback is on thread %llu, holding mutex_AU\n&quot;, id);  gCalled = true;  if (!gTaskDone) {    // Force to switch threads by sleeping 10 ms. Notice that anything over    // 10ms would produce a glitch. It&#39;s intended for testing deadlock,    // so we ignore the fault here.    LOG(&quot;[%llu] Force to switch threads\n&quot;, id);    usleep(10000);  }  LOG(&quot;[%llu] Try getting another mutex: gMutex...\n&quot;, id);  locker guard(gMutex);  LOG(&quot;[%llu] Got mutex finally!\n&quot;, id);  gCalling = false;}void* task(void*){  // Hold the mutex.  locker guard(gMutex);  uint64_t id = getThreadId();  LOG(&quot;Task thread: %llu, holding gMutex, is created\n&quot;, id);  while(!gCalling) {    LOG(&quot;[%llu] waiting for output callback before running task\n&quot;, id);    usleep(1000); // Force to switch threads by sleeping 1 ms.  }  // Creating another AudioUnit when we already one will cause a deadlock!  LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&quot;, id);  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);  LOG(&quot;[%llu] Another AudioUnit is created!\n&quot;, id);  gTaskDone = true;  return NULL;}// We provide one possible solution here:// void* task(void*)// {//   uint64_t id = getThreadId();//   LOG(&quot;Task thread: %llu is created\n&quot;, id);////   while(!gCalling) {//     LOG(&quot;[%llu] waiting for output callback before running task\n&quot;, id);//     usleep(1000); // Force to switch threads by sleeping 1 ms.//   }////   // Creating another AudioUnit when we already one will cause a deadlock!//   LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&quot;, id);//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);////   LOG(&quot;[%llu] Another AudioUnit is created!\n&quot;, id);////   // Hold the mutex.//   LOG(&quot;[%llu] Try getting another mutex: gMutex...\n&quot;, id);//   locker guard(gMutex);////   LOG(&quot;[%llu] Got mutex finally!\n&quot;, id);////   gTaskDone = true;////   return NULL;// }void* watchdog(void* aSubject){  uint64_t id = getThreadId();  pthread_t subject = *((pthread_t *) aSubject);  uint64_t sid = getThreadId(subject);  LOG(&quot;Monitor thread %llu on thread %llu\n&quot;, sid, id);  unsigned int sec = 1;  LOG(&quot;[%llu] sleep %d seconds before checking task for thread %llu\n&quot;, id, sec, sid);  sleep(sec); // Force to switch threads.  if (!gTaskDone) {    LOG(&quot;[%llu] Kill the task thread %llu!\n&quot;, id, sid);    assert(!pthread_kill(subject, CALL_THREAD_KILLER));    assert(!pthread_detach(subject));    // The mutex held by the killed thread(subject) won&#39;t be released,    // so we need unlock it manually. Notice that we can&#39;t unlock a mutex held    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.    gMutex.unlock();  }  LOG(&quot;\n[%llu] Task is %sdone\n\n&quot;, id, gTaskDone ? &quot;&quot;: &quot;NOT &quot;);  gPass = gTaskDone;  return NULL;}int main(){  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);  // Install signal handler.  signal(CALL_THREAD_KILLER, killer);  pthread_t subject, detector;  pthread_create(&amp;subject, NULL, task, NULL);  pthread_create(&amp;detector, NULL, watchdog, (void *) &amp;subject);  as.Start();  pthread_join(subject, NULL);  pthread_join(detector, NULL);  as.Stop();  // If the callback is never fired, then the task must not be done.  // There is no to keep checking in this case.  assert(gCalled &amp;&amp; &quot;Callback should be fired!&quot;);  // The task thread might keep running after the deadlock is freed, so we use  // gPass instead of gTaskDone.  assert(gPass &amp;&amp; &quot;Deadlock detected!&quot;);  // False gPass implies there is a deadlock detected, so we need to kill the  // pending task thread to free the deadlock and set gKilled to true.  // True gPass means there is no deadlock and no need to kill any thread.  assert(gPass != gKilled &amp;&amp; &quot;Killer is out of control!&quot;);  return 0;}The APIs called to play and stop the audio stream is:#ifndef AUDIOSTREAM_H#define AUDIOSTREAM_H#include &lt;AudioUnit/AudioUnit.h&gt;typedef void (* AudioCallback)(void* buffer, unsigned long frames);class AudioStream{public:  // We only support output for now.  // enum Side  // {  //   OUTPUT,  //   INPUT  // }  enum Format  {    S16LE, // PCM signed 16-bit little-endian    S16BE, // PCM signed 16-bit big-endian    F32LE, // PCM 32-bit floating-point little-endian    F32BE  // PCM 32-bit floating-point big-endian  };  AudioStream(Format aFormat,              unsigned int aRate,              unsigned int aChannels,              AudioCallback aCallback);  ~AudioStream();  void Start();  void Stop();private:  void CreateAudioUnit();  void SetDescription(Format aFormat);  void SetCallback();  static OSStatus DataCallback(void* aRefCon,                        AudioUnitRenderActionFlags* aActionFlags,                        const AudioTimeStamp* aTimeStamp,                        UInt32 aBusNumber,                        UInt32 aNumFrames,                        AudioBufferList* aData);  unsigned int mRate;  unsigned int mChannels;  AudioStreamBasicDescription mDescription; // Format descriptions  // AudioUnit is a pointer to ComponentInstanceRecord  AudioUnit mUnit;  AudioCallback mCallback;};#endif // #ifndef AUDIOSTREAM_H#include &lt;assert.h&gt;#include &lt;CoreAudio/CoreAudio.h&gt;#include &quot;AudioStream.h&quot;#define AU_OUT_BUS  0// #define AU_IN_BUS   1AudioStream::AudioStream(Format aFormat,                         unsigned int aRate,                         unsigned int aChannels,                         AudioCallback aCallback)  : mRate(aRate)  , mChannels(aChannels)  , mUnit(nullptr)  , mCallback(aCallback){  assert(mRate &amp;&amp; mChannels);  CreateAudioUnit(); // Initialize mUnit  SetDescription(aFormat); // Initialize mDescription  SetCallback(); // Render output to DataCallback  assert(AudioUnitInitialize(mUnit) == noErr);}AudioStream::~AudioStream(){  assert(mUnit);  assert(AudioOutputUnitStop(mUnit) == noErr);  assert(AudioUnitUninitialize(mUnit) == noErr);  assert(AudioComponentInstanceDispose(mUnit) == noErr);}voidAudioStream::Start(){  assert(mUnit);  assert(AudioOutputUnitStart(mUnit) == noErr);}voidAudioStream::Stop(){  assert(mUnit);  assert(AudioOutputUnitStop(mUnit) == noErr);}voidAudioStream::CreateAudioUnit(){  assert(!mUnit); // mUnit should be nullptr before initializing.  AudioComponentDescription desc;  desc.componentType = kAudioUnitType_Output;  desc.componentSubType = kAudioUnitSubType_DefaultOutput;  desc.componentManufacturer = kAudioUnitManufacturer_Apple;  desc.componentFlags = 0;  desc.componentFlagsMask = 0;  AudioComponent comp = AudioComponentFindNext(NULL, &amp;desc);  assert(comp); // comp will be nullptr if there is no matching audio hardware.  assert(AudioComponentInstanceNew(comp, &amp;mUnit) == noErr);  assert(mUnit); // mUnit should NOT be nullptr after initializing.}voidAudioStream::SetDescription(Format aFormat){  memset(&amp;mDescription, 0, sizeof(mDescription));  switch (aFormat) {    case S16LE:      mDescription.mBitsPerChannel = 16;      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;      break;    case S16BE:      mDescription.mBitsPerChannel = 16;      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |                                  kAudioFormatFlagIsBigEndian;      break;    case F32LE:      mDescription.mBitsPerChannel = 32;      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;      break;    case F32BE:      mDescription.mBitsPerChannel = 32;      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |                                  kAudioFormatFlagIsBigEndian;      break;    default:      assert(false);  }  // The mFormatFlags below should be set by &quot;|&quot; or operator,  // or the assigned flags above will be cleared.  mDescription.mFormatID = kAudioFormatLinearPCM;  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;  mDescription.mSampleRate = mRate;  mDescription.mChannelsPerFrame = mChannels;  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *                                mDescription.mChannelsPerFrame;  mDescription.mFramesPerPacket = 1;  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *                                 mDescription.mFramesPerPacket;  mDescription.mReserved = 0;  assert(AudioUnitSetProperty(mUnit,                              kAudioUnitProperty_StreamFormat,                              kAudioUnitScope_Input,                              AU_OUT_BUS,                              &amp;mDescription,                              sizeof(mDescription)) == noErr);}voidAudioStream::SetCallback(){  AURenderCallbackStruct aurcbs;  memset(&amp;aurcbs, 0, sizeof(aurcbs));  aurcbs.inputProc = DataCallback;  aurcbs.inputProcRefCon = this; // Pass this as callback&#39;s arguments  assert(AudioUnitSetProperty(mUnit,                              kAudioUnitProperty_SetRenderCallback,                              kAudioUnitScope_Global,                              AU_OUT_BUS,                              &amp;aurcbs,                              sizeof(aurcbs)) == noErr);}/* static */ OSStatusAudioStream::DataCallback(void* aRefCon,                          AudioUnitRenderActionFlags* aActionFlags,                          const AudioTimeStamp* aTimeStamp,                          UInt32 aBusNumber,                          UInt32 aNumFrames,                          AudioBufferList* aData){  assert(aBusNumber == AU_OUT_BUS);  assert(aData-&gt;mNumberBuffers == 1);  AudioStream* as = static_cast&lt;AudioStream*&gt;(aRefCon); // Get arguments  void* buffer = aData-&gt;mBuffers[0].mData;  as-&gt;mCallback(buffer, aNumFrames);  return noErr;}The key why deadlock happend is thatthe audio callback thread holds a mutex(hereafter referred to as Mutex-AU)shared with AudioUnit.The Mutex-AU is held inside it’s framework, so you don’t notice it.Thus, if the callback thread requests another mutex M held by the anotherthread, without releasing mutex-AU, then it will cause a deadlock when theanother thread, which holds the mutex M, request to use AudioUnit.That is,if we have a thread T, holding the mutex Mand one callback thread which holds the mutex-AU,The deadlock will occur when the callback thread requests the mutex M(the callback thread is blocked for waiting the mutex M)and the thread T requests the mutex-AU to use AudioUnit" />
<meta property="og:description" content="There was a deadlock occured when we tried to integrate my implementationfor audio 5.1 into Firefox.You can see the bug here.It only happens on OSX.After analysis,I wrote a test to prevent others from getting into the same problem.The test is added to cubeb,which is our cross-platform audio library for Firefox.We reproduced a simpler version of the deadlock)in the test.However, the code is not easy enough for those who are not familir with cubeb,so I wrote a general version to highlight the issue toeveryone who uses AudioUnit in their audio backend.You can find the code on gist here// Deadlock//// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held// by another thread, without releasing mutex_AU, then it will cause a// deadlock when another thread holding the mutex M requests to use AudioUnit.//// The following figure illustrates the deadlock described above:////    (Thread A)     holds//  data_callback &lt;---------- mutext_AudioUnit(mutex_AU)//      |                            ^//      |                            |//      | request                    | request//      |                            |//      v           holds            |//   mutex_M -------------------&gt; Thread B#include &lt;assert.h&gt;               // for assert#include &lt;pthread.h&gt;              // for pthread#include &lt;signal.h&gt;               // for signal#include &lt;unistd.h&gt;               // for sleep, usleep#include &quot;AudioStream.h&quot;          // for AudioStream#include &quot;utils.h&quot;                // for LOG#include &quot;OwnedCriticalSection.h&quot; // for OwnedCriticalSection// The signal alias for calling our thread killer.#define CALL_THREAD_KILLER SIGUSR1const unsigned int kFequency = 44100;const unsigned int kChannels = 2;// If we apply ERRORCHECK mode, then we can&#39;t unlock a mutex locked by a// different thread.// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);OwnedCriticalSection gMutex;using locker = std::lock_guard&lt;OwnedCriticalSection&gt;;// Indicating whether the test is passed.bool gPass = false;// Indicating whether the data callback is fired.bool gCalled = false;// Indicating whether the data callback is running.bool gCalling = false;// Indicating whether the assigned task is done.bool gTaskDone = false;// Indicating whether our pending task thread is killed by ourselves.bool gKilled = false;void killer(int aSignal){  assert(aSignal == CALL_THREAD_KILLER);  LOG(&quot;pending task thread is killed!\n&quot;);  gKilled = true;}uint64_t getThreadId(pthread_t aThread = NULL){  uint64_t tid;  // tid will be current thread id if aThread is null.  pthread_threadid_np(aThread, &amp;tid);  return tid;}// The output callback fired from audio rendering mechanism, which is on// out-of-main thread.void callback(void* aBuffer, unsigned long aFrames){  // The callback thread holds a mutex shared with AudioUnit.  gCalling = true;  uint64_t id = getThreadId();  !gCalled &amp;&amp; LOG(&quot;Output callback is on thread %llu, holding mutex_AU\n&quot;, id);  gCalled = true;  if (!gTaskDone) {    // Force to switch threads by sleeping 10 ms. Notice that anything over    // 10ms would produce a glitch. It&#39;s intended for testing deadlock,    // so we ignore the fault here.    LOG(&quot;[%llu] Force to switch threads\n&quot;, id);    usleep(10000);  }  LOG(&quot;[%llu] Try getting another mutex: gMutex...\n&quot;, id);  locker guard(gMutex);  LOG(&quot;[%llu] Got mutex finally!\n&quot;, id);  gCalling = false;}void* task(void*){  // Hold the mutex.  locker guard(gMutex);  uint64_t id = getThreadId();  LOG(&quot;Task thread: %llu, holding gMutex, is created\n&quot;, id);  while(!gCalling) {    LOG(&quot;[%llu] waiting for output callback before running task\n&quot;, id);    usleep(1000); // Force to switch threads by sleeping 1 ms.  }  // Creating another AudioUnit when we already one will cause a deadlock!  LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&quot;, id);  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);  LOG(&quot;[%llu] Another AudioUnit is created!\n&quot;, id);  gTaskDone = true;  return NULL;}// We provide one possible solution here:// void* task(void*)// {//   uint64_t id = getThreadId();//   LOG(&quot;Task thread: %llu is created\n&quot;, id);////   while(!gCalling) {//     LOG(&quot;[%llu] waiting for output callback before running task\n&quot;, id);//     usleep(1000); // Force to switch threads by sleeping 1 ms.//   }////   // Creating another AudioUnit when we already one will cause a deadlock!//   LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&quot;, id);//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);////   LOG(&quot;[%llu] Another AudioUnit is created!\n&quot;, id);////   // Hold the mutex.//   LOG(&quot;[%llu] Try getting another mutex: gMutex...\n&quot;, id);//   locker guard(gMutex);////   LOG(&quot;[%llu] Got mutex finally!\n&quot;, id);////   gTaskDone = true;////   return NULL;// }void* watchdog(void* aSubject){  uint64_t id = getThreadId();  pthread_t subject = *((pthread_t *) aSubject);  uint64_t sid = getThreadId(subject);  LOG(&quot;Monitor thread %llu on thread %llu\n&quot;, sid, id);  unsigned int sec = 1;  LOG(&quot;[%llu] sleep %d seconds before checking task for thread %llu\n&quot;, id, sec, sid);  sleep(sec); // Force to switch threads.  if (!gTaskDone) {    LOG(&quot;[%llu] Kill the task thread %llu!\n&quot;, id, sid);    assert(!pthread_kill(subject, CALL_THREAD_KILLER));    assert(!pthread_detach(subject));    // The mutex held by the killed thread(subject) won&#39;t be released,    // so we need unlock it manually. Notice that we can&#39;t unlock a mutex held    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.    gMutex.unlock();  }  LOG(&quot;\n[%llu] Task is %sdone\n\n&quot;, id, gTaskDone ? &quot;&quot;: &quot;NOT &quot;);  gPass = gTaskDone;  return NULL;}int main(){  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);  // Install signal handler.  signal(CALL_THREAD_KILLER, killer);  pthread_t subject, detector;  pthread_create(&amp;subject, NULL, task, NULL);  pthread_create(&amp;detector, NULL, watchdog, (void *) &amp;subject);  as.Start();  pthread_join(subject, NULL);  pthread_join(detector, NULL);  as.Stop();  // If the callback is never fired, then the task must not be done.  // There is no to keep checking in this case.  assert(gCalled &amp;&amp; &quot;Callback should be fired!&quot;);  // The task thread might keep running after the deadlock is freed, so we use  // gPass instead of gTaskDone.  assert(gPass &amp;&amp; &quot;Deadlock detected!&quot;);  // False gPass implies there is a deadlock detected, so we need to kill the  // pending task thread to free the deadlock and set gKilled to true.  // True gPass means there is no deadlock and no need to kill any thread.  assert(gPass != gKilled &amp;&amp; &quot;Killer is out of control!&quot;);  return 0;}The APIs called to play and stop the audio stream is:#ifndef AUDIOSTREAM_H#define AUDIOSTREAM_H#include &lt;AudioUnit/AudioUnit.h&gt;typedef void (* AudioCallback)(void* buffer, unsigned long frames);class AudioStream{public:  // We only support output for now.  // enum Side  // {  //   OUTPUT,  //   INPUT  // }  enum Format  {    S16LE, // PCM signed 16-bit little-endian    S16BE, // PCM signed 16-bit big-endian    F32LE, // PCM 32-bit floating-point little-endian    F32BE  // PCM 32-bit floating-point big-endian  };  AudioStream(Format aFormat,              unsigned int aRate,              unsigned int aChannels,              AudioCallback aCallback);  ~AudioStream();  void Start();  void Stop();private:  void CreateAudioUnit();  void SetDescription(Format aFormat);  void SetCallback();  static OSStatus DataCallback(void* aRefCon,                        AudioUnitRenderActionFlags* aActionFlags,                        const AudioTimeStamp* aTimeStamp,                        UInt32 aBusNumber,                        UInt32 aNumFrames,                        AudioBufferList* aData);  unsigned int mRate;  unsigned int mChannels;  AudioStreamBasicDescription mDescription; // Format descriptions  // AudioUnit is a pointer to ComponentInstanceRecord  AudioUnit mUnit;  AudioCallback mCallback;};#endif // #ifndef AUDIOSTREAM_H#include &lt;assert.h&gt;#include &lt;CoreAudio/CoreAudio.h&gt;#include &quot;AudioStream.h&quot;#define AU_OUT_BUS  0// #define AU_IN_BUS   1AudioStream::AudioStream(Format aFormat,                         unsigned int aRate,                         unsigned int aChannels,                         AudioCallback aCallback)  : mRate(aRate)  , mChannels(aChannels)  , mUnit(nullptr)  , mCallback(aCallback){  assert(mRate &amp;&amp; mChannels);  CreateAudioUnit(); // Initialize mUnit  SetDescription(aFormat); // Initialize mDescription  SetCallback(); // Render output to DataCallback  assert(AudioUnitInitialize(mUnit) == noErr);}AudioStream::~AudioStream(){  assert(mUnit);  assert(AudioOutputUnitStop(mUnit) == noErr);  assert(AudioUnitUninitialize(mUnit) == noErr);  assert(AudioComponentInstanceDispose(mUnit) == noErr);}voidAudioStream::Start(){  assert(mUnit);  assert(AudioOutputUnitStart(mUnit) == noErr);}voidAudioStream::Stop(){  assert(mUnit);  assert(AudioOutputUnitStop(mUnit) == noErr);}voidAudioStream::CreateAudioUnit(){  assert(!mUnit); // mUnit should be nullptr before initializing.  AudioComponentDescription desc;  desc.componentType = kAudioUnitType_Output;  desc.componentSubType = kAudioUnitSubType_DefaultOutput;  desc.componentManufacturer = kAudioUnitManufacturer_Apple;  desc.componentFlags = 0;  desc.componentFlagsMask = 0;  AudioComponent comp = AudioComponentFindNext(NULL, &amp;desc);  assert(comp); // comp will be nullptr if there is no matching audio hardware.  assert(AudioComponentInstanceNew(comp, &amp;mUnit) == noErr);  assert(mUnit); // mUnit should NOT be nullptr after initializing.}voidAudioStream::SetDescription(Format aFormat){  memset(&amp;mDescription, 0, sizeof(mDescription));  switch (aFormat) {    case S16LE:      mDescription.mBitsPerChannel = 16;      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;      break;    case S16BE:      mDescription.mBitsPerChannel = 16;      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |                                  kAudioFormatFlagIsBigEndian;      break;    case F32LE:      mDescription.mBitsPerChannel = 32;      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;      break;    case F32BE:      mDescription.mBitsPerChannel = 32;      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |                                  kAudioFormatFlagIsBigEndian;      break;    default:      assert(false);  }  // The mFormatFlags below should be set by &quot;|&quot; or operator,  // or the assigned flags above will be cleared.  mDescription.mFormatID = kAudioFormatLinearPCM;  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;  mDescription.mSampleRate = mRate;  mDescription.mChannelsPerFrame = mChannels;  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *                                mDescription.mChannelsPerFrame;  mDescription.mFramesPerPacket = 1;  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *                                 mDescription.mFramesPerPacket;  mDescription.mReserved = 0;  assert(AudioUnitSetProperty(mUnit,                              kAudioUnitProperty_StreamFormat,                              kAudioUnitScope_Input,                              AU_OUT_BUS,                              &amp;mDescription,                              sizeof(mDescription)) == noErr);}voidAudioStream::SetCallback(){  AURenderCallbackStruct aurcbs;  memset(&amp;aurcbs, 0, sizeof(aurcbs));  aurcbs.inputProc = DataCallback;  aurcbs.inputProcRefCon = this; // Pass this as callback&#39;s arguments  assert(AudioUnitSetProperty(mUnit,                              kAudioUnitProperty_SetRenderCallback,                              kAudioUnitScope_Global,                              AU_OUT_BUS,                              &amp;aurcbs,                              sizeof(aurcbs)) == noErr);}/* static */ OSStatusAudioStream::DataCallback(void* aRefCon,                          AudioUnitRenderActionFlags* aActionFlags,                          const AudioTimeStamp* aTimeStamp,                          UInt32 aBusNumber,                          UInt32 aNumFrames,                          AudioBufferList* aData){  assert(aBusNumber == AU_OUT_BUS);  assert(aData-&gt;mNumberBuffers == 1);  AudioStream* as = static_cast&lt;AudioStream*&gt;(aRefCon); // Get arguments  void* buffer = aData-&gt;mBuffers[0].mData;  as-&gt;mCallback(buffer, aNumFrames);  return noErr;}The key why deadlock happend is thatthe audio callback thread holds a mutex(hereafter referred to as Mutex-AU)shared with AudioUnit.The Mutex-AU is held inside it’s framework, so you don’t notice it.Thus, if the callback thread requests another mutex M held by the anotherthread, without releasing mutex-AU, then it will cause a deadlock when theanother thread, which holds the mutex M, request to use AudioUnit.That is,if we have a thread T, holding the mutex Mand one callback thread which holds the mutex-AU,The deadlock will occur when the callback thread requests the mutex M(the callback thread is blocked for waiting the mutex M)and the thread T requests the mutex-AU to use AudioUnit" />
<link rel="canonical" href="http://localhost:4000/post/deadlock-when-using-audiounit" />
<meta property="og:url" content="http://localhost:4000/post/deadlock-when-using-audiounit" />
<meta property="og:site_name" content="Peak Up" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-05-05T00:00:00+08:00" />
<link rel="prev" href="http://localhost:4000/post/how-to-simulate-a-c-class-in-c" title="How to simulate a C++ class in C" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Deadlock when using AudioUnit",
    "datePublished": "2017-05-05T00:00:00+08:00",
    "description": "There was a deadlock occured when we tried to integrate my implementationfor audio 5.1 into Firefox.You can see the bug here.It only happens on OSX.After analysis,I wrote a test to prevent others from getting into the same problem.The test is added to cubeb,which is our cross-platform audio library for Firefox.We reproduced a simpler version of the deadlock)in the test.However, the code is not easy enough for those who are not familir with cubeb,so I wrote a general version to highlight the issue toeveryone who uses AudioUnit in their audio backend.You can find the code on gist here// Deadlock//// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held// by another thread, without releasing mutex_AU, then it will cause a// deadlock when another thread holding the mutex M requests to use AudioUnit.//// The following figure illustrates the deadlock described above:////    (Thread A)     holds//  data_callback &lt;---------- mutext_AudioUnit(mutex_AU)//      |                            ^//      |                            |//      | request                    | request//      |                            |//      v           holds            |//   mutex_M -------------------&gt; Thread B#include &lt;assert.h&gt;               // for assert#include &lt;pthread.h&gt;              // for pthread#include &lt;signal.h&gt;               // for signal#include &lt;unistd.h&gt;               // for sleep, usleep#include &quot;AudioStream.h&quot;          // for AudioStream#include &quot;utils.h&quot;                // for LOG#include &quot;OwnedCriticalSection.h&quot; // for OwnedCriticalSection// The signal alias for calling our thread killer.#define CALL_THREAD_KILLER SIGUSR1const unsigned int kFequency = 44100;const unsigned int kChannels = 2;// If we apply ERRORCHECK mode, then we can&#39;t unlock a mutex locked by a// different thread.// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);OwnedCriticalSection gMutex;using locker = std::lock_guard&lt;OwnedCriticalSection&gt;;// Indicating whether the test is passed.bool gPass = false;// Indicating whether the data callback is fired.bool gCalled = false;// Indicating whether the data callback is running.bool gCalling = false;// Indicating whether the assigned task is done.bool gTaskDone = false;// Indicating whether our pending task thread is killed by ourselves.bool gKilled = false;void killer(int aSignal){  assert(aSignal == CALL_THREAD_KILLER);  LOG(&quot;pending task thread is killed!\\n&quot;);  gKilled = true;}uint64_t getThreadId(pthread_t aThread = NULL){  uint64_t tid;  // tid will be current thread id if aThread is null.  pthread_threadid_np(aThread, &amp;tid);  return tid;}// The output callback fired from audio rendering mechanism, which is on// out-of-main thread.void callback(void* aBuffer, unsigned long aFrames){  // The callback thread holds a mutex shared with AudioUnit.  gCalling = true;  uint64_t id = getThreadId();  !gCalled &amp;&amp; LOG(&quot;Output callback is on thread %llu, holding mutex_AU\\n&quot;, id);  gCalled = true;  if (!gTaskDone) {    // Force to switch threads by sleeping 10 ms. Notice that anything over    // 10ms would produce a glitch. It&#39;s intended for testing deadlock,    // so we ignore the fault here.    LOG(&quot;[%llu] Force to switch threads\\n&quot;, id);    usleep(10000);  }  LOG(&quot;[%llu] Try getting another mutex: gMutex...\\n&quot;, id);  locker guard(gMutex);  LOG(&quot;[%llu] Got mutex finally!\\n&quot;, id);  gCalling = false;}void* task(void*){  // Hold the mutex.  locker guard(gMutex);  uint64_t id = getThreadId();  LOG(&quot;Task thread: %llu, holding gMutex, is created\\n&quot;, id);  while(!gCalling) {    LOG(&quot;[%llu] waiting for output callback before running task\\n&quot;, id);    usleep(1000); // Force to switch threads by sleeping 1 ms.  }  // Creating another AudioUnit when we already one will cause a deadlock!  LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\\n&quot;, id);  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);  LOG(&quot;[%llu] Another AudioUnit is created!\\n&quot;, id);  gTaskDone = true;  return NULL;}// We provide one possible solution here:// void* task(void*)// {//   uint64_t id = getThreadId();//   LOG(&quot;Task thread: %llu is created\\n&quot;, id);////   while(!gCalling) {//     LOG(&quot;[%llu] waiting for output callback before running task\\n&quot;, id);//     usleep(1000); // Force to switch threads by sleeping 1 ms.//   }////   // Creating another AudioUnit when we already one will cause a deadlock!//   LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\\n&quot;, id);//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);////   LOG(&quot;[%llu] Another AudioUnit is created!\\n&quot;, id);////   // Hold the mutex.//   LOG(&quot;[%llu] Try getting another mutex: gMutex...\\n&quot;, id);//   locker guard(gMutex);////   LOG(&quot;[%llu] Got mutex finally!\\n&quot;, id);////   gTaskDone = true;////   return NULL;// }void* watchdog(void* aSubject){  uint64_t id = getThreadId();  pthread_t subject = *((pthread_t *) aSubject);  uint64_t sid = getThreadId(subject);  LOG(&quot;Monitor thread %llu on thread %llu\\n&quot;, sid, id);  unsigned int sec = 1;  LOG(&quot;[%llu] sleep %d seconds before checking task for thread %llu\\n&quot;, id, sec, sid);  sleep(sec); // Force to switch threads.  if (!gTaskDone) {    LOG(&quot;[%llu] Kill the task thread %llu!\\n&quot;, id, sid);    assert(!pthread_kill(subject, CALL_THREAD_KILLER));    assert(!pthread_detach(subject));    // The mutex held by the killed thread(subject) won&#39;t be released,    // so we need unlock it manually. Notice that we can&#39;t unlock a mutex held    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.    gMutex.unlock();  }  LOG(&quot;\\n[%llu] Task is %sdone\\n\\n&quot;, id, gTaskDone ? &quot;&quot;: &quot;NOT &quot;);  gPass = gTaskDone;  return NULL;}int main(){  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);  // Install signal handler.  signal(CALL_THREAD_KILLER, killer);  pthread_t subject, detector;  pthread_create(&amp;subject, NULL, task, NULL);  pthread_create(&amp;detector, NULL, watchdog, (void *) &amp;subject);  as.Start();  pthread_join(subject, NULL);  pthread_join(detector, NULL);  as.Stop();  // If the callback is never fired, then the task must not be done.  // There is no to keep checking in this case.  assert(gCalled &amp;&amp; &quot;Callback should be fired!&quot;);  // The task thread might keep running after the deadlock is freed, so we use  // gPass instead of gTaskDone.  assert(gPass &amp;&amp; &quot;Deadlock detected!&quot;);  // False gPass implies there is a deadlock detected, so we need to kill the  // pending task thread to free the deadlock and set gKilled to true.  // True gPass means there is no deadlock and no need to kill any thread.  assert(gPass != gKilled &amp;&amp; &quot;Killer is out of control!&quot;);  return 0;}The APIs called to play and stop the audio stream is:#ifndef AUDIOSTREAM_H#define AUDIOSTREAM_H#include &lt;AudioUnit/AudioUnit.h&gt;typedef void (* AudioCallback)(void* buffer, unsigned long frames);class AudioStream{public:  // We only support output for now.  // enum Side  // {  //   OUTPUT,  //   INPUT  // }  enum Format  {    S16LE, // PCM signed 16-bit little-endian    S16BE, // PCM signed 16-bit big-endian    F32LE, // PCM 32-bit floating-point little-endian    F32BE  // PCM 32-bit floating-point big-endian  };  AudioStream(Format aFormat,              unsigned int aRate,              unsigned int aChannels,              AudioCallback aCallback);  ~AudioStream();  void Start();  void Stop();private:  void CreateAudioUnit();  void SetDescription(Format aFormat);  void SetCallback();  static OSStatus DataCallback(void* aRefCon,                        AudioUnitRenderActionFlags* aActionFlags,                        const AudioTimeStamp* aTimeStamp,                        UInt32 aBusNumber,                        UInt32 aNumFrames,                        AudioBufferList* aData);  unsigned int mRate;  unsigned int mChannels;  AudioStreamBasicDescription mDescription; // Format descriptions  // AudioUnit is a pointer to ComponentInstanceRecord  AudioUnit mUnit;  AudioCallback mCallback;};#endif // #ifndef AUDIOSTREAM_H#include &lt;assert.h&gt;#include &lt;CoreAudio/CoreAudio.h&gt;#include &quot;AudioStream.h&quot;#define AU_OUT_BUS  0// #define AU_IN_BUS   1AudioStream::AudioStream(Format aFormat,                         unsigned int aRate,                         unsigned int aChannels,                         AudioCallback aCallback)  : mRate(aRate)  , mChannels(aChannels)  , mUnit(nullptr)  , mCallback(aCallback){  assert(mRate &amp;&amp; mChannels);  CreateAudioUnit(); // Initialize mUnit  SetDescription(aFormat); // Initialize mDescription  SetCallback(); // Render output to DataCallback  assert(AudioUnitInitialize(mUnit) == noErr);}AudioStream::~AudioStream(){  assert(mUnit);  assert(AudioOutputUnitStop(mUnit) == noErr);  assert(AudioUnitUninitialize(mUnit) == noErr);  assert(AudioComponentInstanceDispose(mUnit) == noErr);}voidAudioStream::Start(){  assert(mUnit);  assert(AudioOutputUnitStart(mUnit) == noErr);}voidAudioStream::Stop(){  assert(mUnit);  assert(AudioOutputUnitStop(mUnit) == noErr);}voidAudioStream::CreateAudioUnit(){  assert(!mUnit); // mUnit should be nullptr before initializing.  AudioComponentDescription desc;  desc.componentType = kAudioUnitType_Output;  desc.componentSubType = kAudioUnitSubType_DefaultOutput;  desc.componentManufacturer = kAudioUnitManufacturer_Apple;  desc.componentFlags = 0;  desc.componentFlagsMask = 0;  AudioComponent comp = AudioComponentFindNext(NULL, &amp;desc);  assert(comp); // comp will be nullptr if there is no matching audio hardware.  assert(AudioComponentInstanceNew(comp, &amp;mUnit) == noErr);  assert(mUnit); // mUnit should NOT be nullptr after initializing.}voidAudioStream::SetDescription(Format aFormat){  memset(&amp;mDescription, 0, sizeof(mDescription));  switch (aFormat) {    case S16LE:      mDescription.mBitsPerChannel = 16;      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;      break;    case S16BE:      mDescription.mBitsPerChannel = 16;      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |                                  kAudioFormatFlagIsBigEndian;      break;    case F32LE:      mDescription.mBitsPerChannel = 32;      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;      break;    case F32BE:      mDescription.mBitsPerChannel = 32;      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |                                  kAudioFormatFlagIsBigEndian;      break;    default:      assert(false);  }  // The mFormatFlags below should be set by &quot;|&quot; or operator,  // or the assigned flags above will be cleared.  mDescription.mFormatID = kAudioFormatLinearPCM;  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;  mDescription.mSampleRate = mRate;  mDescription.mChannelsPerFrame = mChannels;  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *                                mDescription.mChannelsPerFrame;  mDescription.mFramesPerPacket = 1;  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *                                 mDescription.mFramesPerPacket;  mDescription.mReserved = 0;  assert(AudioUnitSetProperty(mUnit,                              kAudioUnitProperty_StreamFormat,                              kAudioUnitScope_Input,                              AU_OUT_BUS,                              &amp;mDescription,                              sizeof(mDescription)) == noErr);}voidAudioStream::SetCallback(){  AURenderCallbackStruct aurcbs;  memset(&amp;aurcbs, 0, sizeof(aurcbs));  aurcbs.inputProc = DataCallback;  aurcbs.inputProcRefCon = this; // Pass this as callback&#39;s arguments  assert(AudioUnitSetProperty(mUnit,                              kAudioUnitProperty_SetRenderCallback,                              kAudioUnitScope_Global,                              AU_OUT_BUS,                              &amp;aurcbs,                              sizeof(aurcbs)) == noErr);}/* static */ OSStatusAudioStream::DataCallback(void* aRefCon,                          AudioUnitRenderActionFlags* aActionFlags,                          const AudioTimeStamp* aTimeStamp,                          UInt32 aBusNumber,                          UInt32 aNumFrames,                          AudioBufferList* aData){  assert(aBusNumber == AU_OUT_BUS);  assert(aData-&gt;mNumberBuffers == 1);  AudioStream* as = static_cast&lt;AudioStream*&gt;(aRefCon); // Get arguments  void* buffer = aData-&gt;mBuffers[0].mData;  as-&gt;mCallback(buffer, aNumFrames);  return noErr;}The key why deadlock happend is thatthe audio callback thread holds a mutex(hereafter referred to as Mutex-AU)shared with AudioUnit.The Mutex-AU is held inside it’s framework, so you don’t notice it.Thus, if the callback thread requests another mutex M held by the anotherthread, without releasing mutex-AU, then it will cause a deadlock when theanother thread, which holds the mutex M, request to use AudioUnit.That is,if we have a thread T, holding the mutex Mand one callback thread which holds the mutex-AU,The deadlock will occur when the callback thread requests the mutex M(the callback thread is blocked for waiting the mutex M)and the thread T requests the mutex-AU to use AudioUnit",
    "logo": "http://localhost:4000mountain.png",
    "url": "http://localhost:4000/post/deadlock-when-using-audiounit"
  }
</script>
<!-- End Jekyll SEO tag -->

<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Peak Up" />

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
    crossorigin="anonymous">

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/style.css" />
<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/syntax.css" />




<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/favicons/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/favicons/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/favicons/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/favicons/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post-template" itemscope itemtype="http://schema.org/WebPage">

    
<div class="search-wrapper">
    <div class="search-form">
        <input type="text" id="search-input" class="search-field" placeholder="Search...">
        <i id="search-close" class="fa fa-times-circle"></i>
        <h4>Search results</h4>
        <ul id="results-container" class="search-results post-list">
        </ul>
        <!-- /.search-results -->
    </div>
    <!-- /.search-form -->
</div>
<!-- ./search-wrapper -->


<div id="fade"></div>
<a id="slide" class="animated fade">
    <i class="fa fa-bars" aria-hidden="true"></i>
</a>
<aside id="sidebar">
    <nav id="navigation">
        <h2>MENU</h2>
        <hr>
        <ul> 
            <li>
                <a href="http://localhost:4000/"><!-- <i class="fa fa-home"></i>&nbsp;-->Home</a>  </li>
            
            <li>
                <a href="http://localhost:4000/categories"><!-- <i class="fa fa-sitemap"></i>&nbsp;-->Categories</a>  </li>
            
            <li>
                <a href="http://localhost:4000/tags"><!-- <i class="fa fa-tags"></i>&nbsp;-->Tags</a>  </li>
            
            <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
        </ul>
    </nav>
</aside>


<header id="masthead" class="blog-background overlay align-center align-middle animated from-bottom" style="background-image: url(http://localhost:4000/images/background/taiwan_1.jpg)"
    itemscope itemtype="http://schema.org/Organization">



    <button class="menu-button animated fade dosearch">
        <i class="fa fa-search"></i>
    </button>



    <div class="inner">
        <div class="container">
            <a class="brand" href="http://localhost:4000/" itemprop="url">
                <img itemprop="logo" src="http://localhost:4000/images/mountain.png" alt="Peak Up Logo" />
                <h1 class="blog-title light" itemprop="name">
                    Peak Up
                </h1>
            </a>
        </div>
    </div>



    <div class="decor-wrapper">
        <svg id="header-decor" class="decor bottom" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 100 L50 50 L0 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 100 L50 50 L100 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 100 L50 50 L0 66.6" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 100 L50 50 L100 66.6" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>

</header>


    <div id="main" class="content" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
        <div class="container">
            <div class="row">
                <article class="post col-md-8 col-md-offset-2 hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
                
                
                
                

                    <header class="post-header entry-header">

                    

                    
                        <h1 class="post-title text-center hyper lighter bordered-bottom entry-title" itemprop="headline">
                        
                            
                        
                        
                        

                        
                            Deadlock when using AudioUnit
                        </h1>
                    

                        <div class="cursive" style="color: #000; font-style:italic;"></div>

                            <div class="post-info text-center small">
                            
                                <span class="entry-date date published updated">
                            
                            
                                    <time datetime="2017-05-05T00:00:00+08:00" class="post-time" itemprop="datePublished">05 May 2017</time>
                                </span>
                            

                                in <span class="post-tags">

                            
                                    <a href="http://localhost:4000/categories/index.html#Media" data-toggle="tooltip" title="Other posts from the Media category" rel="tag">Media</a>
                                
                            
                                </span>
                            
                            &nbsp;
                                <span class="post-tags"><i class="fa fa-clock-o"></i>&nbsp;

                            

                            
                                    <span class="time">8.627777777777778</span> minutes read
                            
                                
                            

                                </span>
                            
                            </div>

                    </header>

                    <div class="post-body bordered-bottom" itemprop="description">
                    

                        <p>There was a deadlock occured when we tried to integrate my implementation
for audio 5.1 into Firefox.
You can see the <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1337805">bug here</a>.
It <strong>only happens on OSX</strong>.
After <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1350511#c1">analysis</a>,
I wrote a test to prevent others from getting into the same problem.
The test is added to <a href="https://github.com/ChunMinChang/cubeb">cubeb</a>,
which is our cross-platform audio library for Firefox.
We reproduced a simpler version of <a href="https://github.com/ChunMinChang/cubeb/blob/8939c0d168a27b1d5047779caad46835ca4651b9/test/test_deadlock.cpp#L1-L43">the deadlock</a>)
in the test.</p>

<p>However, the code is not easy enough for those who are not familir with <em>cubeb</em>,
so I wrote a general version to highlight the issue to
everyone who uses <em>AudioUnit</em> in their audio backend.
You can find the code on <a href="https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9">gist here</a></p>

<noscript><pre>// Deadlock
//
// In CoreAudio, the ouput callback will holds a mutex shared with AudioUnit
// (hereinafter mutex_AU). Thus, if the callback requests another mutex M held
// by another thread, without releasing mutex_AU, then it will cause a
// deadlock when another thread holding the mutex M requests to use AudioUnit.
//
// The following figure illustrates the deadlock described above:
//
//    (Thread A)     holds
//  data_callback &lt;---------- mutext_AudioUnit(mutex_AU)
//      |                            ^
//      |                            |
//      | request                    | request
//      |                            |
//      v           holds            |
//   mutex_M -------------------&gt; Thread B

#include &lt;assert.h&gt;               // for assert
#include &lt;pthread.h&gt;              // for pthread
#include &lt;signal.h&gt;               // for signal
#include &lt;unistd.h&gt;               // for sleep, usleep

#include &quot;AudioStream.h&quot;          // for AudioStream
#include &quot;utils.h&quot;                // for LOG
#include &quot;OwnedCriticalSection.h&quot; // for OwnedCriticalSection

// The signal alias for calling our thread killer.
#define CALL_THREAD_KILLER SIGUSR1

const unsigned int kFequency = 44100;
const unsigned int kChannels = 2;

// If we apply ERRORCHECK mode, then we can&#39;t unlock a mutex locked by a
// different thread.
// OwnedCriticalSection gMutex(OwnedCriticalSection::Mode::ERRORCHECK);
OwnedCriticalSection gMutex;
using locker = std::lock_guard&lt;OwnedCriticalSection&gt;;

// Indicating whether the test is passed.
bool gPass = false;

// Indicating whether the data callback is fired.
bool gCalled = false;

// Indicating whether the data callback is running.
bool gCalling = false;

// Indicating whether the assigned task is done.
bool gTaskDone = false;

// Indicating whether our pending task thread is killed by ourselves.
bool gKilled = false;

void killer(int aSignal)
{
  assert(aSignal == CALL_THREAD_KILLER);
  LOG(&quot;pending task thread is killed!\n&quot;);
  gKilled = true;
}

uint64_t getThreadId(pthread_t aThread = NULL)
{
  uint64_t tid;
  // tid will be current thread id if aThread is null.
  pthread_threadid_np(aThread, &amp;tid);
  return tid;
}

// The output callback fired from audio rendering mechanism, which is on
// out-of-main thread.
void callback(void* aBuffer, unsigned long aFrames)
{
  // The callback thread holds a mutex shared with AudioUnit.

  gCalling = true;

  uint64_t id = getThreadId();
  !gCalled &amp;&amp; LOG(&quot;Output callback is on thread %llu, holding mutex_AU\n&quot;, id);
  gCalled = true;

  if (!gTaskDone) {
    // Force to switch threads by sleeping 10 ms. Notice that anything over
    // 10ms would produce a glitch. It&#39;s intended for testing deadlock,
    // so we ignore the fault here.
    LOG(&quot;[%llu] Force to switch threads\n&quot;, id);
    usleep(10000);
  }

  LOG(&quot;[%llu] Try getting another mutex: gMutex...\n&quot;, id);
  locker guard(gMutex);

  LOG(&quot;[%llu] Got mutex finally!\n&quot;, id);

  gCalling = false;
}

void* task(void*)
{
  // Hold the mutex.
  locker guard(gMutex);

  uint64_t id = getThreadId();
  LOG(&quot;Task thread: %llu, holding gMutex, is created\n&quot;, id);

  while(!gCalling) {
    LOG(&quot;[%llu] waiting for output callback before running task\n&quot;, id);
    usleep(1000); // Force to switch threads by sleeping 1 ms.
  }

  // Creating another AudioUnit when we already one will cause a deadlock!
  LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&quot;, id);
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  LOG(&quot;[%llu] Another AudioUnit is created!\n&quot;, id);
  gTaskDone = true;

  return NULL;
}

// We provide one possible solution here:
// void* task(void*)
// {
//   uint64_t id = getThreadId();
//   LOG(&quot;Task thread: %llu is created\n&quot;, id);
//
//   while(!gCalling) {
//     LOG(&quot;[%llu] waiting for output callback before running task\n&quot;, id);
//     usleep(1000); // Force to switch threads by sleeping 1 ms.
//   }
//
//   // Creating another AudioUnit when we already one will cause a deadlock!
//   LOG(&quot;[%llu] Try creating another AudioUnit (getting mutex_AU)...\n&quot;, id);
//   AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);
//
//   LOG(&quot;[%llu] Another AudioUnit is created!\n&quot;, id);
//
//   // Hold the mutex.
//   LOG(&quot;[%llu] Try getting another mutex: gMutex...\n&quot;, id);
//   locker guard(gMutex);
//
//   LOG(&quot;[%llu] Got mutex finally!\n&quot;, id);
//
//   gTaskDone = true;
//
//   return NULL;
// }

void* watchdog(void* aSubject)
{
  uint64_t id = getThreadId();

  pthread_t subject = *((pthread_t *) aSubject);
  uint64_t sid = getThreadId(subject);

  LOG(&quot;Monitor thread %llu on thread %llu\n&quot;, sid, id);

  unsigned int sec = 1;
  LOG(&quot;[%llu] sleep %d seconds before checking task for thread %llu\n&quot;, id, sec, sid);
  sleep(sec); // Force to switch threads.

  if (!gTaskDone) {
    LOG(&quot;[%llu] Kill the task thread %llu!\n&quot;, id, sid);
    assert(!pthread_kill(subject, CALL_THREAD_KILLER));
    assert(!pthread_detach(subject));
    // The mutex held by the killed thread(subject) won&#39;t be released,
    // so we need unlock it manually. Notice that we can&#39;t unlock a mutex held
    // by other thread in OwnedCriticalSection::Mode::ERRORCHECK mode of gMutex.
    gMutex.unlock();
  }

  LOG(&quot;\n[%llu] Task is %sdone\n\n&quot;, id, gTaskDone ? &quot;&quot;: &quot;NOT &quot;);
  gPass = gTaskDone;

  return NULL;
}

int main()
{
  AudioStream as(AudioStream::Format::F32LE, kFequency, kChannels, callback);

  // Install signal handler.
  signal(CALL_THREAD_KILLER, killer);

  pthread_t subject, detector;
  pthread_create(&amp;subject, NULL, task, NULL);
  pthread_create(&amp;detector, NULL, watchdog, (void *) &amp;subject);

  as.Start();

  pthread_join(subject, NULL);
  pthread_join(detector, NULL);

  as.Stop();

  // If the callback is never fired, then the task must not be done.
  // There is no to keep checking in this case.
  assert(gCalled &amp;&amp; &quot;Callback should be fired!&quot;);

  // The task thread might keep running after the deadlock is freed, so we use
  // gPass instead of gTaskDone.
  assert(gPass &amp;&amp; &quot;Deadlock detected!&quot;);

  // False gPass implies there is a deadlock detected, so we need to kill the
  // pending task thread to free the deadlock and set gKilled to true.
  // True gPass means there is no deadlock and no need to kill any thread.
  assert(gPass != gKilled &amp;&amp; &quot;Killer is out of control!&quot;);

  return 0;
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=test_deadlock.cpp"> </script>

<p>The APIs called to play and stop the audio stream is:</p>
<noscript><pre>#ifndef AUDIOSTREAM_H
#define AUDIOSTREAM_H

#include &lt;AudioUnit/AudioUnit.h&gt;

typedef void (* AudioCallback)(void* buffer, unsigned long frames);

class AudioStream
{
public:
  // We only support output for now.
  // enum Side
  // {
  //   OUTPUT,
  //   INPUT
  // }

  enum Format
  {
    S16LE, // PCM signed 16-bit little-endian
    S16BE, // PCM signed 16-bit big-endian
    F32LE, // PCM 32-bit floating-point little-endian
    F32BE  // PCM 32-bit floating-point big-endian
  };

  AudioStream(Format aFormat,
              unsigned int aRate,
              unsigned int aChannels,
              AudioCallback aCallback);

  ~AudioStream();

  void Start();
  void Stop();

private:
  void CreateAudioUnit();
  void SetDescription(Format aFormat);
  void SetCallback();
  static OSStatus DataCallback(void* aRefCon,
                        AudioUnitRenderActionFlags* aActionFlags,
                        const AudioTimeStamp* aTimeStamp,
                        UInt32 aBusNumber,
                        UInt32 aNumFrames,
                        AudioBufferList* aData);

  unsigned int mRate;
  unsigned int mChannels;
  AudioStreamBasicDescription mDescription; // Format descriptions
  // AudioUnit is a pointer to ComponentInstanceRecord
  AudioUnit mUnit;
  AudioCallback mCallback;
};

#endif // #ifndef AUDIOSTREAM_H
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.h"> </script>

<noscript><pre>#include &lt;assert.h&gt;
#include &lt;CoreAudio/CoreAudio.h&gt;

#include &quot;AudioStream.h&quot;

#define AU_OUT_BUS  0
// #define AU_IN_BUS   1

AudioStream::AudioStream(Format aFormat,
                         unsigned int aRate,
                         unsigned int aChannels,
                         AudioCallback aCallback)
  : mRate(aRate)
  , mChannels(aChannels)
  , mUnit(nullptr)
  , mCallback(aCallback)
{
  assert(mRate &amp;&amp; mChannels);
  CreateAudioUnit(); // Initialize mUnit
  SetDescription(aFormat); // Initialize mDescription
  SetCallback(); // Render output to DataCallback
  assert(AudioUnitInitialize(mUnit) == noErr);
}

AudioStream::~AudioStream()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
  assert(AudioUnitUninitialize(mUnit) == noErr);
  assert(AudioComponentInstanceDispose(mUnit) == noErr);
}

void
AudioStream::Start()
{
  assert(mUnit);
  assert(AudioOutputUnitStart(mUnit) == noErr);
}

void
AudioStream::Stop()
{
  assert(mUnit);
  assert(AudioOutputUnitStop(mUnit) == noErr);
}

void
AudioStream::CreateAudioUnit()
{
  assert(!mUnit); // mUnit should be nullptr before initializing.

  AudioComponentDescription desc;
  desc.componentType = kAudioUnitType_Output;
  desc.componentSubType = kAudioUnitSubType_DefaultOutput;
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;

  AudioComponent comp = AudioComponentFindNext(NULL, &amp;desc);
  assert(comp); // comp will be nullptr if there is no matching audio hardware.

  assert(AudioComponentInstanceNew(comp, &amp;mUnit) == noErr);
  assert(mUnit); // mUnit should NOT be nullptr after initializing.
}

void
AudioStream::SetDescription(Format aFormat)
{
  memset(&amp;mDescription, 0, sizeof(mDescription));
  switch (aFormat) {
    case S16LE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger;
      break;
    case S16BE:
      mDescription.mBitsPerChannel = 16;
      mDescription.mFormatFlags = kAudioFormatFlagIsSignedInteger |
                                  kAudioFormatFlagIsBigEndian;
      break;
    case F32LE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat;
      break;
    case F32BE:
      mDescription.mBitsPerChannel = 32;
      mDescription.mFormatFlags = kAudioFormatFlagIsFloat |
                                  kAudioFormatFlagIsBigEndian;
      break;
    default:
      assert(false);
  }

  // The mFormatFlags below should be set by &quot;|&quot; or operator,
  // or the assigned flags above will be cleared.
  mDescription.mFormatID = kAudioFormatLinearPCM;
  mDescription.mFormatFlags |= kLinearPCMFormatFlagIsPacked;
  mDescription.mSampleRate = mRate;
  mDescription.mChannelsPerFrame = mChannels;

  mDescription.mBytesPerFrame = (mDescription.mBitsPerChannel / 8) *
                                mDescription.mChannelsPerFrame;

  mDescription.mFramesPerPacket = 1;
  mDescription.mBytesPerPacket = mDescription.mBytesPerFrame *
                                 mDescription.mFramesPerPacket;
  mDescription.mReserved = 0;

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_StreamFormat,
                              kAudioUnitScope_Input,
                              AU_OUT_BUS,
                              &amp;mDescription,
                              sizeof(mDescription)) == noErr);
}

void
AudioStream::SetCallback()
{
  AURenderCallbackStruct aurcbs;
  memset(&amp;aurcbs, 0, sizeof(aurcbs));
  aurcbs.inputProc = DataCallback;
  aurcbs.inputProcRefCon = this; // Pass this as callback&#39;s arguments

  assert(AudioUnitSetProperty(mUnit,
                              kAudioUnitProperty_SetRenderCallback,
                              kAudioUnitScope_Global,
                              AU_OUT_BUS,
                              &amp;aurcbs,
                              sizeof(aurcbs)) == noErr);
}

/* static */ OSStatus
AudioStream::DataCallback(void* aRefCon,
                          AudioUnitRenderActionFlags* aActionFlags,
                          const AudioTimeStamp* aTimeStamp,
                          UInt32 aBusNumber,
                          UInt32 aNumFrames,
                          AudioBufferList* aData)
{
  assert(aBusNumber == AU_OUT_BUS);
  assert(aData-&gt;mNumberBuffers == 1);

  AudioStream* as = static_cast&lt;AudioStream*&gt;(aRefCon); // Get arguments
  void* buffer = aData-&gt;mBuffers[0].mData;
  as-&gt;mCallback(buffer, aNumFrames);
  return noErr;
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9.js?file=AudioStream.cpp"> </script>

<p>The key why deadlock happend is that
the audio callback thread holds a mutex(hereafter referred to as <em>Mutex-AU</em>)
shared with <em>AudioUnit</em>.
The <em>Mutex-AU</em> is held inside it’s framework, so you don’t notice it.</p>

<p>Thus, if the callback thread requests another <em>mutex M</em> held by the another
thread, without releasing <em>mutex-AU</em>, then it will cause a deadlock when the
another thread, which holds the <em>mutex M</em>, request to use AudioUnit.</p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock.gif" alt="" /></p>

<p>That is,
if we have a <em>thread T</em>, holding the <em>mutex M</em></p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-1.png" alt="" /></p>

<p>and one <em>callback thread</em> which holds the <em>mutex-AU</em>,</p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-2.png" alt="" /></p>

<p>The deadlock will occur when the <em>callback thread</em> requests the <em>mutex M</em>
(the callback thread is blocked for waiting the <em>mutex M</em>)</p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-3.png" alt="" /></p>

<p>and the <em>thread T</em> requests the <em>mutex-AU</em> to use AudioUnit</p>

<p><img src="https://gist.githubusercontent.com/ChunMinChang/47b8712ed57b96721eec18dede39d2f9/raw/e27ea5d4fcee8cfd58acbdea09e90a40a4cfe5e1/deadlock-4.png" alt="" /></p>


                        <br>

                    
                    
                        <div class="entry-tags text-center">
                            <i class="fa fa-tags"></i>&nbsp;
                                Tagged with 
                            
                                <a href="http://localhost:4000/tags/index.html#CoreAudio" data-toggle="tooltip" title="Posts tagged with CoreAudio" rel="tag">CoreAudio</a>

                                
                            
                        </div>
                    
                    </div>

                    <footer class="post-footer entry-meta">
                    
                        <div class="post-share text-center">
    <p class="light small">
        Share this post
    </p>
    <ul class="social-mini">
        <li>
            <a href="https://twitter.com/intent/tweet?text=Deadlock+when+using+AudioUnit%20http://localhost:4000/post/deadlock-when-using-audiounit%20via%20&#64;"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" data-toggle="tooltip"
                title="Share on Twitter" itemprop="Twitter">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/post/deadlock-when-using-audiounit" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"
                data-toggle="tooltip" title="Share on Facebook" itemprop="Facebook">
                <i class="fa fa-facebook"></i>
            </a>
        </li>
        <li>
            <a href="https://plus.google.com/share?url=http://localhost:4000/post/deadlock-when-using-audiounit" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;"
                data-toggle="tooltip" title="Share on Google plus" itemprop="GooglePlus">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
    </ul>
</div>
                    

                        <div class="post-author text-center">
	<img src="http://localhost:4000/images/chunmin.jpg" alt="Chun-Min Chang's photo" itemprop="image" class="post-avatar img-circle img-responsive" />
	<h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="http://schema.org/Person">
		By <span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About Chun-Min Chang" itemprop="url">Chun-Min Chang</a></span>
	</h4>
	<p>I am a self-directed learner and a maker who enjoys building products from original ideas.</p>
</div> 
                        
                    
                        <div id="disqus_thread"></div><!-- /#disqus_thread -->
                    
                    </footer>

                </article>
            </div>
        </div>
    </div>

    
<footer id="footer" class="blog-background overlay text-center align-middle animated from-top" style="background-image: url(http://localhost:4000/images/background/taiwan_1.jpg)">


    <div class="inner">
        <div class="container">
            <ul class="social-icons">
                    
                <li>
                    <a href="https://www.linkedin.com/in/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on LinkedIn" target="_blank">
                        <i class="fa fa-linkedin"></i>
                    </a>
                </li>
                   
                <li>
                    <a href="http://github.com/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on Github" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </li>
                
            </ul>
            <div>
                <a href="http://localhost:4000/about/">Chun-Min Chang</a> &copy; 2017 &bull;
                All rights reserved.
            </div>
            <ul class="menu-items">
                
                <li>
                    
                    <a href="http://localhost:4000/"><i class="fa fa-home"></i>&nbsp;Home</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/categories"><i class="fa fa-sitemap"></i>&nbsp;Categories</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/tags"><i class="fa fa-tags"></i>&nbsp;Tags</a>&nbsp;&bull;
                    
                </li>
                
                <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
            </ul>
        </div>
    </div>

    
    <div class="decor-wrapper">
        <svg id="footer-decor" class="decor top" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 0 L50 50 L0 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 0 L50 50 L100 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 0 L50 50 L0 33.3" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 0 L50 50 L100 33.3" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>
    

</footer>


    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ="
  crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.12.4.min.js"><\/script>')</script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
  crossorigin="anonymous"></script>

<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jekyll-search.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.fitvids.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.waypoints.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/main.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/script.js"></script>
<script type='text/javascript'>$(document).ready(function(){$(".time").text(function(a,b){return Math.round(parseFloat(b))})});</script>

<script type="text/javascript">

/*      Slides       */

$("a#slide").click(function(){
    $("#sidebar,body,a#slide,#fade").addClass("slide")
});

$("#fade,#header,#posts-container").click(function(){
    $("#sidebar,body,a#slide,#fade").removeClass("slide")
});

$("a#click-filter").click(function(){
    $("#slide-filter").slideToggle("medium");
    $("#slide-pages").slideOut("medium");
});

$("a#click-pages").click(function(){
    $("#slide-pages").slideToggle("medium");
    $("#slide-filter").slideOut("medium");
});

/*      End-Slides      */

</script>


<!-- Jekyll Simple Search option -->
<script>

   SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: 'http://localhost:4000/assets/json/search.json',
        searchResultTemplate: '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
        noResultsText: '<p>Nothing found.</p>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $("#search-close"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


 


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'chunminchang-blog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        
</body>
</html>
