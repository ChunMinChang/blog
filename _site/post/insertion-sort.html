<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">


<meta name="keywords" content="Sorting">


<!-- Begin Jekyll SEO tag v1.3.3 -->
<title>Insertion Sort - Peak Up</title>
<meta property="og:title" content="Insertion Sort" />
<meta name="description" content="Insertion sortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaThe basic concept is similar to Selection Sort.Considering there are two lists. One is already sorted,and the other is unsorted, denoted  and  respectively.The key idea is to pick the element from  one by oneand then insert them into the correct positions of .Suppose we have and :  Step 1          Pick  (which is the first element) from ,and insert it into       Find a position in  such thatall elements before it is less than or equal to and all elements after it is greater than       Start comparing it from the last(maximal) elementto the first(minimal) one in (Or you can do same thing from the first element to the last one)       is greater than , so we keep moving      Next, we found that  is less than       A-ha!  should be inserted between  and       The  and  are updated to and  respectively.        Step 2          Pick the current first element of , ,and insert it into       Same as the previous step, we start comparing  from the maximal elementof  to find the position to insert       is obviously larger than , so we should keep moving      In this step, we can not find any element less than or equal to  afterthe all elements in  are checked      Thus, the  is the minimal value among these elements      We should put  as the first element in       The  and  are updated to and  respectively        Step 3          pick the current first element of , ,and then insert it into       Start comparing  with , we found  is greater      It means that  is the maximal value among these elements      Therefore,  should be inserted at the last position of       The  and  are updated to and  respectively        Step 4           is picked to compare with the elements in .       is greater than , so go next       is equal to , so we stop here      The picked  should be inserted between the existed  and       so the  and  are updated to and  respectively.        Step 5           is picked to insert.       is greater than ,      so it should be put to the last position of       Finally,  is emptyand .      How to find the inserted positionWe can use the following method to find the first elementwhose value is less than or equal to the picked element:,where  is the element needs to be inserted, is the th element in the sorted list ,and  is the length of .After getting the position  given the element ,we need to insert  between  and .(If , then we insert  as the first element .If , then we insert  as the last element .)Dividing one list into unsorted list and sorted listIn implementation, we usually divide the source list  into two parts.One is sorted, the other is unsorted.They are denoted  and  respectively.This is better for memory usage thancreating another list to put the sorted results.Suppose we have ,where  and  are initialized to and .  First round           is picked, but there is nothing could be compared      so we just put it into        and       now         Second round           is picked and       so, we should insert  as the first element and update lists      then  and       now         Third round           is picked and       so we should insert  between  and       then  and       now         Fourth round           is picked and       Thus,  are updated to and .      now         Fifth round           is picked and       so we should put  as the last element of the       then  and       now .        Final round           is picked and       so we should insert  between  and       then  and  is empty      now .      AlgorithmThe above method will divide  into two parts. is sorted, and  is unsorted,where  is the length of .The  will be picked to insert into  iteratively.  When            and       The goal in this round is to insert the  into       The  is picked and compare with       If , then we swap them      Otherwise, do nothing      Then,  is sorted and         When            and       The goal in this round is to insert the  into       The  is picked      If , it means that  is sorted, so we donâ€™t need to do anything      Otherwise(), swap  and and check whether it needs to swap again if       After finishing checking,  is sortedand         When            and       The goal in this round is to insert the  into       The  is picked to compare with the elements one by one in ,from the maximal() to minimal item(), to find a place to insert      After finishing checking,  is sortedand  is         When            and       The goal in this round is to insert the  into       In the same way, the  is sorted after finishing the procedure      so  is updated to  and  is empty      Another method without swappingProofProof by mathematical induction  After each iteration for  in ,  the  is sorted array.We need to prove this statement is true.  when :          Same as the above explanation      The assumption is hold        when :          Assume the statement is hold when        is sorted array        when           If , then  is naturally sortedso the proof is done      Otherwise, the  is swapped with       Now  is sorted and (after swapping!)      Next, we apply this algorithm to  and now       The statement is hold when ,so  is sorted after applying the algorithm      Now  is sorted and , so the proof is done      ComplexityThe time complexity depends on the speed to find the inserted position.The more iterations to find the value of  need,the more time it takes.The worst case is that we need to go through whole  to find correctpositions to insert. It happens when the list is arranged from maximal tominimal values(e.g.,).In this case, if the length of list is , we need to searchtimes to move all the items into .Thus, the complexity is .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::swap#include &lt;cassert&gt;#include &quot;sorting.h&quot;/* * Insertion sort: O(n^2) */void insertionSort(int list[], unsigned int length){  assert(length);  // &lt;-- sorted --&gt;|&lt;-- unsorted --&gt;  // +---+-----+---+---------------+  // | 0 | ... | t | ............  |  // +---+-----+---+---------------+  //             ^  //       tail is the index of last item of sorted list.  for (unsigned int tail = 1 ; tail &lt; length; ++tail) { // list[0] is sorted!    for (unsigned int j = tail; j &gt; 0 &amp;&amp; list[j - 1] &gt; list[j] ; --j) {      std::swap(list[j], list[j - 1]);    }  }}// void insertionSort(int list[], unsigned int length)// {//   assert(length);////   for (unsigned int tail = 1 ; tail &lt; length; ++tail) {//     int current = list[tail];//     unsigned int j = tail;//     while(j &gt; 0 &amp;&amp; list[j-1] &gt; current) {//       list[j] = list[j - 1];//       --j;//     }//     list[j] = current;//   }// }" />
<meta property="og:description" content="Insertion sortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaThe basic concept is similar to Selection Sort.Considering there are two lists. One is already sorted,and the other is unsorted, denoted  and  respectively.The key idea is to pick the element from  one by oneand then insert them into the correct positions of .Suppose we have and :  Step 1          Pick  (which is the first element) from ,and insert it into       Find a position in  such thatall elements before it is less than or equal to and all elements after it is greater than       Start comparing it from the last(maximal) elementto the first(minimal) one in (Or you can do same thing from the first element to the last one)       is greater than , so we keep moving      Next, we found that  is less than       A-ha!  should be inserted between  and       The  and  are updated to and  respectively.        Step 2          Pick the current first element of , ,and insert it into       Same as the previous step, we start comparing  from the maximal elementof  to find the position to insert       is obviously larger than , so we should keep moving      In this step, we can not find any element less than or equal to  afterthe all elements in  are checked      Thus, the  is the minimal value among these elements      We should put  as the first element in       The  and  are updated to and  respectively        Step 3          pick the current first element of , ,and then insert it into       Start comparing  with , we found  is greater      It means that  is the maximal value among these elements      Therefore,  should be inserted at the last position of       The  and  are updated to and  respectively        Step 4           is picked to compare with the elements in .       is greater than , so go next       is equal to , so we stop here      The picked  should be inserted between the existed  and       so the  and  are updated to and  respectively.        Step 5           is picked to insert.       is greater than ,      so it should be put to the last position of       Finally,  is emptyand .      How to find the inserted positionWe can use the following method to find the first elementwhose value is less than or equal to the picked element:,where  is the element needs to be inserted, is the th element in the sorted list ,and  is the length of .After getting the position  given the element ,we need to insert  between  and .(If , then we insert  as the first element .If , then we insert  as the last element .)Dividing one list into unsorted list and sorted listIn implementation, we usually divide the source list  into two parts.One is sorted, the other is unsorted.They are denoted  and  respectively.This is better for memory usage thancreating another list to put the sorted results.Suppose we have ,where  and  are initialized to and .  First round           is picked, but there is nothing could be compared      so we just put it into        and       now         Second round           is picked and       so, we should insert  as the first element and update lists      then  and       now         Third round           is picked and       so we should insert  between  and       then  and       now         Fourth round           is picked and       Thus,  are updated to and .      now         Fifth round           is picked and       so we should put  as the last element of the       then  and       now .        Final round           is picked and       so we should insert  between  and       then  and  is empty      now .      AlgorithmThe above method will divide  into two parts. is sorted, and  is unsorted,where  is the length of .The  will be picked to insert into  iteratively.  When            and       The goal in this round is to insert the  into       The  is picked and compare with       If , then we swap them      Otherwise, do nothing      Then,  is sorted and         When            and       The goal in this round is to insert the  into       The  is picked      If , it means that  is sorted, so we donâ€™t need to do anything      Otherwise(), swap  and and check whether it needs to swap again if       After finishing checking,  is sortedand         When            and       The goal in this round is to insert the  into       The  is picked to compare with the elements one by one in ,from the maximal() to minimal item(), to find a place to insert      After finishing checking,  is sortedand  is         When            and       The goal in this round is to insert the  into       In the same way, the  is sorted after finishing the procedure      so  is updated to  and  is empty      Another method without swappingProofProof by mathematical induction  After each iteration for  in ,  the  is sorted array.We need to prove this statement is true.  when :          Same as the above explanation      The assumption is hold        when :          Assume the statement is hold when        is sorted array        when           If , then  is naturally sortedso the proof is done      Otherwise, the  is swapped with       Now  is sorted and (after swapping!)      Next, we apply this algorithm to  and now       The statement is hold when ,so  is sorted after applying the algorithm      Now  is sorted and , so the proof is done      ComplexityThe time complexity depends on the speed to find the inserted position.The more iterations to find the value of  need,the more time it takes.The worst case is that we need to go through whole  to find correctpositions to insert. It happens when the list is arranged from maximal tominimal values(e.g.,).In this case, if the length of list is , we need to searchtimes to move all the items into .Thus, the complexity is .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::swap#include &lt;cassert&gt;#include &quot;sorting.h&quot;/* * Insertion sort: O(n^2) */void insertionSort(int list[], unsigned int length){  assert(length);  // &lt;-- sorted --&gt;|&lt;-- unsorted --&gt;  // +---+-----+---+---------------+  // | 0 | ... | t | ............  |  // +---+-----+---+---------------+  //             ^  //       tail is the index of last item of sorted list.  for (unsigned int tail = 1 ; tail &lt; length; ++tail) { // list[0] is sorted!    for (unsigned int j = tail; j &gt; 0 &amp;&amp; list[j - 1] &gt; list[j] ; --j) {      std::swap(list[j], list[j - 1]);    }  }}// void insertionSort(int list[], unsigned int length)// {//   assert(length);////   for (unsigned int tail = 1 ; tail &lt; length; ++tail) {//     int current = list[tail];//     unsigned int j = tail;//     while(j &gt; 0 &amp;&amp; list[j-1] &gt; current) {//       list[j] = list[j - 1];//       --j;//     }//     list[j] = current;//   }// }" />
<link rel="canonical" href="http://localhost:4000/post/insertion-sort" />
<meta property="og:url" content="http://localhost:4000/post/insertion-sort" />
<meta property="og:site_name" content="Peak Up" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-12-30T00:00:00+08:00" />
<link rel="next" href="http://localhost:4000/post/bubble-sort" title="Bubble Sort" />
<link rel="prev" href="http://localhost:4000/post/selection-sort" title="Selection Sort" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Insertion Sort",
    "datePublished": "2016-12-30T00:00:00+08:00",
    "description": "Insertion sortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaThe basic concept is similar to Selection Sort.Considering there are two lists. One is already sorted,and the other is unsorted, denoted  and  respectively.The key idea is to pick the element from  one by oneand then insert them into the correct positions of .Suppose we have and :  Step 1          Pick  (which is the first element) from ,and insert it into       Find a position in  such thatall elements before it is less than or equal to and all elements after it is greater than       Start comparing it from the last(maximal) elementto the first(minimal) one in (Or you can do same thing from the first element to the last one)       is greater than , so we keep moving      Next, we found that  is less than       A-ha!  should be inserted between  and       The  and  are updated to and  respectively.        Step 2          Pick the current first element of , ,and insert it into       Same as the previous step, we start comparing  from the maximal elementof  to find the position to insert       is obviously larger than , so we should keep moving      In this step, we can not find any element less than or equal to  afterthe all elements in  are checked      Thus, the  is the minimal value among these elements      We should put  as the first element in       The  and  are updated to and  respectively        Step 3          pick the current first element of , ,and then insert it into       Start comparing  with , we found  is greater      It means that  is the maximal value among these elements      Therefore,  should be inserted at the last position of       The  and  are updated to and  respectively        Step 4           is picked to compare with the elements in .       is greater than , so go next       is equal to , so we stop here      The picked  should be inserted between the existed  and       so the  and  are updated to and  respectively.        Step 5           is picked to insert.       is greater than ,      so it should be put to the last position of       Finally,  is emptyand .      How to find the inserted positionWe can use the following method to find the first elementwhose value is less than or equal to the picked element:,where  is the element needs to be inserted, is the th element in the sorted list ,and  is the length of .After getting the position  given the element ,we need to insert  between  and .(If , then we insert  as the first element .If , then we insert  as the last element .)Dividing one list into unsorted list and sorted listIn implementation, we usually divide the source list  into two parts.One is sorted, the other is unsorted.They are denoted  and  respectively.This is better for memory usage thancreating another list to put the sorted results.Suppose we have ,where  and  are initialized to and .  First round           is picked, but there is nothing could be compared      so we just put it into        and       now         Second round           is picked and       so, we should insert  as the first element and update lists      then  and       now         Third round           is picked and       so we should insert  between  and       then  and       now         Fourth round           is picked and       Thus,  are updated to and .      now         Fifth round           is picked and       so we should put  as the last element of the       then  and       now .        Final round           is picked and       so we should insert  between  and       then  and  is empty      now .      AlgorithmThe above method will divide  into two parts. is sorted, and  is unsorted,where  is the length of .The  will be picked to insert into  iteratively.  When            and       The goal in this round is to insert the  into       The  is picked and compare with       If , then we swap them      Otherwise, do nothing      Then,  is sorted and         When            and       The goal in this round is to insert the  into       The  is picked      If , it means that  is sorted, so we donâ€™t need to do anything      Otherwise(), swap  and and check whether it needs to swap again if       After finishing checking,  is sortedand         When            and       The goal in this round is to insert the  into       The  is picked to compare with the elements one by one in ,from the maximal() to minimal item(), to find a place to insert      After finishing checking,  is sortedand  is         When            and       The goal in this round is to insert the  into       In the same way, the  is sorted after finishing the procedure      so  is updated to  and  is empty      Another method without swappingProofProof by mathematical induction  After each iteration for  in ,  the  is sorted array.We need to prove this statement is true.  when :          Same as the above explanation      The assumption is hold        when :          Assume the statement is hold when        is sorted array        when           If , then  is naturally sortedso the proof is done      Otherwise, the  is swapped with       Now  is sorted and (after swapping!)      Next, we apply this algorithm to  and now       The statement is hold when ,so  is sorted after applying the algorithm      Now  is sorted and , so the proof is done      ComplexityThe time complexity depends on the speed to find the inserted position.The more iterations to find the value of  need,the more time it takes.The worst case is that we need to go through whole  to find correctpositions to insert. It happens when the list is arranged from maximal tominimal values(e.g.,).In this case, if the length of list is , we need to searchtimes to move all the items into .Thus, the complexity is .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::swap#include &lt;cassert&gt;#include &quot;sorting.h&quot;/* * Insertion sort: O(n^2) */void insertionSort(int list[], unsigned int length){  assert(length);  // &lt;-- sorted --&gt;|&lt;-- unsorted --&gt;  // +---+-----+---+---------------+  // | 0 | ... | t | ............  |  // +---+-----+---+---------------+  //             ^  //       tail is the index of last item of sorted list.  for (unsigned int tail = 1 ; tail &lt; length; ++tail) { // list[0] is sorted!    for (unsigned int j = tail; j &gt; 0 &amp;&amp; list[j - 1] &gt; list[j] ; --j) {      std::swap(list[j], list[j - 1]);    }  }}// void insertionSort(int list[], unsigned int length)// {//   assert(length);////   for (unsigned int tail = 1 ; tail &lt; length; ++tail) {//     int current = list[tail];//     unsigned int j = tail;//     while(j &gt; 0 &amp;&amp; list[j-1] &gt; current) {//       list[j] = list[j - 1];//       --j;//     }//     list[j] = current;//   }// }",
    "logo": "http://localhost:4000mountain.png",
    "url": "http://localhost:4000/post/insertion-sort"
  }
</script>
<!-- End Jekyll SEO tag -->

<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Peak Up" />

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
    crossorigin="anonymous">

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/style.css" />
<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/syntax.css" />


<!--Load Mathjax-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
        MathJax.Hub.Config({
            config: ["MMLorHTML.js"],
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: false
            },
            TeX: {
                TagSide: "right",
                TagIndent: ".8em",
                MultLineWidth: "85%",
                equationNumbers: {
                   autoNumber: "AMS",
                },
                unicode: {
                   fonts: "STIXGeneral,'Arial Unicode MS'"
                }
            },
            showProcessingMessages: false
        });
</script>



<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/favicons/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/favicons/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/favicons/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/favicons/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post-template" itemscope itemtype="http://schema.org/WebPage">

    
<div class="search-wrapper">
    <div class="search-form">
        <input type="text" id="search-input" class="search-field" placeholder="Search...">
        <i id="search-close" class="fa fa-times-circle"></i>
        <h4>Search results</h4>
        <ul id="results-container" class="search-results post-list">
        </ul>
        <!-- /.search-results -->
    </div>
    <!-- /.search-form -->
</div>
<!-- ./search-wrapper -->


<div id="fade"></div>
<a id="slide" class="animated fade">
    <i class="fa fa-bars" aria-hidden="true"></i>
</a>
<aside id="sidebar">
    <nav id="navigation">
        <h2>MENU</h2>
        <hr>
        <ul> 
            <li>
                <a href="http://localhost:4000/"><!-- <i class="fa fa-home"></i>&nbsp;-->Home</a>  </li>
            
            <li>
                <a href="http://localhost:4000/categories"><!-- <i class="fa fa-sitemap"></i>&nbsp;-->Categories</a>  </li>
            
            <li>
                <a href="http://localhost:4000/tags"><!-- <i class="fa fa-tags"></i>&nbsp;-->Tags</a>  </li>
            
            <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
        </ul>
    </nav>
</aside>


<header id="masthead" class="blog-background overlay align-center align-middle animated from-bottom" style="background-image: url(http://localhost:4000/images/background/yosemite/yosemite-tiny.jpg)"
    itemscope itemtype="http://schema.org/Organization">



    <button class="menu-button animated fade dosearch">
        <i class="fa fa-search"></i>
    </button>



    <div class="inner">
        <div class="container">
            <a class="brand" href="http://localhost:4000/" itemprop="url">
                <img itemprop="logo" src="http://localhost:4000/images/mountain.png" alt="Peak Up Logo" />
                <h1 class="blog-title light" itemprop="name">
                    Peak Up
                </h1>
            </a>
        </div>
    </div>



    <div class="decor-wrapper">
        <svg id="header-decor" class="decor bottom" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <!-- <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 100 L50 50 L0 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 100 L50 50 L100 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 100 L50 50 L0 66.6" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 100 L50 50 L100 66.6" fill="rgba(255,255,255, .5)"></path> -->
            <path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>

</header>


    <div id="main" class="content" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
        <div class="container">
            <div class="row">
                <article class="post col-md-8 col-md-offset-2 hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
                
                
                
                

                    <header class="post-header entry-header">

                    

                    
                        <h1 class="post-title text-center hyper lighter bordered-bottom entry-title" itemprop="headline">
                        
                            
                        
                        
                        

                        
                            Insertion Sort
                        </h1>
                    

                        <div class="cursive" style="color: #000; font-style:italic;"></div>

                            <div class="post-info text-center small">
                            
                                <span class="entry-date date published updated">
                            
                            
                                    <time datetime="2016-12-30T00:00:00+08:00" class="post-time" itemprop="datePublished">30 Dec 2016</time>
                                </span>
                            

                                in <span class="post-tags">

                            
                                    <a href="http://localhost:4000/categories/index.html#Algorithm" data-toggle="tooltip" title="Other posts from the Algorithm category" rel="tag">Algorithm</a>
                                
                            
                                </span>
                            
                            &nbsp;
                                <span class="post-tags"><i class="fa fa-clock-o"></i>&nbsp;

                            

                            
                                    <span class="time">6.361111111111111</span> minutes read
                            
                                
                            

                                </span>
                            
                            </div>

                    </header>

                    <div class="post-body bordered-bottom" itemprop="description">
                    

                        <h1 id="insertion-sort">Insertion sort</h1>

<p>This post series is synchronized with my book <a href="https://www.gitbook.com/book/chunminchang/codeplay/details" title="CodePlay">CodePlay</a>
and this post could be read <a href="https://chunminchang.gitbooks.io/codeplay/content/sorting/insertion_sort.html" title="Insertion Sort">here</a>.</p>

<h2 id="idea">Idea</h2>
<p>The basic concept is similar to <a href="https://chunminchang.gitbooks.io/codeplay/content/sorting/selection_sort.html" title="Selection Sort"><em>Selection Sort</em></a>.
Considering there are two lists. One is already sorted,
and the other is unsorted, denoted <script type="math/tex">L_{sorted}</script> and <script type="math/tex">L_{unsorted}</script> respectively.
The key idea is to pick the element from <script type="math/tex">L_{unsorted}</script> one by one
and then <strong>insert</strong> them into the correct positions of <script type="math/tex">L_{sorted}</script>.
Suppose we have <script type="math/tex">L_{sorted} = [3, 8, 34]</script>
and <script type="math/tex">L_{unsorted} = [23, 2, 67, 34, 97]</script>:</p>

<ul>
  <li>Step 1
    <ul>
      <li>Pick <script type="math/tex">23</script> (which is the first element) from <script type="math/tex">L_{unsorted}</script>,
and insert it into <script type="math/tex">L_{sorted}</script></li>
      <li>Find a position in <script type="math/tex">L_{sorted}</script> such that
<strong>all elements before it is less than or equal to <script type="math/tex">23</script>
and all elements after it is greater than <script type="math/tex">23</script></strong></li>
      <li>Start comparing it from the <strong>last(maximal)</strong> element
to the <strong>first(minimal)</strong> one in <script type="math/tex">L_{sorted}</script>
(Or you can do same thing from the first element to the last one)</li>
      <li><script type="math/tex">34</script> is greater than <script type="math/tex">23</script>, so we keep moving</li>
      <li>Next, we found that <script type="math/tex">8</script> is less than <script type="math/tex">23</script></li>
      <li>A-ha! <script type="math/tex">23</script> should be inserted between <script type="math/tex">8</script> and <script type="math/tex">34</script></li>
      <li>The <script type="math/tex">L_{sorted}</script> and <script type="math/tex">L_{unsorted}</script> are updated to <script type="math/tex">[3, 8, 23, 34]</script>
and <script type="math/tex">[2, 67, 34, 97]</script> respectively.</li>
    </ul>
  </li>
  <li>Step 2
    <ul>
      <li>Pick the current first element of <script type="math/tex">L_{unsorted}</script>, <script type="math/tex">2</script>,
and insert it into <script type="math/tex">L_{sorted}</script></li>
      <li>Same as the previous step, we start comparing <script type="math/tex">2</script> from the maximal element
of <script type="math/tex">L_{sorted}</script> to find the position to insert</li>
      <li><script type="math/tex">34</script> is obviously larger than <script type="math/tex">2</script>, so we should keep moving</li>
      <li>In this step, we can not find any element less than or equal to <script type="math/tex">2</script> after
the all elements in <script type="math/tex">L_{sorted}</script> are checked</li>
      <li>Thus, the <script type="math/tex">2</script> is the minimal value among these elements</li>
      <li>We should put <script type="math/tex">2</script> as the first element in <script type="math/tex">L_{sorted}</script></li>
      <li>The <script type="math/tex">L_{sorted}</script> and <script type="math/tex">L_{unsorted}</script> are updated to <script type="math/tex">[2, 3, 8, 23, 34]</script>
and <script type="math/tex">[67, 34, 97]</script> respectively</li>
    </ul>
  </li>
  <li>Step 3
    <ul>
      <li>pick the current first element of <script type="math/tex">L_{unsorted}</script>, <script type="math/tex">67</script>,
and then insert it into <script type="math/tex">L_{sorted}</script></li>
      <li>Start comparing <script type="math/tex">67</script> with <script type="math/tex">34</script>, we found <script type="math/tex">67</script> is greater</li>
      <li>It means that <script type="math/tex">67</script> is the maximal value among these elements</li>
      <li>Therefore, <script type="math/tex">67</script> should be inserted at the last position of <script type="math/tex">L_{sorted}</script></li>
      <li>The <script type="math/tex">L_{sorted}</script> and <script type="math/tex">L_{unsorted}</script> are updated to
<script type="math/tex">[2, 3, 8, 23, 34, 67]</script> and <script type="math/tex">[34, 97]</script> respectively</li>
    </ul>
  </li>
  <li>Step 4
    <ul>
      <li><script type="math/tex">34</script> is picked to compare with the elements in <script type="math/tex">L_{sorted}</script>.</li>
      <li><script type="math/tex">67</script> is greater than <script type="math/tex">34</script>, so go next</li>
      <li><script type="math/tex">34</script> is equal to <script type="math/tex">34</script>, so we stop here</li>
      <li>The picked <script type="math/tex">34</script> should be inserted between the existed <script type="math/tex">34</script> and <script type="math/tex">67</script></li>
      <li>so the <script type="math/tex">L_{sorted}</script> and <script type="math/tex">L_{unsorted}</script> are updated to
<script type="math/tex">[2, 3, 8, 23, 34, 34, 67]</script> and <script type="math/tex">[97]</script> respectively.</li>
    </ul>
  </li>
  <li>Step 5
    <ul>
      <li><script type="math/tex">97</script> is picked to insert.</li>
      <li><script type="math/tex">97</script> is greater than <script type="math/tex">67</script>,</li>
      <li>so it should be put to the last position of <script type="math/tex">L_{sorted}</script></li>
      <li>Finally, <script type="math/tex">L_{unsorted}</script> is empty
and <script type="math/tex">L_{sorted} = [2, 3, 8, 23, 34, 34, 67, 97]</script>.</li>
    </ul>
  </li>
</ul>

<h3 id="how-to-find-the-inserted-position">How to find the inserted position</h3>

<p>We can use the following method to find the <strong>first</strong> element
whose value is <strong>less than or equal to</strong> the picked element:
<script type="math/tex">% <![CDATA[
\begin{align}
& \text{Position($L, x$):} \\
& \space \space \space \space i \leftarrow N\\
& \space \space \space \space \text{while $i > 0$ and $L[i] > x$:} \\
& \space \space \space \space \space \space \space \space i \leftarrow i - 1 \\
& \space \space \space \space \text{return} \space i \\
\end{align} %]]></script>
,where <script type="math/tex">x</script> is the element needs to be inserted,
<script type="math/tex">L[i]</script> is the <script type="math/tex">i</script>th element in the sorted list <script type="math/tex">L</script>,
and <script type="math/tex">N = \vert L \vert</script> is the length of <script type="math/tex">L</script>.</p>

<p>After getting the position <script type="math/tex">p = Position(L, x)</script> given the element <script type="math/tex">x</script>,
we need to insert <script type="math/tex">x</script> between <script type="math/tex">L[p]</script> and <script type="math/tex">L[p+1]</script>.
(If <script type="math/tex">p = 0</script>, then we insert <script type="math/tex">x</script> as the first element <script type="math/tex">L[1]</script>.
If <script type="math/tex">p = N</script>, then we insert <script type="math/tex">x</script> as the last element <script type="math/tex">L[p + 1]</script>.)</p>

<h3 id="dividing-one-list-into-unsorted-list-and-sorted-list">Dividing one list into unsorted list and sorted list</h3>

<p>In implementation, we usually divide the source list <script type="math/tex">L</script> into two parts.
One is sorted, the other is unsorted.
They are denoted <script type="math/tex">L_{sorted}</script> and <script type="math/tex">L_{unsorted}</script> respectively.
This is better for memory usage than
creating another list to put the sorted results.</p>

<p>Suppose we have <script type="math/tex">L = [73, 24, 37, 9, 97, 29] = L_{sorted} \cup L_{unsorted}</script>,
where <script type="math/tex">L_{sorted}</script> and <script type="math/tex">L_{unsorted}</script> are initialized to <script type="math/tex">[]</script>
and <script type="math/tex">[73, 24, 37, 9, 97, 29]</script>.</p>

<ul>
  <li>First round
    <ul>
      <li><script type="math/tex">73</script> is picked, but there is nothing could be compared</li>
      <li>so we just put it into <script type="math/tex">L_{sorted}</script></li>
      <li><script type="math/tex">L_{sorted} = [73]</script> and <script type="math/tex">L_{unsorted} = [24, 37, 9, 97, 29]</script></li>
      <li>now <script type="math/tex">L = L_{sorted} \cup L_{unsorted} = [73 \vert 24, 37, 9, 97, 29]</script></li>
    </ul>
  </li>
  <li>Second round
    <ul>
      <li><script type="math/tex">24</script> is picked and <script type="math/tex">p = Position(L_{sorted}, 24) = 0</script></li>
      <li>so, we should insert <script type="math/tex">24</script> as the <strong>first</strong> element and update lists</li>
      <li>then <script type="math/tex">L_{sorted} = [24, 73]</script> and <script type="math/tex">L_{unsorted} = [37, 9, 97, 29]</script></li>
      <li>now <script type="math/tex">L = L_{sorted} \cup L_{unsorted} = [24, 73 \vert 37, 9, 97, 29]</script></li>
    </ul>
  </li>
  <li>Third round
    <ul>
      <li><script type="math/tex">37</script> is picked and <script type="math/tex">p = Position(L_{sorted}, 37) = 1</script></li>
      <li>so we should insert <script type="math/tex">37</script> between <script type="math/tex">L[p] = L[1] = 24</script> and <script type="math/tex">L[p + 1] = L[2] = 73</script></li>
      <li>then <script type="math/tex">L_{sorted} = [24, 37, 73]</script> and <script type="math/tex">L_{unsorted} = [9, 97, 29]</script></li>
      <li>now <script type="math/tex">L = L_{sorted} \cup L_{unsorted} = [24, 37, 73 \vert 9, 97, 29]</script></li>
    </ul>
  </li>
  <li>Fourth round
    <ul>
      <li><script type="math/tex">9</script> is picked and <script type="math/tex">p = Position(L_{sorted}, 9) = 0</script></li>
      <li>Thus, <script type="math/tex">L_{sorted}, L_{unsorted}</script> are updated to
<script type="math/tex">[9, 24, 37, 73]</script> and <script type="math/tex">[97, 29]</script>.</li>
      <li>now <script type="math/tex">L = L_{sorted} \cup L_{unsorted} = [9, 24, 37, 73 \vert 97, 29]</script></li>
    </ul>
  </li>
  <li>Fifth round
    <ul>
      <li><script type="math/tex">97</script> is picked and <script type="math/tex">p = Position(L_{sorted}, 97) = 4 = \vert L_{sorted} \vert</script></li>
      <li>so we should put <script type="math/tex">97</script> as the <strong>last</strong> element of the <script type="math/tex">L_{sorted}</script></li>
      <li>then <script type="math/tex">L_{sorted} = [9, 24, 37, 73, 97]</script> and <script type="math/tex">L_{unsorted} = [29]</script></li>
      <li>now <script type="math/tex">L = L_{sorted} \cup L_{unsorted} = [9, 24, 37, 73, 97 \vert 29]</script>.</li>
    </ul>
  </li>
  <li>Final round
    <ul>
      <li><script type="math/tex">29</script> is picked and <script type="math/tex">p = Position(L_{sorted}, 29) = 2</script></li>
      <li>so we should insert <script type="math/tex">29</script> between <script type="math/tex">L[p] = L[2] = 24</script> and <script type="math/tex">L[p + 1] = L[3] = 37</script></li>
      <li>then <script type="math/tex">L_{sorted} = [9, 24, 29, 37, 73, 97]</script> and <script type="math/tex">L_{unsorted} = []</script> is empty</li>
      <li>now <script type="math/tex">L = L_{sorted} \cup L_{unsorted} = [9, 24, 29, 37, 73, 97]</script>.</li>
    </ul>
  </li>
</ul>

<h2 id="algorithm">Algorithm</h2>
<p><script type="math/tex">% <![CDATA[
\begin{align}
& \text{InsertionSort($L$):} \\
& \space \space \space \space \text{for $i \leftarrow 2$ to $\vert L \vert$:} \\
& \space \space \space \space \space \space \space \space j \leftarrow i\\
& \space \space \space \space \space \space \space \space \text{while $j > 1$ and $L[j-1] > L[j]$:} \\
& \space \space \space \space \space \space \space \space \space \space \space \space \text{swap $L[j-1]$ and $L[j]$} \\
& \space \space \space \space \space \space \space \space \space \space \space \space j \leftarrow j - 1 \\
\end{align} %]]></script></p>

<p>The above method will divide <script type="math/tex">L</script> into two parts.
<script type="math/tex">L[1...i-1] = L_{sorted}</script> is sorted, and <script type="math/tex">L[i...N] = L_{unsorted}</script> is unsorted,
where <script type="math/tex">N = \vert L \vert</script> is the length of <script type="math/tex">L</script>.
The <script type="math/tex">L[i]</script> will be picked to insert into <script type="math/tex">L_{sorted}</script> iteratively.</p>

<ul>
  <li>When <script type="math/tex">i = 2</script>
    <ul>
      <li><script type="math/tex">L_{sorted} = L[1]</script> and <script type="math/tex">L_{unsorted} = L[2...N]</script></li>
      <li>The goal in this round is to insert the <script type="math/tex">L[2]</script> into <script type="math/tex">L_{sorted}</script></li>
      <li>The <script type="math/tex">L[2]</script> is picked and compare with <script type="math/tex">L[1]</script></li>
      <li>If <script type="math/tex">% <![CDATA[
L[2] < L[1] %]]></script>, then we swap them</li>
      <li>Otherwise, do nothing</li>
      <li>Then, <script type="math/tex">L_{sorted} = L[1...2]</script> is sorted and <script type="math/tex">L_{unsorted} = L[3...N]</script></li>
    </ul>
  </li>
  <li>When <script type="math/tex">i = 3</script>
    <ul>
      <li><script type="math/tex">L_{sorted} = L[1...2]</script> and <script type="math/tex">L_{unsorted} = L[3...N]</script></li>
      <li>The goal in this round is to insert the <script type="math/tex">L[3]</script> into <script type="math/tex">L_{sorted}</script></li>
      <li>The <script type="math/tex">L[3]</script> is picked</li>
      <li>If <script type="math/tex">L[3] >= L[2]</script>, it means that <script type="math/tex">L[1...3]</script> is sorted, so we donâ€™t need to do anything</li>
      <li>Otherwise(<script type="math/tex">% <![CDATA[
L[3] < L[2] %]]></script>), swap <script type="math/tex">L[3]</script> and <script type="math/tex">L[2]</script>
and check whether it needs to swap again if <script type="math/tex">% <![CDATA[
L[2] < L[1] %]]></script></li>
      <li>After finishing checking, <script type="math/tex">L_{sorted} = L[1...3]</script> is sorted
and <script type="math/tex">L_{unsorted} = L[4...N]</script></li>
    </ul>
  </li>
  <li>When <script type="math/tex">i = k</script>
    <ul>
      <li><script type="math/tex">L_{sorted} = L[1...k-1]</script> and <script type="math/tex">L_{unsorted} = L[k...N]</script></li>
      <li>The goal in this round is to insert the <script type="math/tex">L[k]</script> into <script type="math/tex">L_{sorted}</script></li>
      <li>The <script type="math/tex">L[k]</script> is picked to compare with the elements one by one in <script type="math/tex">L_{sorted}</script>,
from the maximal(<script type="math/tex">L[k-1]</script>) to minimal item(<script type="math/tex">L[1]</script>), to find a place to insert</li>
      <li>After finishing checking, <script type="math/tex">L_{sorted} = L[1...k]</script> is sorted
and <script type="math/tex">L_{unsorted}</script> is <script type="math/tex">L[k+1...N]</script></li>
    </ul>
  </li>
  <li>When <script type="math/tex">i = N</script>
    <ul>
      <li><script type="math/tex">L_{sorted} = L[1...N-1]</script> and <script type="math/tex">L_{unsorted} = L[N]</script></li>
      <li>The goal in this round is to insert the <script type="math/tex">L[N]</script> into <script type="math/tex">L_{sorted}</script></li>
      <li>In the same way, the <script type="math/tex">L[1...N]</script> is sorted after finishing the procedure</li>
      <li>so <script type="math/tex">L_{sorted}</script> is updated to <script type="math/tex">L[1...N]</script> and <script type="math/tex">L_{unsorted} = []</script> is empty</li>
    </ul>
  </li>
</ul>

<h3 id="another-method-without-swapping">Another method without swapping</h3>
<p><script type="math/tex">% <![CDATA[
\begin{align}
& \text{InsertionSort($L$):} \\
& \space \space \space \space \text{for $i \leftarrow 2$ to $\vert L \vert$:} \\
& \space \space \space \space \space \space \space \space c \leftarrow L[i] \\
& \space \space \space \space \space \space \space \space j \leftarrow i \\
& \space \space \space \space \space \space \space \space \text{while $j > 1$ and $L[j-1] > c$:} \\
& \space \space \space \space \space \space \space \space \space \space \space \space L[j] = L[j-1] \\
& \space \space \space \space \space \space \space \space \space \space \space \space j = j - 1 \\
& \space \space \space \space \space \space \space \space L[j] = c \\
\end{align} %]]></script></p>

<h3 id="proof">Proof</h3>

<h4 id="proof-by-mathematical-induction">Proof by mathematical induction</h4>

<blockquote>
  <p>After each iteration for <script type="math/tex">i</script> in <script type="math/tex">InsertionSort</script>,
  the <script type="math/tex">L[1...i]</script> is sorted array.</p>
</blockquote>

<p>We need to prove this statement is true.</p>

<ul>
  <li>when <script type="math/tex">i = 2</script>:
    <ul>
      <li>Same as the above explanation</li>
      <li>The assumption is hold</li>
    </ul>
  </li>
  <li>when <script type="math/tex">i = k</script>:
    <ul>
      <li>Assume the statement is hold when <script type="math/tex">i = k</script></li>
      <li><script type="math/tex">L[1...k]</script> is sorted array</li>
    </ul>
  </li>
  <li>when <script type="math/tex">i = k + 1</script>
    <ul>
      <li>If <script type="math/tex">L[k + 1] > L[k]</script>, then <script type="math/tex">L[1...k + 1]</script> is naturally sorted
so the proof is done</li>
      <li>Otherwise, the <script type="math/tex">L[k + 1]</script> is swapped with <script type="math/tex">L[k]</script></li>
      <li>Now <script type="math/tex">L[1...k-1]</script> is sorted and <script type="math/tex">L[k + 1] > L[k]</script>(after swapping!)</li>
      <li>Next, we apply this algorithm to <script type="math/tex">L = L[1...k-1] \cup L[k]</script> and now <script type="math/tex">i = k</script></li>
      <li>The statement is hold when <script type="math/tex">i = k</script>,
so <script type="math/tex">L[1...k]</script> is sorted after applying the algorithm</li>
      <li>Now <script type="math/tex">L[1...k]</script> is sorted and <script type="math/tex">L[k + 1] > L[k]</script>, so the proof is done</li>
    </ul>
  </li>
</ul>

<h2 id="complexity">Complexity</h2>
<p>The time complexity depends on the speed to find the inserted position.
The more iterations to find the value of <script type="math/tex">Position(L, x)</script> need,
the more time it takes.
The worst case is that we need to go through whole <script type="math/tex">L_{sorted}</script> to find correct
positions to insert. It happens when the list is arranged from maximal to
minimal values(e.g.,<script type="math/tex">[5, 4, 3, 2, 1]</script>).
In this case, if the length of list is <script type="math/tex">N</script>, we need to search
<script type="math/tex">% <![CDATA[
\begin{align}
0 + 1 + 2 + ... + (N - 1)
&= \frac{ N \cdot (N - 1) }{ 2 } \\
&= \frac{ 1 }{ 2 } \cdot N^2 - \frac{ 1 }{ 2 } N
\end{align} %]]></script>
times to move all the items into <script type="math/tex">L_{sorted}</script>.
Thus, the complexity is <script type="math/tex">\mathcal{O}(N^2)</script>.</p>

<h2 id="implementation">Implementation</h2>

<p>See the files on <a href="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb" title="Sorting">gist here</a>.</p>

<noscript><pre>#include &lt;algorithm&gt;  // for std::swap
#include &lt;cassert&gt;
#include &quot;sorting.h&quot;

/*
 * Insertion sort: O(n^2)
 */
void insertionSort(int list[], unsigned int length)
{
  assert(length);

  // &lt;-- sorted --&gt;|&lt;-- unsorted --&gt;
  // +---+-----+---+---------------+
  // | 0 | ... | t | ............  |
  // +---+-----+---+---------------+
  //             ^
  //       tail is the index of last item of sorted list.
  for (unsigned int tail = 1 ; tail &lt; length; ++tail) { // list[0] is sorted!
    for (unsigned int j = tail; j &gt; 0 &amp;&amp; list[j - 1] &gt; list[j] ; --j) {
      std::swap(list[j], list[j - 1]);
    }
  }
}

// void insertionSort(int list[], unsigned int length)
// {
//   assert(length);
//
//   for (unsigned int tail = 1 ; tail &lt; length; ++tail) {
//     int current = list[tail];
//     unsigned int j = tail;
//     while(j &gt; 0 &amp;&amp; list[j-1] &gt; current) {
//       list[j] = list[j - 1];
//       --j;
//     }
//     list[j] = current;
//   }
// }
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=insertion_sort.cpp"> </script>



                        <br>

                    
                    
                        <div class="entry-tags text-center">
                            <i class="fa fa-tags"></i>&nbsp;
                                Tagged with 
                            
                                <a href="http://localhost:4000/tags/index.html#Sorting" data-toggle="tooltip" title="Posts tagged with Sorting" rel="tag">Sorting</a>

                                
                            
                        </div>
                    
                    </div>

                    <footer class="post-footer entry-meta">
                    
                        <div class="post-share text-center">
    <p class="light small">
        Share this post
    </p>
    <ul class="social-mini">
        <li>
            <a href="https://twitter.com/intent/tweet?text=Insertion+Sort%20http://localhost:4000/post/insertion-sort%20via%20&#64;"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" data-toggle="tooltip"
                title="Share on Twitter" itemprop="Twitter">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/post/insertion-sort" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"
                data-toggle="tooltip" title="Share on Facebook" itemprop="Facebook">
                <i class="fa fa-facebook"></i>
            </a>
        </li>
        <li>
            <a href="https://plus.google.com/share?url=http://localhost:4000/post/insertion-sort" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;"
                data-toggle="tooltip" title="Share on Google plus" itemprop="GooglePlus">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
    </ul>
</div>
                    

                        <div class="post-author text-center">
	<img src="http://localhost:4000/images/yosemite.png" alt="Chun-Min Chang's photo" itemprop="image" class="post-avatar img-circle img-responsive" />
	<h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="http://schema.org/Person">
		By <span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About Chun-Min Chang" itemprop="url">Chun-Min Chang</a></span>
	</h4>
	<p>I am a self-directed learner and a maker who enjoys building products from original ideas.</p>
</div> 
                        
                    
                        <div id="disqus_thread"></div><!-- /#disqus_thread -->
                    
                    </footer>

                </article>
            </div>
        </div>
    </div>

    
<footer id="footer" class="blog-background overlay text-center align-middle animated from-top" style="background-image: url(http://localhost:4000/images/background/yosemite/yosemite-tiny.jpg)">


    <div class="inner">
        <div class="container">
            <ul class="social-icons">
                    
                <li>
                    <a href="https://www.linkedin.com/in/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on LinkedIn" target="_blank">
                        <i class="fa fa-linkedin"></i>
                    </a>
                </li>
                   
                <li>
                    <a href="http://github.com/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on Github" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </li>
                
            </ul>
            <div>
                <a href="http://localhost:4000/about/">Chun-Min Chang</a> &copy; 2018 &bull;
                All rights reserved.
            </div>
            <ul class="menu-items">
                
                <li>
                    
                    <a href="http://localhost:4000/"><i class="fa fa-home"></i>&nbsp;Home</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/categories"><i class="fa fa-sitemap"></i>&nbsp;Categories</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/tags"><i class="fa fa-tags"></i>&nbsp;Tags</a>&nbsp;&bull;
                    
                </li>
                
                <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
            </ul>
        </div>
    </div>

    
    <div class="decor-wrapper">
        <svg id="footer-decor" class="decor top" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <!-- <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 0 L50 50 L0 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 0 L50 50 L100 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 0 L50 50 L0 33.3" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 0 L50 50 L100 33.3" fill="rgba(255,255,255, .5)"></path> -->
            <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>
    

</footer>


    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ="
  crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.12.4.min.js"><\/script>')</script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
  crossorigin="anonymous"></script>

<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jekyll-search.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.fitvids.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.waypoints.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/main.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/script.js"></script>
<script type='text/javascript'>$(document).ready(function(){$(".time").text(function(a,b){return Math.round(parseFloat(b))})});</script>

<script type="text/javascript">

/*      Slides       */

$("a#slide").click(function(){
    $("#sidebar,body,a#slide,#fade").addClass("slide")
});

$("#fade,#header,#posts-container").click(function(){
    $("#sidebar,body,a#slide,#fade").removeClass("slide")
});

$("a#click-filter").click(function(){
    $("#slide-filter").slideToggle("medium");
    $("#slide-pages").slideOut("medium");
});

$("a#click-pages").click(function(){
    $("#slide-pages").slideToggle("medium");
    $("#slide-filter").slideOut("medium");
});

/*      End-Slides      */

</script>


<!-- Jekyll Simple Search option -->
<script>

   SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: 'http://localhost:4000/assets/json/search.json',
        searchResultTemplate: '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
        noResultsText: '<p>Nothing found.</p>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $("#search-close"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


 


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'chunminchang-blog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        
</body>
</html>
