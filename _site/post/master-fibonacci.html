<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">


<meta name="keywords" content="Fibonacci, Recursion, Dynamic Programming">


<!-- Begin Jekyll SEO tag v1.3.3 -->
<title>Master Fibonacci - Peak Up</title>
<meta property="og:title" content="Master Fibonacci" />
<meta name="description" content="The Fibonacci number is defined as:where .It can be directly written into the following most common codewhen we learned what the recursion is:///////////////////////////////////////////////////////////////////////////////// Recursive: O(2^n)uint64_t fibonacci(unsigned int n){  return (n &lt;= 1) ? n : fibonacci(n-1) + fibonacci(n-2);}However, if you try calculating ,then you will wait a long long time to get the resultsince it has so many overlapping processes.For example, if we calculate ,then there are duplicated calculations(overlapping substructures) for :The larger  is, the more overlapping processes we have.As a result, the time-complexity is .MemoizationTo avoid that, we can use a cache to save all the resultsand check it first before any calculation,so all the  we need, for ,will be computed just once.Therefore, the time complexity can be shorten to .///////////////////////////////////////////////////////////////////////////////// Recursive with memoization: O(n)std::vector&lt;uint64_t&gt; mem = { 0, 1 }; // F(k) = mem[k], F(0) = 0, F(1) = 1.uint64_t fibonacci(unsigned int n){  if (n + 1 &gt; mem.size()) { // if n is not calculated yet    mem.push_back(fibonacci(n-1) + fibonacci(n-2));  }  return mem[n];}Dynamic programmingThe above implementation needs extra space to save the results,and pay time for memory allocation.If we iteratively calculate from  to , , … then we can get without extra memory:The above implementation needs extra space to save the results,and pay time for memory allocation.If we iteratively calculate from  to , , …,to ,  or , then we can use only three or four variables to get :///////////////////////////////////////////////////////////////////////////////// Dynamic programming: O(n)uint64_t fibonacci(unsigned int n){  uint64_t a = 0, b = 1; // a = F(k), b = F(k+1), k = 0 now.  for (unsigned int k = 1 ; k &lt;= n ; ++k) { // loop k from 1 to n.    std::swap(a, b); // a = F(k+1), b = F(k)    b += a; // b = F(k) + F(k+1) = F(k+2)  }  return a;}or///////////////////////////////////////////////////////////////////////////////// Dynamic programming: O(n)uint64_t fibonacci(unsigned int n){  uint64_t a = 0, b = 1, sum = 0; // a = F(0), b = F(1)  for (unsigned int i = 1 ; i &lt; n ; ++i) { // run if n &gt;= 2    sum = a + b; // sum = F(i+1)    a = b;       // a = F(i)    b = sum;     // b = F(i+1)  }  // Now, i = n, sum = F(n), a = F(n-1), b = F(n)  return (n &lt; 2) ? n : sum;}They also run in  with less memory consumptionthan memoization approach.Furthermore, they avoid the memory overhead for the activation recordson the stack segment/space for the recursions.(The recursion will call itself multiple times,so it will push multiple activation records for the same function itself,with different arguments, into the stack segment/spaceof the process loading the program.)Closed-formIn fact, the Fibonacci number can be calculated by the following formula:(Please readthis postto know how it’s derived.)///////////////////////////////////////////////////////////////////////////////// closed-form: O(log(n))//   Theoretically, the power of n could be done in O(log(n)), but it&#39;s//   complicated to calculate the floating numbers.uint64_t fibonacci(unsigned int n){  // double sqrt5 = sqrt((double)5);  double sqrt5 = 2.2360679775;  return (pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n)) / sqrt5;}Its time-complexity depends on how the power of  is calculated.It could be done in  time(we will explain it below).However, the floating point operations limit the calculable number of ,and it might block the performance.Matrix AlgebraThe Fibonacci numbers can be written into the following matrix:, so it could be easily expanded by the same rule:(Please readthis postfor more discussion.)That is, the Fibonacci matrix turns into a perfect power.Applyingexponentiation by squaring:, we could implement the above idea to:///////////////////////////////////////////////////////////////////////////////// Power by matrix exponentiation: O(log(n))// Matrix A://  &lt;---  cols: n  ---&gt;// +-                 -+// | A11, A12, ... A1n |   ^// | A21, A22, ... A2n |   |// | ...               | rows: m// | ...               |   |// | Am1, Am2, ... Amn |   v// +-                 -+class Matrix{public:  Matrix(unsigned int r, unsigned int c,         std::vector&lt;std::vector&lt;uint64_t&gt;&gt; d)    : rows(r)    , cols(c)    , data(d)  {  }  Matrix(unsigned int r, unsigned int c)    : rows(r)    , cols(c)  {    assert(rows &amp;&amp; cols);    data.resize(rows);    for (unsigned int i = 0 ; i &lt; rows ; ++i) {      data[i].resize(cols);    }  }  ~Matrix()  {  }  uint64_t Read(unsigned int r, unsigned int c)  {    return data[r][c];  }  // friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; m)  // {  //   for (unsigned int i = 0; i &lt; m.rows; ++i) {  //     for (unsigned int j = 0; j &lt; m.cols; ++j) {  //       os &lt;&lt; m.data[i][j] &lt;&lt; &quot; &quot;;  //     }  //     os &lt;&lt; std::endl;  //   }  //   return os;  // }  Matrix operator*(const Matrix&amp; other)  {    assert(cols == other.rows); // Check if they can be multiplied.    Matrix z(rows, other.cols);    for (unsigned int i = 0 ; i &lt; rows ; ++i) {      for (unsigned int j = 0 ; j &lt; other.cols; ++j) {        for (unsigned int k = 0 ; k &lt; cols; ++k) {          z.data[i][j] += data[i][k] * other.data[k][j];        }      }    }    return z;  }  // Calculate the power by fast doubling:  //   k ^ n = (k^2) ^ (n/2)          , if n is even  //        or k * (k^2) ^ ((k-1)/2)  , if n is odd  Matrix pow(unsigned int n)  {    Matrix k(*this); // Copy constructor = Matrix x(rows, cols, data);    Matrix r = Identity(rows);    while (n) {      if (/*n % 2*/n &amp; 1) {        r = r * k;      }      k = k * k;      /*n /= 2*/n &gt;&gt;= 1;    }    return r;  }private:  Matrix Identity(unsigned int size)  {    Matrix z(size, size);    for (unsigned int i = 0 ; i &lt; size ; ++i) {      z.data[i][i] = 1;    }    return z;  }  unsigned int rows;  unsigned int cols;  std::vector&lt;std::vector&lt;uint64_t&gt;&gt; data;};// The Fibonacci matrix can be written into the following equation:// +-             -+   +-    -+^n// | F(n+1)   F(n) |   | 1  1 |// |               | = |      |// | F(n)   F(n-1) |   | 1  0 |// +-             -+   +-    -+uint64_t fibonacci(unsigned int n){  Matrix F { 2, 2, {    { 1, 1 },    { 1, 0 }  } };  // Using F.data[0][1] since n might be 0.  // (we need to power by n - 1 if we return F.data[0][0].)  F = F.pow(n);  return F.Read(0, 1);}Its time-complexity is  by halving and halving.Without the floating point operations,the  could be larger than using the closed-form approach.To make it faster, you can use native array instead of std::vector,but you need to manage the memory usage by yourself.Please readthis postto know how to do it.Fast doublingThe following equations:can be derived by applying  to the above Fibonacci matrix:Hence, we could calculate  by:As a consequence, we could use to compute  by the following program:(Please readthis postto know how the code is derived.)uint64_t fibonacci(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  // There is only one `1` in the bits of `mask`. The `1`&#39;s position is same as  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right  // iteratively to do `AND` operation with `n` to check `n / 2^j` is odd  // or even.  for (unsigned int mask = 1 &lt;&lt; (h - 1) ; mask ; mask &gt;&gt;= 1) { // Run h times!    // Let j = h-i (looping from i = 1 to i = h),    // n_j = floor(n / 2^j) = n &gt;&gt; j (n_j = n when j = 0), k = floor(n_j / 2),    // then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (mask &amp; n) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;        //   F(n_j) = F(2k + 1)      b = c + d;    //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)    } else {        // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;        //   F(n_j) = F(2k)      b = d;        //   F(n_j + 1) = F(2k + 1)    }  }  return a;}Its time-complexity is also  by halving and halving.In contrast to matrix algebra approach,there is no need for using matrixthat contains the duplicated ,so it will be faster.Performance            Approach                                          Recursive      7440.61                                   Memoization      0.034841      3.03045      3.05931      6.10806              Dynamic programming      0.000508      0.052462      0.05395      0.1069              Closed-form      0.030075                                   Matrix Algebra      0.02013      0.052985      0.052427      0.050423              Fast doubling      0.000446      0.000737      0.000785      0.000724      The above results are the time in millisecond for calculating .It will take too long time to get the results from the recursive approach,so we skip it.The closed-form approach is also ignoredsince the floating point operations only workwhen  in above implementation.ConclusionAlthough the performance is platform-dependent,it still indicates that:  The fast doubling approach is always the fastest wayand its performance is far far better than others.  The dynamic programming approach is faster than matrix algebra onewhen  is small ( here),but slower when  is large.  Therefore, if you are pretty sure you have a small ,and the bottleneck of your algorithm doesn’t depend onthe Fibonacci calculation, then dynamic programming is acceptableand it’s easier to implement.This post is the end of my journey for the Fibonacci calculation.Hope you enjoyed.All the above code are uploaded to gist here.Please clone them to play with it.I will start another journey for other interesting topics soon.Stay tuned!" />
<meta property="og:description" content="The Fibonacci number is defined as:where .It can be directly written into the following most common codewhen we learned what the recursion is:///////////////////////////////////////////////////////////////////////////////// Recursive: O(2^n)uint64_t fibonacci(unsigned int n){  return (n &lt;= 1) ? n : fibonacci(n-1) + fibonacci(n-2);}However, if you try calculating ,then you will wait a long long time to get the resultsince it has so many overlapping processes.For example, if we calculate ,then there are duplicated calculations(overlapping substructures) for :The larger  is, the more overlapping processes we have.As a result, the time-complexity is .MemoizationTo avoid that, we can use a cache to save all the resultsand check it first before any calculation,so all the  we need, for ,will be computed just once.Therefore, the time complexity can be shorten to .///////////////////////////////////////////////////////////////////////////////// Recursive with memoization: O(n)std::vector&lt;uint64_t&gt; mem = { 0, 1 }; // F(k) = mem[k], F(0) = 0, F(1) = 1.uint64_t fibonacci(unsigned int n){  if (n + 1 &gt; mem.size()) { // if n is not calculated yet    mem.push_back(fibonacci(n-1) + fibonacci(n-2));  }  return mem[n];}Dynamic programmingThe above implementation needs extra space to save the results,and pay time for memory allocation.If we iteratively calculate from  to , , … then we can get without extra memory:The above implementation needs extra space to save the results,and pay time for memory allocation.If we iteratively calculate from  to , , …,to ,  or , then we can use only three or four variables to get :///////////////////////////////////////////////////////////////////////////////// Dynamic programming: O(n)uint64_t fibonacci(unsigned int n){  uint64_t a = 0, b = 1; // a = F(k), b = F(k+1), k = 0 now.  for (unsigned int k = 1 ; k &lt;= n ; ++k) { // loop k from 1 to n.    std::swap(a, b); // a = F(k+1), b = F(k)    b += a; // b = F(k) + F(k+1) = F(k+2)  }  return a;}or///////////////////////////////////////////////////////////////////////////////// Dynamic programming: O(n)uint64_t fibonacci(unsigned int n){  uint64_t a = 0, b = 1, sum = 0; // a = F(0), b = F(1)  for (unsigned int i = 1 ; i &lt; n ; ++i) { // run if n &gt;= 2    sum = a + b; // sum = F(i+1)    a = b;       // a = F(i)    b = sum;     // b = F(i+1)  }  // Now, i = n, sum = F(n), a = F(n-1), b = F(n)  return (n &lt; 2) ? n : sum;}They also run in  with less memory consumptionthan memoization approach.Furthermore, they avoid the memory overhead for the activation recordson the stack segment/space for the recursions.(The recursion will call itself multiple times,so it will push multiple activation records for the same function itself,with different arguments, into the stack segment/spaceof the process loading the program.)Closed-formIn fact, the Fibonacci number can be calculated by the following formula:(Please readthis postto know how it’s derived.)///////////////////////////////////////////////////////////////////////////////// closed-form: O(log(n))//   Theoretically, the power of n could be done in O(log(n)), but it&#39;s//   complicated to calculate the floating numbers.uint64_t fibonacci(unsigned int n){  // double sqrt5 = sqrt((double)5);  double sqrt5 = 2.2360679775;  return (pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n)) / sqrt5;}Its time-complexity depends on how the power of  is calculated.It could be done in  time(we will explain it below).However, the floating point operations limit the calculable number of ,and it might block the performance.Matrix AlgebraThe Fibonacci numbers can be written into the following matrix:, so it could be easily expanded by the same rule:(Please readthis postfor more discussion.)That is, the Fibonacci matrix turns into a perfect power.Applyingexponentiation by squaring:, we could implement the above idea to:///////////////////////////////////////////////////////////////////////////////// Power by matrix exponentiation: O(log(n))// Matrix A://  &lt;---  cols: n  ---&gt;// +-                 -+// | A11, A12, ... A1n |   ^// | A21, A22, ... A2n |   |// | ...               | rows: m// | ...               |   |// | Am1, Am2, ... Amn |   v// +-                 -+class Matrix{public:  Matrix(unsigned int r, unsigned int c,         std::vector&lt;std::vector&lt;uint64_t&gt;&gt; d)    : rows(r)    , cols(c)    , data(d)  {  }  Matrix(unsigned int r, unsigned int c)    : rows(r)    , cols(c)  {    assert(rows &amp;&amp; cols);    data.resize(rows);    for (unsigned int i = 0 ; i &lt; rows ; ++i) {      data[i].resize(cols);    }  }  ~Matrix()  {  }  uint64_t Read(unsigned int r, unsigned int c)  {    return data[r][c];  }  // friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; m)  // {  //   for (unsigned int i = 0; i &lt; m.rows; ++i) {  //     for (unsigned int j = 0; j &lt; m.cols; ++j) {  //       os &lt;&lt; m.data[i][j] &lt;&lt; &quot; &quot;;  //     }  //     os &lt;&lt; std::endl;  //   }  //   return os;  // }  Matrix operator*(const Matrix&amp; other)  {    assert(cols == other.rows); // Check if they can be multiplied.    Matrix z(rows, other.cols);    for (unsigned int i = 0 ; i &lt; rows ; ++i) {      for (unsigned int j = 0 ; j &lt; other.cols; ++j) {        for (unsigned int k = 0 ; k &lt; cols; ++k) {          z.data[i][j] += data[i][k] * other.data[k][j];        }      }    }    return z;  }  // Calculate the power by fast doubling:  //   k ^ n = (k^2) ^ (n/2)          , if n is even  //        or k * (k^2) ^ ((k-1)/2)  , if n is odd  Matrix pow(unsigned int n)  {    Matrix k(*this); // Copy constructor = Matrix x(rows, cols, data);    Matrix r = Identity(rows);    while (n) {      if (/*n % 2*/n &amp; 1) {        r = r * k;      }      k = k * k;      /*n /= 2*/n &gt;&gt;= 1;    }    return r;  }private:  Matrix Identity(unsigned int size)  {    Matrix z(size, size);    for (unsigned int i = 0 ; i &lt; size ; ++i) {      z.data[i][i] = 1;    }    return z;  }  unsigned int rows;  unsigned int cols;  std::vector&lt;std::vector&lt;uint64_t&gt;&gt; data;};// The Fibonacci matrix can be written into the following equation:// +-             -+   +-    -+^n// | F(n+1)   F(n) |   | 1  1 |// |               | = |      |// | F(n)   F(n-1) |   | 1  0 |// +-             -+   +-    -+uint64_t fibonacci(unsigned int n){  Matrix F { 2, 2, {    { 1, 1 },    { 1, 0 }  } };  // Using F.data[0][1] since n might be 0.  // (we need to power by n - 1 if we return F.data[0][0].)  F = F.pow(n);  return F.Read(0, 1);}Its time-complexity is  by halving and halving.Without the floating point operations,the  could be larger than using the closed-form approach.To make it faster, you can use native array instead of std::vector,but you need to manage the memory usage by yourself.Please readthis postto know how to do it.Fast doublingThe following equations:can be derived by applying  to the above Fibonacci matrix:Hence, we could calculate  by:As a consequence, we could use to compute  by the following program:(Please readthis postto know how the code is derived.)uint64_t fibonacci(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  // There is only one `1` in the bits of `mask`. The `1`&#39;s position is same as  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right  // iteratively to do `AND` operation with `n` to check `n / 2^j` is odd  // or even.  for (unsigned int mask = 1 &lt;&lt; (h - 1) ; mask ; mask &gt;&gt;= 1) { // Run h times!    // Let j = h-i (looping from i = 1 to i = h),    // n_j = floor(n / 2^j) = n &gt;&gt; j (n_j = n when j = 0), k = floor(n_j / 2),    // then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (mask &amp; n) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;        //   F(n_j) = F(2k + 1)      b = c + d;    //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)    } else {        // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;        //   F(n_j) = F(2k)      b = d;        //   F(n_j + 1) = F(2k + 1)    }  }  return a;}Its time-complexity is also  by halving and halving.In contrast to matrix algebra approach,there is no need for using matrixthat contains the duplicated ,so it will be faster.Performance            Approach                                          Recursive      7440.61                                   Memoization      0.034841      3.03045      3.05931      6.10806              Dynamic programming      0.000508      0.052462      0.05395      0.1069              Closed-form      0.030075                                   Matrix Algebra      0.02013      0.052985      0.052427      0.050423              Fast doubling      0.000446      0.000737      0.000785      0.000724      The above results are the time in millisecond for calculating .It will take too long time to get the results from the recursive approach,so we skip it.The closed-form approach is also ignoredsince the floating point operations only workwhen  in above implementation.ConclusionAlthough the performance is platform-dependent,it still indicates that:  The fast doubling approach is always the fastest wayand its performance is far far better than others.  The dynamic programming approach is faster than matrix algebra onewhen  is small ( here),but slower when  is large.  Therefore, if you are pretty sure you have a small ,and the bottleneck of your algorithm doesn’t depend onthe Fibonacci calculation, then dynamic programming is acceptableand it’s easier to implement.This post is the end of my journey for the Fibonacci calculation.Hope you enjoyed.All the above code are uploaded to gist here.Please clone them to play with it.I will start another journey for other interesting topics soon.Stay tuned!" />
<link rel="canonical" href="http://localhost:4000/post/master-fibonacci" />
<meta property="og:url" content="http://localhost:4000/post/master-fibonacci" />
<meta property="og:site_name" content="Peak Up" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-09T00:00:00+08:00" />
<link rel="prev" href="http://localhost:4000/post/calculating-fibonacci-numbers-by-fast-doubling" title="Calculating Fibonacci Numbers by Fast Doubling" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Master Fibonacci",
    "datePublished": "2017-09-09T00:00:00+08:00",
    "description": "The Fibonacci number is defined as:where .It can be directly written into the following most common codewhen we learned what the recursion is:///////////////////////////////////////////////////////////////////////////////// Recursive: O(2^n)uint64_t fibonacci(unsigned int n){  return (n &lt;= 1) ? n : fibonacci(n-1) + fibonacci(n-2);}However, if you try calculating ,then you will wait a long long time to get the resultsince it has so many overlapping processes.For example, if we calculate ,then there are duplicated calculations(overlapping substructures) for :The larger  is, the more overlapping processes we have.As a result, the time-complexity is .MemoizationTo avoid that, we can use a cache to save all the resultsand check it first before any calculation,so all the  we need, for ,will be computed just once.Therefore, the time complexity can be shorten to .///////////////////////////////////////////////////////////////////////////////// Recursive with memoization: O(n)std::vector&lt;uint64_t&gt; mem = { 0, 1 }; // F(k) = mem[k], F(0) = 0, F(1) = 1.uint64_t fibonacci(unsigned int n){  if (n + 1 &gt; mem.size()) { // if n is not calculated yet    mem.push_back(fibonacci(n-1) + fibonacci(n-2));  }  return mem[n];}Dynamic programmingThe above implementation needs extra space to save the results,and pay time for memory allocation.If we iteratively calculate from  to , , … then we can get without extra memory:The above implementation needs extra space to save the results,and pay time for memory allocation.If we iteratively calculate from  to , , …,to ,  or , then we can use only three or four variables to get :///////////////////////////////////////////////////////////////////////////////// Dynamic programming: O(n)uint64_t fibonacci(unsigned int n){  uint64_t a = 0, b = 1; // a = F(k), b = F(k+1), k = 0 now.  for (unsigned int k = 1 ; k &lt;= n ; ++k) { // loop k from 1 to n.    std::swap(a, b); // a = F(k+1), b = F(k)    b += a; // b = F(k) + F(k+1) = F(k+2)  }  return a;}or///////////////////////////////////////////////////////////////////////////////// Dynamic programming: O(n)uint64_t fibonacci(unsigned int n){  uint64_t a = 0, b = 1, sum = 0; // a = F(0), b = F(1)  for (unsigned int i = 1 ; i &lt; n ; ++i) { // run if n &gt;= 2    sum = a + b; // sum = F(i+1)    a = b;       // a = F(i)    b = sum;     // b = F(i+1)  }  // Now, i = n, sum = F(n), a = F(n-1), b = F(n)  return (n &lt; 2) ? n : sum;}They also run in  with less memory consumptionthan memoization approach.Furthermore, they avoid the memory overhead for the activation recordson the stack segment/space for the recursions.(The recursion will call itself multiple times,so it will push multiple activation records for the same function itself,with different arguments, into the stack segment/spaceof the process loading the program.)Closed-formIn fact, the Fibonacci number can be calculated by the following formula:(Please readthis postto know how it’s derived.)///////////////////////////////////////////////////////////////////////////////// closed-form: O(log(n))//   Theoretically, the power of n could be done in O(log(n)), but it&#39;s//   complicated to calculate the floating numbers.uint64_t fibonacci(unsigned int n){  // double sqrt5 = sqrt((double)5);  double sqrt5 = 2.2360679775;  return (pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n)) / sqrt5;}Its time-complexity depends on how the power of  is calculated.It could be done in  time(we will explain it below).However, the floating point operations limit the calculable number of ,and it might block the performance.Matrix AlgebraThe Fibonacci numbers can be written into the following matrix:, so it could be easily expanded by the same rule:(Please readthis postfor more discussion.)That is, the Fibonacci matrix turns into a perfect power.Applyingexponentiation by squaring:, we could implement the above idea to:///////////////////////////////////////////////////////////////////////////////// Power by matrix exponentiation: O(log(n))// Matrix A://  &lt;---  cols: n  ---&gt;// +-                 -+// | A11, A12, ... A1n |   ^// | A21, A22, ... A2n |   |// | ...               | rows: m// | ...               |   |// | Am1, Am2, ... Amn |   v// +-                 -+class Matrix{public:  Matrix(unsigned int r, unsigned int c,         std::vector&lt;std::vector&lt;uint64_t&gt;&gt; d)    : rows(r)    , cols(c)    , data(d)  {  }  Matrix(unsigned int r, unsigned int c)    : rows(r)    , cols(c)  {    assert(rows &amp;&amp; cols);    data.resize(rows);    for (unsigned int i = 0 ; i &lt; rows ; ++i) {      data[i].resize(cols);    }  }  ~Matrix()  {  }  uint64_t Read(unsigned int r, unsigned int c)  {    return data[r][c];  }  // friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; m)  // {  //   for (unsigned int i = 0; i &lt; m.rows; ++i) {  //     for (unsigned int j = 0; j &lt; m.cols; ++j) {  //       os &lt;&lt; m.data[i][j] &lt;&lt; &quot; &quot;;  //     }  //     os &lt;&lt; std::endl;  //   }  //   return os;  // }  Matrix operator*(const Matrix&amp; other)  {    assert(cols == other.rows); // Check if they can be multiplied.    Matrix z(rows, other.cols);    for (unsigned int i = 0 ; i &lt; rows ; ++i) {      for (unsigned int j = 0 ; j &lt; other.cols; ++j) {        for (unsigned int k = 0 ; k &lt; cols; ++k) {          z.data[i][j] += data[i][k] * other.data[k][j];        }      }    }    return z;  }  // Calculate the power by fast doubling:  //   k ^ n = (k^2) ^ (n/2)          , if n is even  //        or k * (k^2) ^ ((k-1)/2)  , if n is odd  Matrix pow(unsigned int n)  {    Matrix k(*this); // Copy constructor = Matrix x(rows, cols, data);    Matrix r = Identity(rows);    while (n) {      if (/*n % 2*/n &amp; 1) {        r = r * k;      }      k = k * k;      /*n /= 2*/n &gt;&gt;= 1;    }    return r;  }private:  Matrix Identity(unsigned int size)  {    Matrix z(size, size);    for (unsigned int i = 0 ; i &lt; size ; ++i) {      z.data[i][i] = 1;    }    return z;  }  unsigned int rows;  unsigned int cols;  std::vector&lt;std::vector&lt;uint64_t&gt;&gt; data;};// The Fibonacci matrix can be written into the following equation:// +-             -+   +-    -+^n// | F(n+1)   F(n) |   | 1  1 |// |               | = |      |// | F(n)   F(n-1) |   | 1  0 |// +-             -+   +-    -+uint64_t fibonacci(unsigned int n){  Matrix F { 2, 2, {    { 1, 1 },    { 1, 0 }  } };  // Using F.data[0][1] since n might be 0.  // (we need to power by n - 1 if we return F.data[0][0].)  F = F.pow(n);  return F.Read(0, 1);}Its time-complexity is  by halving and halving.Without the floating point operations,the  could be larger than using the closed-form approach.To make it faster, you can use native array instead of std::vector,but you need to manage the memory usage by yourself.Please readthis postto know how to do it.Fast doublingThe following equations:can be derived by applying  to the above Fibonacci matrix:Hence, we could calculate  by:As a consequence, we could use to compute  by the following program:(Please readthis postto know how the code is derived.)uint64_t fibonacci(unsigned int n){  // The position of the highest bit of n.  // So we need to loop `h` times to get the answer.  // Example: n = (Dec)50 = (Bin)00110010, then h = 6.  //                               ^ 6th bit from right side  unsigned int h = 0;  for (unsigned int i = n ; i ; ++h, i &gt;&gt;= 1);  uint64_t a = 0; // F(0) = 0  uint64_t b = 1; // F(1) = 1  // There is only one `1` in the bits of `mask`. The `1`&#39;s position is same as  // the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right  // iteratively to do `AND` operation with `n` to check `n / 2^j` is odd  // or even.  for (unsigned int mask = 1 &lt;&lt; (h - 1) ; mask ; mask &gt;&gt;= 1) { // Run h times!    // Let j = h-i (looping from i = 1 to i = h),    // n_j = floor(n / 2^j) = n &gt;&gt; j (n_j = n when j = 0), k = floor(n_j / 2),    // then a = F(k), b = F(k+1) now.    uint64_t c = a * (2 * b - a); // F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]    uint64_t d = a * a + b * b;   // F(2k+1) = F(k)^2 + F(k+1)^2    if (mask &amp; n) { // n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1      a = d;        //   F(n_j) = F(2k + 1)      b = c + d;    //   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)    } else {        // n_j is even: k = n_j/2 =&gt; n_j = 2k      a = c;        //   F(n_j) = F(2k)      b = d;        //   F(n_j + 1) = F(2k + 1)    }  }  return a;}Its time-complexity is also  by halving and halving.In contrast to matrix algebra approach,there is no need for using matrixthat contains the duplicated ,so it will be faster.Performance            Approach                                          Recursive      7440.61                                   Memoization      0.034841      3.03045      3.05931      6.10806              Dynamic programming      0.000508      0.052462      0.05395      0.1069              Closed-form      0.030075                                   Matrix Algebra      0.02013      0.052985      0.052427      0.050423              Fast doubling      0.000446      0.000737      0.000785      0.000724      The above results are the time in millisecond for calculating .It will take too long time to get the results from the recursive approach,so we skip it.The closed-form approach is also ignoredsince the floating point operations only workwhen  in above implementation.ConclusionAlthough the performance is platform-dependent,it still indicates that:  The fast doubling approach is always the fastest wayand its performance is far far better than others.  The dynamic programming approach is faster than matrix algebra onewhen  is small ( here),but slower when  is large.  Therefore, if you are pretty sure you have a small ,and the bottleneck of your algorithm doesn’t depend onthe Fibonacci calculation, then dynamic programming is acceptableand it’s easier to implement.This post is the end of my journey for the Fibonacci calculation.Hope you enjoyed.All the above code are uploaded to gist here.Please clone them to play with it.I will start another journey for other interesting topics soon.Stay tuned!",
    "logo": "http://localhost:4000mountain.png",
    "url": "http://localhost:4000/post/master-fibonacci"
  }
</script>
<!-- End Jekyll SEO tag -->

<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Peak Up" />

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
    crossorigin="anonymous">

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/style.css" />
<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/syntax.css" />


<!--Load Mathjax-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
        MathJax.Hub.Config({
            config: ["MMLorHTML.js"],
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: false
            },
            TeX: {
                TagSide: "right",
                TagIndent: ".8em",
                MultLineWidth: "85%",
                equationNumbers: {
                   autoNumber: "AMS",
                },
                unicode: {
                   fonts: "STIXGeneral,'Arial Unicode MS'"
                }
            },
            showProcessingMessages: false
        });
</script>



<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/favicons/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/favicons/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/favicons/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/favicons/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post-template" itemscope itemtype="http://schema.org/WebPage">

    
<div class="search-wrapper">
    <div class="search-form">
        <input type="text" id="search-input" class="search-field" placeholder="Search...">
        <i id="search-close" class="fa fa-times-circle"></i>
        <h4>Search results</h4>
        <ul id="results-container" class="search-results post-list">
        </ul>
        <!-- /.search-results -->
    </div>
    <!-- /.search-form -->
</div>
<!-- ./search-wrapper -->


<div id="fade"></div>
<a id="slide" class="animated fade">
    <i class="fa fa-bars" aria-hidden="true"></i>
</a>
<aside id="sidebar">
    <nav id="navigation">
        <h2>MENU</h2>
        <hr>
        <ul> 
            <li>
                <a href="http://localhost:4000/"><!-- <i class="fa fa-home"></i>&nbsp;-->Home</a>  </li>
            
            <li>
                <a href="http://localhost:4000/categories"><!-- <i class="fa fa-sitemap"></i>&nbsp;-->Categories</a>  </li>
            
            <li>
                <a href="http://localhost:4000/tags"><!-- <i class="fa fa-tags"></i>&nbsp;-->Tags</a>  </li>
            
            <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
        </ul>
    </nav>
</aside>


<header id="masthead" class="blog-background overlay align-center align-middle animated from-bottom" style="background-image: url(http://localhost:4000/images/background/taiwan_1.jpg)"
    itemscope itemtype="http://schema.org/Organization">



    <button class="menu-button animated fade dosearch">
        <i class="fa fa-search"></i>
    </button>



    <div class="inner">
        <div class="container">
            <a class="brand" href="http://localhost:4000/" itemprop="url">
                <img itemprop="logo" src="http://localhost:4000/images/mountain.png" alt="Peak Up Logo" />
                <h1 class="blog-title light" itemprop="name">
                    Peak Up
                </h1>
            </a>
        </div>
    </div>



    <div class="decor-wrapper">
        <svg id="header-decor" class="decor bottom" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 100 L50 50 L0 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 100 L50 50 L100 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 100 L50 50 L0 66.6" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 100 L50 50 L100 66.6" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>

</header>


    <div id="main" class="content" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
        <div class="container">
            <div class="row">
                <article class="post col-md-8 col-md-offset-2 hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
                
                
                
                

                    <header class="post-header entry-header">

                    

                    
                        <h1 class="post-title text-center hyper lighter bordered-bottom entry-title" itemprop="headline">
                        
                            
                        
                        
                        

                        
                            Master Fibonacci
                        </h1>
                    

                        <div class="cursive" style="color: #000; font-style:italic;"></div>

                            <div class="post-info text-center small">
                            
                                <span class="entry-date date published updated">
                            
                            
                                    <time datetime="2017-09-09T00:00:00+08:00" class="post-time" itemprop="datePublished">09 Sep 2017</time>
                                </span>
                            

                                in <span class="post-tags">

                            
                                    <a href="http://localhost:4000/categories/index.html#AlgorithmMath" data-toggle="tooltip" title="Other posts from the Algorithm category" rel="tag">Algorithm</a>
                                
                                    &nbsp;&bull;&nbsp;
                                
                            
                                    <a href="http://localhost:4000/categories/index.html#AlgorithmMath" data-toggle="tooltip" title="Other posts from the Math category" rel="tag">Math</a>
                                
                            
                                </span>
                            
                            &nbsp;
                                <span class="post-tags"><i class="fa fa-clock-o"></i>&nbsp;

                            

                            
                                    <span class="time">9.78888888888889</span> minutes read
                            
                                
                            

                                </span>
                            
                            </div>

                    </header>

                    <div class="post-body bordered-bottom" itemprop="description">
                    

                        <p>The <em>Fibonacci</em> number is defined as:</p>

<script type="math/tex; mode=display">F_n = F_{n-1} + F_{n-2}</script>

<p>where <script type="math/tex">F_0 = 0, F_1 = 1</script>.</p>

<p>It can be directly written into the following most common code
when we learned what the recursion is:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////
// Recursive: O(2^n)
</span><span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>However, if you try calculating <script type="math/tex">F_{100}</script>,
then you will wait a long long time to get the result
since it has so many overlapping processes.
For example, if we calculate <script type="math/tex">F_4</script>,
then there are duplicated calculations(overlapping substructures) for <script type="math/tex">F_2</script>:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{matrix}
 & & & & & & & 4 & & & & & \\
 & & & & & & \diagup & & \diagdown & & & & \\
 & & & & & \diagup & & & & \diagdown & & & \\
 & & & & 3 & & & & & & 2 & & \\
 & & & \diagup & & \diagdown & & & & \diagup & & \diagdown & \\
 & & 2 & & & & 1 & & 1 & & & & 0 \\
 & \diagup & & \diagdown & & & & & & & & & \\
 1 & & & & 0 & & & & & & & &
\end{matrix} %]]></script>

<p>The larger <script type="math/tex">n</script> is, the more overlapping processes we have.
As a result, the time-complexity is <script type="math/tex">O(2^n)</script>.</p>

<h3 id="memoization">Memoization</h3>

<p>To avoid that, we can use a <strong>cache</strong> to save all the results
and check it first before any calculation,
so all the <script type="math/tex">F_k</script> we need, for <script type="math/tex">k \in [0, n]</script>,
will be computed just once.
Therefore, the time complexity can be shorten to <script type="math/tex">O(n)</script>.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////
// Recursive with memoization: O(n)
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">mem</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span> <span class="c1">// F(k) = mem[k], F(0) = 0, F(1) = 1.
</span><span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">mem</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// if n is not calculated yet
</span>    <span class="n">mem</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">mem</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="dynamic-programming">Dynamic programming</h3>

<p>The above implementation needs extra space to save the results,
and pay time for memory allocation.
If we iteratively calculate <script type="math/tex">F_n</script>
from <script type="math/tex">F_0, F_1</script> to <script type="math/tex">F_2</script>, <script type="math/tex">F_3</script>, … then we can get <script type="math/tex">F_n</script>
without extra memory:</p>

<p>The above implementation needs extra space to save the results,
and pay time for memory allocation.
If we iteratively calculate <script type="math/tex">F_n</script>
from <script type="math/tex">F_0, F_1</script> to <script type="math/tex">F_2</script>, <script type="math/tex">F_3</script>, …,
to <script type="math/tex">F_{n-1}</script>, <script type="math/tex">F_n</script> or <script type="math/tex">F_n</script>, <script type="math/tex">F_{n+1}</script>
then we can use only three or four variables to get <script type="math/tex">F_n</script>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////
// Dynamic programming: O(n)
</span><span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// a = F(k), b = F(k+1), k = 0 now.
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// loop k from 1 to n.
</span>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// a = F(k+1), b = F(k)
</span>    <span class="n">b</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// b = F(k) + F(k+1) = F(k+2)
</span>  <span class="p">}</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>or</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////
// Dynamic programming: O(n)
</span><span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// a = F(0), b = F(1)
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// run if n &gt;= 2
</span>    <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// sum = F(i+1)
</span>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>       <span class="c1">// a = F(i)
</span>    <span class="n">b</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>     <span class="c1">// b = F(i+1)
</span>  <span class="p">}</span>
  <span class="c1">// Now, i = n, sum = F(n), a = F(n-1), b = F(n)
</span>  <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>They also run in <script type="math/tex">O(n)</script> with less memory consumption
than <em>memoization</em> approach.
Furthermore, they avoid the memory overhead for the <em>activation records</em>
on the <em>stack segment/space</em> for the recursions.
(The recursion will call itself multiple times,
so it will push multiple <em>activation records</em> for the same function itself,
with different arguments, into the <em>stack segment/space</em>
of the process loading the program.)</p>

<h3 id="closed-form">Closed-form</h3>

<p>In fact, the <em>Fibonacci</em> number can be calculated by the following formula:</p>

<script type="math/tex; mode=display">F_n = \frac{1}{\sqrt{5}} \cdot [ (\frac{1 + \sqrt{5}}{2})^n -  (\frac{1 - \sqrt{5}}{2})^n ]</script>

<p>(Please read
<!-- [this post](/post/closed-form-for-the-fibonacci-sequence) -->
<a href="https://chunminchang.github.io/blog/post/closed-form-for-the-fibonacci-sequence">this post</a>
to know how it’s derived.)</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////
// closed-form: O(log(n))
//   Theoretically, the power of n could be done in O(log(n)), but it's
//   complicated to calculate the floating numbers.
</span><span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// double sqrt5 = sqrt((double)5);
</span>  <span class="kt">double</span> <span class="n">sqrt5</span> <span class="o">=</span> <span class="mf">2.2360679775</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">pow</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sqrt5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">pow</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sqrt5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">sqrt5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Its time-complexity depends on how the power of <script type="math/tex">n</script> is calculated.
It could be done in <script type="math/tex">O(\log n)</script> time(we will explain it below).
However, the floating point operations limit the calculable number of <script type="math/tex">n</script>,
and it might block the performance.</p>

<h3 id="matrix-algebra">Matrix Algebra</h3>

<p>The <em>Fibonacci</em> numbers can be written into the following matrix:</p>

<script type="math/tex; mode=display">% <![CDATA[
\vec{F_n} =
\begin{bmatrix} F_n \\ F_{F - 1} \end{bmatrix}
=
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_{n - 1} \\ F_{n - 2} \end{bmatrix} %]]></script>

<p>, so it could be easily expanded by the same rule:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
&=
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\cdot
\begin{bmatrix} F_n & F_{n - 1} \\ F_{n - 1} & F_{n - 2} \end{bmatrix}
\\
&=
{\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^2
\cdot
\begin{bmatrix} F_{n - 1} & F_{n - 2} \\ F_{n - 2} & F_{n - 3} \end{bmatrix}
\\
\vdots
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} F_2 & F_1 \\ F_1 & F_0 \end{bmatrix}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{n - 1}
\cdot
\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\end{align} %]]></script>

<p>(Please read
<!-- [this post](/post/matrix-difference-equation-for-fibonacci-sequence) -->
<a href="https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence">this post</a>
for more discussion.)</p>

<p>That is, the <em>Fibonacci</em> matrix turns into a perfect power.
Applying
<!-- [exponentiation by squaring](/post/exponentiation-by-squaring) -->
<a href="https://chunminchang.github.io/blog/post/exponentiation-by-squaring">exponentiation by squaring</a>
:</p>

<script type="math/tex; mode=display">% <![CDATA[
k^n =
\begin{cases}
(k^2)^\frac{n}{2},  & \text{if $n$ is even} \\
k \cdot (k^2)^\frac{n-1}{2}, & \text{if $n$ is odd}
\end{cases} %]]></script>

<p>, we could implement the above idea to:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">///////////////////////////////////////////////////////////////////////////////
// Power by matrix exponentiation: O(log(n))
// Matrix A:
//  &lt;---  cols: n  ---&gt;
// +-                 -+
// | A11, A12, ... A1n |   ^
// | A21, A22, ... A2n |   |
// | ...               | rows: m
// | ...               |   |
// | Am1, Am2, ... Amn |   v
// +-                 -+
</span><span class="k">class</span> <span class="nc">Matrix</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">rows</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cols</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">data</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>

  <span class="n">Matrix</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">rows</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cols</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">cols</span><span class="p">);</span>
    <span class="n">data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">cols</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Matrix</span><span class="p">()</span>
  <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">uint64_t</span> <span class="n">Read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; m)
</span>  <span class="c1">// {
</span>  <span class="c1">//   for (unsigned int i = 0; i &lt; m.rows; ++i) {
</span>  <span class="c1">//     for (unsigned int j = 0; j &lt; m.cols; ++j) {
</span>  <span class="c1">//       os &lt;&lt; m.data[i][j] &lt;&lt; " ";
</span>  <span class="c1">//     }
</span>  <span class="c1">//     os &lt;&lt; std::endl;
</span>  <span class="c1">//   }
</span>  <span class="c1">//   return os;
</span>  <span class="c1">// }
</span>
  <span class="n">Matrix</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">cols</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">rows</span><span class="p">);</span> <span class="c1">// Check if they can be multiplied.
</span>
    <span class="n">Matrix</span> <span class="n">z</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">z</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Calculate the power by fast doubling:
</span>  <span class="c1">//   k ^ n = (k^2) ^ (n/2)          , if n is even
</span>  <span class="c1">//        or k * (k^2) ^ ((k-1)/2)  , if n is odd
</span>  <span class="n">Matrix</span> <span class="n">pow</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">k</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// Copy constructor = Matrix x(rows, cols, data);
</span>    <span class="n">Matrix</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="cm">/*n % 2*/</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
      <span class="cm">/*n /= 2*/</span><span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Matrix</span> <span class="n">Identity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Matrix</span> <span class="n">z</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">z</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The Fibonacci matrix can be written into the following equation:
// +-             -+   +-    -+^n
// | F(n+1)   F(n) |   | 1  1 |
// |               | = |      |
// | F(n)   F(n-1) |   | 1  0 |
// +-             -+   +-    -+
</span><span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Matrix</span> <span class="n">F</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="p">}</span> <span class="p">};</span>

  <span class="c1">// Using F.data[0][1] since n might be 0.
</span>  <span class="c1">// (we need to power by n - 1 if we return F.data[0][0].)
</span>  <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">pow</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">F</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Its time-complexity is <script type="math/tex">O(\log n)</script> by halving and halving.
Without the floating point operations,
the <script type="math/tex">n</script> could be larger than using the <em>closed-form</em> approach.</p>

<p>To make it faster, you can use native array instead of <code class="highlighter-rouge">std::vector</code>,
but you need to manage the memory usage by yourself.
Please read
<!-- [this post](/post/matrix-difference-equation-for-fibonacci-sequence) -->
<a href="https://chunminchang.github.io/blog/post/matrix-difference-equation-for-fibonacci-sequence">this post</a>
to know how to do it.</p>

<h3 id="fast-doubling">Fast doubling</h3>

<p>The following equations:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
F_{2n+1} &= {F_{n+1}}^2 + {F_n}^2
\\
F_{2n} &= F_n \cdot (F_{n+1} + F_{n-1}) \\
       &= F_n \cdot (F_{n+1} + (F_{n+1} - F_n)) \\
       &= F_n \cdot (2 \cdot F_{n+1} - F_n)
\end{align} %]]></script>

<p>can be derived by applying <script type="math/tex">2n</script> to the above <em>Fibonacci</em> matrix:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\begin{bmatrix} F_{2n+1} & F_{2n} \\ F_{2n} & F_{2n - 1} \end{bmatrix}
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^{2n}
\\
&= {\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\cdot
{\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}}^n
\\
&= \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
\cdot \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n - 1} \end{bmatrix}
\\
&=
\begin{bmatrix}
  {F_{n+1}}^2 + {F_n}^2 & F_n \cdot (F_{n+1} + F_{n-1}) \\
  F_n \cdot (F_{n+1} + F_{n-1}) & {F_n}^2 + {F_{n-1}}^2
\end{bmatrix}
\end{align} %]]></script>

<p>Hence, we could calculate <script type="math/tex">F_n</script> by:</p>

<script type="math/tex; mode=display">% <![CDATA[
F_n =
\begin{cases}
F_{2n'},  & \text{if $n$ is even} \\
F_{2n'+1}, & \text{if $n$ is odd}
\end{cases} %]]></script>

<p>As a consequence, we could use <script type="math/tex">F_{n'}, F_{n' + 1}</script>
to compute <script type="math/tex">F_n</script> by the following program:
(Please read
<!-- [this post](/post/calculating-fibonacci-numbers-by-fast-doubling) -->
<a href="https://chunminchang.github.io/blog/post/calculating-fibonacci-numbers-by-fast-doubling">this post</a>
to know how the code is derived.)</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// The position of the highest bit of n.
</span>  <span class="c1">// So we need to loop `h` times to get the answer.
</span>  <span class="c1">// Example: n = (Dec)50 = (Bin)00110010, then h = 6.
</span>  <span class="c1">//                               ^ 6th bit from right side
</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">++</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// F(0) = 0
</span>  <span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// F(1) = 1
</span>  <span class="c1">// There is only one `1` in the bits of `mask`. The `1`'s position is same as
</span>  <span class="c1">// the highest bit of n(mask = 2^(h-1) at first), and it will be shifted right
</span>  <span class="c1">// iteratively to do `AND` operation with `n` to check `n / 2^j` is odd
</span>  <span class="c1">// or even.
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="n">mask</span> <span class="p">;</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Run h times!
</span>    <span class="c1">// Let j = h-i (looping from i = 1 to i = h),
</span>    <span class="c1">// n_j = floor(n / 2^j) = n &gt;&gt; j (n_j = n when j = 0), k = floor(n_j / 2),
</span>    <span class="c1">// then a = F(k), b = F(k+1) now.
</span>    <span class="kt">uint64_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// F(2k) = F(k) * [ 2 * F(k+1) – F(k) ]
</span>    <span class="kt">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// F(2k+1) = F(k)^2 + F(k+1)^2
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n_j is odd: k = (n_j-1)/2 =&gt; n_j = 2k + 1
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j) = F(2k + 1)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">//   F(n_j + 1) = F(2k + 2) = F(2k) + F(2k + 1)
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        <span class="c1">// n_j is even: k = n_j/2 =&gt; n_j = 2k
</span>      <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>        <span class="c1">//   F(n_j) = F(2k)
</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>        <span class="c1">//   F(n_j + 1) = F(2k + 1)
</span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Its time-complexity is also <script type="math/tex">O(\log n)</script> by halving and halving.
In contrast to <em>matrix algebra</em> approach,
there is no need for using matrix
that contains the duplicated <script type="math/tex">F_k</script>,
so it will be faster.</p>

<h3 id="performance">Performance</h3>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th><script type="math/tex">F_{45}</script></th>
      <th><script type="math/tex">F_{13100}</script></th>
      <th><script type="math/tex">F_{13500}</script></th>
      <th><script type="math/tex">F_{29108}</script></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Recursive</td>
      <td>7440.61</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Memoization</td>
      <td>0.034841</td>
      <td>3.03045</td>
      <td>3.05931</td>
      <td>6.10806</td>
    </tr>
    <tr>
      <td>Dynamic programming</td>
      <td>0.000508</td>
      <td>0.052462</td>
      <td>0.05395</td>
      <td>0.1069</td>
    </tr>
    <tr>
      <td>Closed-form</td>
      <td>0.030075</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Matrix Algebra</td>
      <td>0.02013</td>
      <td>0.052985</td>
      <td>0.052427</td>
      <td>0.050423</td>
    </tr>
    <tr>
      <td>Fast doubling</td>
      <td>0.000446</td>
      <td>0.000737</td>
      <td>0.000785</td>
      <td>0.000724</td>
    </tr>
  </tbody>
</table>

<p>The above results are the time in <em>millisecond</em> for calculating <script type="math/tex">F_n</script>.
It will take too long time to get the results from the <em>recursive</em> approach,
so we skip it.
The <em>closed-form</em> approach is also ignored
since the floating point operations only work
when <script type="math/tex">n \leq 97</script> in above implementation.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Although the performance is platform-dependent,
it still indicates that:</p>

<ul>
  <li>The <em>fast doubling</em> approach is always the fastest way
and its performance is far far better than others.</li>
  <li>The <em>dynamic programming</em> approach is faster than <em>matrix algebra</em> one
when <script type="math/tex">n</script> is small (<script type="math/tex">n \leq 13000</script> here),
but slower when <script type="math/tex">n</script> is large.</li>
  <li>Therefore, if you are pretty sure you have a small <script type="math/tex">n</script>,
and the bottleneck of your algorithm doesn’t depend on
the <em>Fibonacci</em> calculation, then <em>dynamic programming</em> is acceptable
and it’s easier to implement.</li>
</ul>

<p>This post is the end of my journey for the <em>Fibonacci</em> calculation.
Hope you enjoyed.
All the above code are uploaded to <a href="https://gist.github.com/ChunMinChang/b6325c148e8aff15b6e72dcac0aa904e" title="Ways to calculate Fibonacci">gist here</a>.
Please clone them to play with it.</p>

<p>I will start another journey for other interesting topics soon.
Stay tuned!</p>



                        <br>

                    
                    
                        <div class="entry-tags text-center">
                            <i class="fa fa-tags"></i>&nbsp;
                                Tagged with 
                            
                                <a href="http://localhost:4000/tags/index.html#Fibonacci" data-toggle="tooltip" title="Posts tagged with Fibonacci" rel="tag">Fibonacci</a>

                                
                                &nbsp;&bull;&nbsp;
                                
                            
                                <a href="http://localhost:4000/tags/index.html#Recursion" data-toggle="tooltip" title="Posts tagged with Recursion" rel="tag">Recursion</a>

                                
                                &nbsp;&bull;&nbsp;
                                
                            
                                <a href="http://localhost:4000/tags/index.html#Dynamic Programming" data-toggle="tooltip" title="Posts tagged with Dynamic Programming" rel="tag">Dynamic Programming</a>

                                
                            
                        </div>
                    
                    </div>

                    <footer class="post-footer entry-meta">
                    
                        <div class="post-share text-center">
    <p class="light small">
        Share this post
    </p>
    <ul class="social-mini">
        <li>
            <a href="https://twitter.com/intent/tweet?text=Master+Fibonacci%20http://localhost:4000/post/master-fibonacci%20via%20&#64;"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" data-toggle="tooltip"
                title="Share on Twitter" itemprop="Twitter">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/post/master-fibonacci" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"
                data-toggle="tooltip" title="Share on Facebook" itemprop="Facebook">
                <i class="fa fa-facebook"></i>
            </a>
        </li>
        <li>
            <a href="https://plus.google.com/share?url=http://localhost:4000/post/master-fibonacci" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;"
                data-toggle="tooltip" title="Share on Google plus" itemprop="GooglePlus">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
    </ul>
</div>
                    

                        <div class="post-author text-center">
	<img src="http://localhost:4000/images/chunmin.jpg" alt="Chun-Min Chang's photo" itemprop="image" class="post-avatar img-circle img-responsive" />
	<h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="http://schema.org/Person">
		By <span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About Chun-Min Chang" itemprop="url">Chun-Min Chang</a></span>
	</h4>
	<p>I am a self-directed learner and a maker who enjoys building products from original ideas.</p>
</div> 
                        
                    
                        <div id="disqus_thread"></div><!-- /#disqus_thread -->
                    
                    </footer>

                </article>
            </div>
        </div>
    </div>

    
<footer id="footer" class="blog-background overlay text-center align-middle animated from-top" style="background-image: url(http://localhost:4000/images/background/taiwan_1.jpg)">


    <div class="inner">
        <div class="container">
            <ul class="social-icons">
                    
                <li>
                    <a href="https://www.linkedin.com/in/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on LinkedIn" target="_blank">
                        <i class="fa fa-linkedin"></i>
                    </a>
                </li>
                   
                <li>
                    <a href="http://github.com/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on Github" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </li>
                
            </ul>
            <div>
                <a href="http://localhost:4000/about/">Chun-Min Chang</a> &copy; 2017 &bull;
                All rights reserved.
            </div>
            <ul class="menu-items">
                
                <li>
                    
                    <a href="http://localhost:4000/"><i class="fa fa-home"></i>&nbsp;Home</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/categories"><i class="fa fa-sitemap"></i>&nbsp;Categories</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/tags"><i class="fa fa-tags"></i>&nbsp;Tags</a>&nbsp;&bull;
                    
                </li>
                
                <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
            </ul>
        </div>
    </div>

    
    <div class="decor-wrapper">
        <svg id="footer-decor" class="decor top" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 0 L50 50 L0 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 0 L50 50 L100 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 0 L50 50 L0 33.3" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 0 L50 50 L100 33.3" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>
    

</footer>


    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ="
  crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.12.4.min.js"><\/script>')</script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
  crossorigin="anonymous"></script>

<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jekyll-search.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.fitvids.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.waypoints.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/main.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/script.js"></script>
<script type='text/javascript'>$(document).ready(function(){$(".time").text(function(a,b){return Math.round(parseFloat(b))})});</script>

<script type="text/javascript">

/*      Slides       */

$("a#slide").click(function(){
    $("#sidebar,body,a#slide,#fade").addClass("slide")
});

$("#fade,#header,#posts-container").click(function(){
    $("#sidebar,body,a#slide,#fade").removeClass("slide")
});

$("a#click-filter").click(function(){
    $("#slide-filter").slideToggle("medium");
    $("#slide-pages").slideOut("medium");
});

$("a#click-pages").click(function(){
    $("#slide-pages").slideToggle("medium");
    $("#slide-filter").slideOut("medium");
});

/*      End-Slides      */

</script>


<!-- Jekyll Simple Search option -->
<script>

   SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: 'http://localhost:4000/assets/json/search.json',
        searchResultTemplate: '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
        noResultsText: '<p>Nothing found.</p>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $("#search-close"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


 


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'chunminchang-blog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        
</body>
</html>
