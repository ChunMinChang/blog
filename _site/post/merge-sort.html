<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">


<meta name="keywords" content="Sorting">


<!-- Begin Jekyll SEO tag v1.3.3 -->
<title>Merge Sort - Peak Up</title>
<meta property="og:title" content="Merge Sort" />
<meta name="description" content="Merge SortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaMerge sort is an efficient algorithm thatapplies the concepts of divide and conquer to sort the list.The key idea of divide and conquer is to recursively break down the problemsinto two or more sub-problems and they are same or related to the original problem,until these divided sub-problems are simple enough to solve directly.Then, the solutions of the original problem can be combined and derivedby the solutions of all the sub-problems.Divide and conquerThe calculation of Fibonacci number, ,is one example.To calculate , it needs to find  and .Similarly, to calculate , it needs to  and .The sub-problems for calculating  and  have same formas the one for .Recursively, we will need to get , , …, , and  and  are easy enough to solve directly. They are both .Thus, , , … and then can be computed.Dividing the sorting-problemLet’s apply this concept to the sorting problem.If we want to sort the list ,the sub-lists  must also be sorted,so we can narrow down our problem scope for handling the sub-lists.Next,  can be divided to and  also can be split into  and .Finally,  are not dividableso we stop breaking down the list.       [6, 3, 7, 1, 9, 2, 5]         /               \   [6, 3, 7, 1]       [9, 2, 5]    /        \          /     \ [6, 3]    [7, 1]    [9, 2]  [5] /    \    /    \    /    \[6]  [3]  [7]  [1]  [9]  [2]In the same way, the whole list can be divided into.Conquering the sub-problemsAfter there is only one element left,the subproblem is solved by nature since it’s already sorted.However, the problem becomes  how do we combine these sorted chunks into a sorted listWe need a method that can merge two sorted lists, and , where ,into a bigger sorted list .Combining all the results of sub-sorting-problemSuppose we have two sorted lists  and .We provide two ways to merge them into a sorted list.Picking the smallest elements one by oneThe simplest method is to pick the smallest elements iterativelyby searching both lists from the minimal to maximal.We only need to compare the left most elements of both listsand pick the smaller one since  and  are already sorted.The following example demonstrate the process of this idea:() &lt;- search indexA = [(3), 6, 10, 23]B = [(2), 7, 50, 55]L = []                            // &lt;- 2In the first round,  is picked since and going to be put into another list .                                  // You can think the left most element                                  // is shifted one by oneA = [(3), 6, 10, 23]              // [3, 6, 10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2]                           // &lt;- 3After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, (6), 10, 23]              // [6, 10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2, 3]                        // &lt;- 6After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, (10), 23]              // [10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2, 3, 6]                     // &lt;- 7After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, (10), 23]              // [10, 23]B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7]                  // &lt;- 10After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, 10, (23)]              // [23]B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7, 10]After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, 10, 23]                // []B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7, 10, 23]After  is picked, there is no need to compare againsince the  is the last element in .A = [3, 6, 10, 23]                // []B = [2, 7, 50, 55]                // []L = [2, 3, 6, 7, 10, 23, 50, 55]Next, we can append all the rest elementsfrom  to the end of  into the .Finally, we get a sort list .Swapping the elements one by oneAnother idea to merge the two sorted lists and ,is to couple them together into a list () &lt;- element who will be movedL = [3, 6, 10, 23, | (2), 7, 50, 55]// The &#39;|&#39; doesn&#39;t exist! It&#39;s only a notation for better explanation.and then move the minimal element of the later list()to the right position of the former list().The way for finding right the position is to compare the elements one by onefrom the end of the former list() to its head.() &lt;- element who will be movedL = [3, 6, 10, (2), 23, | 7, 50, 55]In our example, the  is swapped with  since .Then we keep comparing  with .() &lt;- element who will be movedL = [3, 6, (2), 10, 23, | 7, 50, 55]Similarly, the  are swapped since .() &lt;- element who will be movedL = [3, (2), 6,  10, 23, | 7, 50, 55]Next, the  are swapped since .() &lt;- element who will be movedL = [(2), 3, 6,  10, 23, | 7, 50, 55]Next, the  are swapped since .After this round, there is nothing to compare,so the  is moved to its right position.Now  and In the same way, we can do this process again with .It’s the minimal element of the later list  now.() &lt;- element who will be movedL = [2, 3, 6, 10, 23, | (7), 50, 55]L = [2, 3, 6, 10, (7), 23, | 50, 55]L = [2, 3, 6, (7), 10, 23, | 50, 55]L = [2, 3, 6, 7, 10, 23, | 50, 55]After this round,  and .Then do it again with with .() &lt;- element who will be movedL = [2, 3, 6,  7, 10, 23, | (50), 55]L = [2, 3, 6,  7, 10, 23, 50, | 55]However,  doesn’t move because .We just need to append  to the end of the former list .After this round,  and .() &lt;- element who will be movedL = [2, 3, 6,  7, 10, 23, 50, | (55)]L = [2, 3, 6,  7, 10, 23, 50, 55]It’s same to .It doesn’t need to be moved since ,so just append it to the .Finally,  and  is empty now.Now we have a sorted list !Which merge method is betterThe first method use extra space to store the sorted results,rather than the second in-place solution.On the other hand, the second method needs more swapping executionsand its a linear operation.For better performance, we take the first method as our approach here.Actually, there is a way to save the extra spaceand it works as fast as the first method above.However, it’s complicated.I will write another post for illustrating it.Please refer In-place merge sort in Elementary Algorithmsto read it.AlgorithmProofCorrectness of Merge  List L        &lt;------   sorted   ------&gt; &lt;------   sorted  -------&gt;        &lt;- merged -&gt; &lt;---  A  ---&gt; &lt;- merged -&gt; &lt;---  B  ---&gt;  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----   ... | l | ...... | i | ... | m | m+1 | .... | j | ... | r | ...  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----                      ^                          ^                head of sublist A          head of sublist B  List L&#39;   &lt;--   merged  --&gt; &lt;---   empty   ---&gt;  +---+-------+-----+---+-------+-------+  | 1 |  ...  | k-1 | k | ..... | r-l+1 |  +---+-------+-----+---+-------+-------+                      ^                head of empty area of list L&#39;  L[l...m]    : the sorted sublists for merging with L[m+1...r]  L[m+1...r]  : the sorted sublists for merging with L[l...m]  A, B        : the sublists containing elements that have NOT been merged yet  L&#39;[1...k-1] : the merged list from L[l...i-1] and L[m+1...j-1]  i: The index of the first element in L[l...m] that has NOT been merged yet  j: The index of the first element in L[m+1...r] that has NOT been merged yet  k: The index of next merged element copied from L[i] or L[j]Loop Invariant:At the beginning of the while-loop, the following conditions hold:  Sublists  and  are sorted   holds the elements from sublists  and   All elements in  is less or equal thansublists  and    are sorted.Formally, Then we use loop-invariants to prove:  Initialization: At the very beginning when           the input  are sorted so 1 holds      the list  is empty so 2, 3, 4 hold        Maintenance: Consider the iteration           1 is preserved since there is no change in       2 is preserved because                  If ,                           then               3 is preserved because and                                 Otherwise,                           then               3 is preserved because and                                           The previous appended element must be smaller thanthe current selected minimal element or 1 is false      By 3, the next selected minimal element will be larger than current one      So 4 is also preserved        Termination          By 2,  consists of the elements in       By 4,  are sorted      Correctness of Merge Sort  Given a list  with  elements,the  can be sortedby applying the above the MergeSort with .  Base step: When , it’s trivial.  Induction Hypothesis:Suppose this assumption holds when list has  elements  Induction Step: When           the list  is divide to ( elements)and ( elements)      so       and       By our hypothesis,  and  can be sorted      By the proved correctness of merge above,the merged  and  is also sorted,so the proof is done      Complexity  ^    +------------------------------------------------------+   Merge  |    |                           N                          |   Complexity  |    +------------------------------------------------------+  |                 |                              |  |                 v                              v  |    +------------------------+    +------------------------+  |    |           N/2          |    |           N/2          |   2 * O(N/2)  |    +------------------------+    +------------------------+  |         |              |              |              |            v              v              v              v  K    +---------+    +---------+    +---------+    +---------+       |   N/4   |    |   N/4   |    |   N/4   |    |   N/4   |   4 * O(N/4)  |    +---------+    +---------+    +---------+    +---------+  |      |     |        |     |        |     |        |     |  |      v     v        v     v        v     v        v     v  |  |                        .  .  .  .  .  .                       2^i * O(N/(2^i))  |  |    +---+  +---+  +---+                                +---+  |    | 1 |  | 1 |  | 1 |  .  .  .  .  .  .  .  .  .  .  | 1 |   N * O(1)  v    +---+  +---+  +---+                                +---+  N: the number of list elements.  K: K layers from N to 1.     N/2^k = 1 =&gt; N = 2^K =&gt; K = log_2(N)The above figure is the recursion tree of merge sort.The list containing  elements is recursively divided to sortuntil there is only one elements.Suppose that there is  times of division, therefore,On the other hand, the time complexitydepends on the performance of merge .The used merge here is the basic version.It iteratively picks the minimal elements from both subliststhen copied to another list .After all the elements in one sublist are all selected,we move the rest elements in the other sublist to list .Finally, we assigned , .Thus,  can be defined aswhere  is a constant reflecting the basic operationslike comparisons or assignments for merging routine.By the recursion treeFrom the above figure, the total time for the merge sort isThus, the time complexity is .By telescopingFormally, since the merge sort repeatedly breaks down the -elements listinto two -elements sublists,the amount of time that merge sort, ,can be written as follows:Thus, the time complexity is .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::min, std::swap#include &lt;cassert&gt;#include &lt;cstring&gt;    // for memcpy#include &quot;sorting.h&quot;/* * Merge sort: O(n * log(n)) */// Basic merge: O(n)// The following is the most straightforward way to merge two sorted array.// However, it allocates extra memory for sorted results in every recursion.void merge(int list[],           unsigned int left,           unsigned int division,           unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  unsigned int i = left;  unsigned int j = division + 1;  const unsigned int size = right - left + 1;  int array[size];  // When left &lt;= i &lt;= div and div + 1 &lt;= j &lt;= right:  // Compare list[i] and list[j], if list[i] &lt; list[j], then copy list[i] into  // the new array and let i = i + 1. Otherwise, copy list[j] into the new array  // and let j = j + 1. If i &gt; div, it means list[left...div] is all compared  // and already copied, so we just need to put the rest list[j...right] into  // the array. In the same way, if j &gt; right, then put the rest list[i...div]  // into the array.  unsigned int k = 0;  for (k = 0 ; k &lt; size; ++k) {    array[k] = (j &gt; right || (i &lt;= division &amp;&amp; list[i] &lt; list[j])) ? list[i++] : list[j++];  }  // while (i &lt;= division &amp;&amp; j &lt;= right) {  //   array[k++] = (list[i] &lt; list[j]) ? list[i++] : list[j++];  //   // if (list[i] &lt; list[j]) {  //   //   array[k] = list[i];  //   //   ++i;  //   // } else {  //   //   array[k] = list[j];  //   //   ++j;  //   // }  //   // ++k;  // }  //  // // In this case, j &gt; right, so we put the rest list[i...div] into the array.  // while (i &lt;= division) {  //   array[k++] = list[i++];  //   // array[k] = list[i];  //   // ++i;  //   // ++k;  // }  //  // // in this case, i &gt; div, so we put the rest list[j...right] into the array.  // while (j &lt;= right) {  //   array[k++] = list[j++];  //   // array[k] = list[j];  //   // ++j;  //   // ++k;  // }  assert(k == size);  assert(i == division + 1);  assert(j == right + 1);  // Overwrite list[left...right] by the new sorted array.  for (k = 0 ; k &lt; size ; ++k) {    list[left + k] = array[k];  }  assert(left + k == right + 1);}// Append ∞ as the last sentinel element to the both ordered arrays for merging.void mergeWithSentinel(int list[], unsigned int left, unsigned int division, unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  //      |&lt;---  A&#39;  ---&gt;|&lt;---  B&#39;  ---&gt;|  // Allocate list A = A&#39; ∪ [INFINITY] and list B = B&#39; ∪ [INFINITY]  const static int INFINITY = ((unsigned int)(-1) &gt;&gt; 1);  const unsigned int sizeA = division - left + 2; // (division - left + 1) + 1  const unsigned int sizeB = right - division + 1; // (right - (division + 1) + 1) + 1  int *A = new int[sizeA]; // 1 is for [ INFINITY ]  int *B = new int[sizeB];  // Copy elements from list[left...division] to A&#39;[0...(sizeA - 2)].  memcpy((void*)A, (void*)(list + left), sizeof(int) * (sizeA - 1));  // Copy elements from list[(division + 1)...right] to B&#39;[0...(sizeB - 2)].  memcpy((void*)B, (void*)(list + division + 1), sizeof(int) * (sizeB - 1));  // Set the last elements of A and B to INFINITY.  A[sizeA - 1] = B[sizeB - 1] = INFINITY;  // Move the sorted elements of A and B to list[left...right].  unsigned int i, j;  for (i = j = 0 ; left &lt;= right ; ++left) {    list[left] = A[i] &lt; B[j] ? A[i++] : B[j++];  }  free(A);  free(B);}// The following method demonstrates a in-place version of merge method.// However, it downgrades mergesort overall performance to quadratic O(n^2)!// Naive in-place merge: O(n^2)void naiveInplaceMerge(int list[],                       unsigned int left,                       unsigned int division,                       unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  unsigned int anchor = left;  for (unsigned int i = division + 1 ; i &lt;= right ; ++i) {    for (unsigned int j = i ; j &gt; anchor ; --j) { // Replace anchor with left is fine.      // The following condition is definitely true and will be triggered.      // list[division + k + 1] &gt;= list[division + k] where k &gt;= 1      // is assertive because list[division + 1 .... right] is a sorted from      // minimal item to maximal one.      if (list[j] &gt;= list[j-1]) {        anchor = j;        break;      }      std::swap(list[j], list[j-1]);    }  }}void topDownMergeSort(int list[], unsigned int left, unsigned int right){  if (left &gt;= right) {    return;  }  const unsigned int middle = (left + right) / 2;  topDownMergeSort(list, left, middle);  topDownMergeSort(list, middle + 1, right);  merge(list, left, middle, right);  // mergeWithSentinel(list, left, middle, right);  // naiveInplaceMerge(list, left, middle, right); // Slower!}void bottomUpMergeSort(int list[], unsigned int length){  // &lt;----------  l = 2^k + r  ----------&gt;  where k, r are integers, k &gt;= 0,  // &lt;-----  2^k  -----&gt;|&lt;-----  r  -----&gt;  and 0 &lt;= r &lt; 2^k.  // +---+---+---------+---+---------+---+  // | 0 | 1 | ....... | n | ....... | m |  // +---+---+---------+---+---------+---+  //  // l            k  r  // 1 : 2^0 + 0  0  0  // 2 : 2^1 + 0  1  0  // 3 : 2^1 + 1  1  1  // 4 : 2^2 + 0  2  0  // 5 : 2^2 + 1  2  1  // 6 : 2^2 + 2  2  2  // 7 : 2^2 + 3  2  3  // 8 : 2^3 + 0  3  0  // 9 : 2^3 + 1  3  1  // ...  // ...  //  // When r = 0:  The length of list is powers of 2, denoted 2^k, so all the  //              size of blocks for merging must be same. At the round (k+1),  //              the size is 2^k, where k &gt;= 0 is a integer.  // When r != 0: We can consider there are extra &#39;r&#39; elements added into the  //              above list whose length is powers of 2.  //              The extra &#39;r&#39; elements will be merged when the block size is  //              grown to 2^k, where k &gt;= 0 and 0 &lt; r &lt; 2^k.  //  // Each round, the list is divided into blocks and then merged  // from size 1, 2, 4, ... to lenght/2.  for (unsigned int size = 1 ; size &lt; length ; size *= 2) {    // If i &gt;= length - size, then the rest elements list[i .. length - 1]    // is smaller than or equal to one block size, so there is nothing to be    // merged. These rest elements will be merged when size = 2^k    // and 2^(k-1) &lt; length - 2^k &lt; 2^k,.    for (unsigned int i = 0 ; i &lt; length - size ; i += 2 * size) {      // Merge the adjacent two blocks.      merge(list, i, i + size - 1, std::min(i + 2 * size - 1, length - 1));      // mergeWithSentinel(list, i, i + size - 1, min(i + 2 * size - 1, length - 1));      // naiveInplaceMerge(list, i, i + size - 1, min(i + 2 * size - 1, length - 1)); // Slower!      // Uncomment below to check when the rest items will be merged.      // if ((size/2 &lt; length - size/2) &amp;&amp; (length - size &lt; size)) {      //   std::cout &lt;&lt; &quot;List length: &quot; &lt;&lt; length &lt;&lt; std::endl;      //   std::cout &lt;&lt; &quot;Merge the last &quot; &lt;&lt; length - size &lt;&lt;      //                &quot; items when size is &quot; &lt;&lt; size &lt;&lt; std::endl;      //   assert(min(i + 2 * size - 1, length - 1) == length - 1);      // }    }  }}void mergeSort(int list[], unsigned int length){  assert(length);  // topDownMergeSort(list, 0, length - 1);  bottomUpMergeSort(list, length);}AppendixCorrectness of naive in-place mergeProof by mathematical inductionLemma 1  Given a sorted list  with  elements,where ,and one value ,the list ( is appended to the end of list ),can be sorted by the naive in-place merge method with .  Base step: When , list  is trivially true  Induction Hypothesis: Suppose this assumption holds when   Induction Step: When           If , then the  is naturally sorted      Otherwise,  and the  and  are swapped.                  Now           By the hypothesis, the naive in-place merge works when , so we can a sorted           Thus, the list  now is sorted since  is sortedand all its elements are smaller than the current th element                     Lemma 2  Given a sorted list  with  elementswhere ,and  with  elementswhere ,the list can be sorted by the above naive in-place merge method with .  Base step: When , the condition is same as Lemma 1, so it’s true  Induction Hypothesis: Suppose this assumption holds when   Induction Step: When           When                   the element  will be merged with           then the list  is sorted by Lemma 1                    When                   the list is composed by sorted sublists and  with  elements          By the hypothesis, the naive in-place merge works when           Thus, the list  is sorted                    Reference  CS104  COS226  COMP250  DSA1112  CSC282" />
<meta property="og:description" content="Merge SortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaMerge sort is an efficient algorithm thatapplies the concepts of divide and conquer to sort the list.The key idea of divide and conquer is to recursively break down the problemsinto two or more sub-problems and they are same or related to the original problem,until these divided sub-problems are simple enough to solve directly.Then, the solutions of the original problem can be combined and derivedby the solutions of all the sub-problems.Divide and conquerThe calculation of Fibonacci number, ,is one example.To calculate , it needs to find  and .Similarly, to calculate , it needs to  and .The sub-problems for calculating  and  have same formas the one for .Recursively, we will need to get , , …, , and  and  are easy enough to solve directly. They are both .Thus, , , … and then can be computed.Dividing the sorting-problemLet’s apply this concept to the sorting problem.If we want to sort the list ,the sub-lists  must also be sorted,so we can narrow down our problem scope for handling the sub-lists.Next,  can be divided to and  also can be split into  and .Finally,  are not dividableso we stop breaking down the list.       [6, 3, 7, 1, 9, 2, 5]         /               \   [6, 3, 7, 1]       [9, 2, 5]    /        \          /     \ [6, 3]    [7, 1]    [9, 2]  [5] /    \    /    \    /    \[6]  [3]  [7]  [1]  [9]  [2]In the same way, the whole list can be divided into.Conquering the sub-problemsAfter there is only one element left,the subproblem is solved by nature since it’s already sorted.However, the problem becomes  how do we combine these sorted chunks into a sorted listWe need a method that can merge two sorted lists, and , where ,into a bigger sorted list .Combining all the results of sub-sorting-problemSuppose we have two sorted lists  and .We provide two ways to merge them into a sorted list.Picking the smallest elements one by oneThe simplest method is to pick the smallest elements iterativelyby searching both lists from the minimal to maximal.We only need to compare the left most elements of both listsand pick the smaller one since  and  are already sorted.The following example demonstrate the process of this idea:() &lt;- search indexA = [(3), 6, 10, 23]B = [(2), 7, 50, 55]L = []                            // &lt;- 2In the first round,  is picked since and going to be put into another list .                                  // You can think the left most element                                  // is shifted one by oneA = [(3), 6, 10, 23]              // [3, 6, 10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2]                           // &lt;- 3After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, (6), 10, 23]              // [6, 10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2, 3]                        // &lt;- 6After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, (10), 23]              // [10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2, 3, 6]                     // &lt;- 7After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, (10), 23]              // [10, 23]B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7]                  // &lt;- 10After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, 10, (23)]              // [23]B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7, 10]After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, 10, 23]                // []B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7, 10, 23]After  is picked, there is no need to compare againsince the  is the last element in .A = [3, 6, 10, 23]                // []B = [2, 7, 50, 55]                // []L = [2, 3, 6, 7, 10, 23, 50, 55]Next, we can append all the rest elementsfrom  to the end of  into the .Finally, we get a sort list .Swapping the elements one by oneAnother idea to merge the two sorted lists and ,is to couple them together into a list () &lt;- element who will be movedL = [3, 6, 10, 23, | (2), 7, 50, 55]// The &#39;|&#39; doesn&#39;t exist! It&#39;s only a notation for better explanation.and then move the minimal element of the later list()to the right position of the former list().The way for finding right the position is to compare the elements one by onefrom the end of the former list() to its head.() &lt;- element who will be movedL = [3, 6, 10, (2), 23, | 7, 50, 55]In our example, the  is swapped with  since .Then we keep comparing  with .() &lt;- element who will be movedL = [3, 6, (2), 10, 23, | 7, 50, 55]Similarly, the  are swapped since .() &lt;- element who will be movedL = [3, (2), 6,  10, 23, | 7, 50, 55]Next, the  are swapped since .() &lt;- element who will be movedL = [(2), 3, 6,  10, 23, | 7, 50, 55]Next, the  are swapped since .After this round, there is nothing to compare,so the  is moved to its right position.Now  and In the same way, we can do this process again with .It’s the minimal element of the later list  now.() &lt;- element who will be movedL = [2, 3, 6, 10, 23, | (7), 50, 55]L = [2, 3, 6, 10, (7), 23, | 50, 55]L = [2, 3, 6, (7), 10, 23, | 50, 55]L = [2, 3, 6, 7, 10, 23, | 50, 55]After this round,  and .Then do it again with with .() &lt;- element who will be movedL = [2, 3, 6,  7, 10, 23, | (50), 55]L = [2, 3, 6,  7, 10, 23, 50, | 55]However,  doesn’t move because .We just need to append  to the end of the former list .After this round,  and .() &lt;- element who will be movedL = [2, 3, 6,  7, 10, 23, 50, | (55)]L = [2, 3, 6,  7, 10, 23, 50, 55]It’s same to .It doesn’t need to be moved since ,so just append it to the .Finally,  and  is empty now.Now we have a sorted list !Which merge method is betterThe first method use extra space to store the sorted results,rather than the second in-place solution.On the other hand, the second method needs more swapping executionsand its a linear operation.For better performance, we take the first method as our approach here.Actually, there is a way to save the extra spaceand it works as fast as the first method above.However, it’s complicated.I will write another post for illustrating it.Please refer In-place merge sort in Elementary Algorithmsto read it.AlgorithmProofCorrectness of Merge  List L        &lt;------   sorted   ------&gt; &lt;------   sorted  -------&gt;        &lt;- merged -&gt; &lt;---  A  ---&gt; &lt;- merged -&gt; &lt;---  B  ---&gt;  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----   ... | l | ...... | i | ... | m | m+1 | .... | j | ... | r | ...  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----                      ^                          ^                head of sublist A          head of sublist B  List L&#39;   &lt;--   merged  --&gt; &lt;---   empty   ---&gt;  +---+-------+-----+---+-------+-------+  | 1 |  ...  | k-1 | k | ..... | r-l+1 |  +---+-------+-----+---+-------+-------+                      ^                head of empty area of list L&#39;  L[l...m]    : the sorted sublists for merging with L[m+1...r]  L[m+1...r]  : the sorted sublists for merging with L[l...m]  A, B        : the sublists containing elements that have NOT been merged yet  L&#39;[1...k-1] : the merged list from L[l...i-1] and L[m+1...j-1]  i: The index of the first element in L[l...m] that has NOT been merged yet  j: The index of the first element in L[m+1...r] that has NOT been merged yet  k: The index of next merged element copied from L[i] or L[j]Loop Invariant:At the beginning of the while-loop, the following conditions hold:  Sublists  and  are sorted   holds the elements from sublists  and   All elements in  is less or equal thansublists  and    are sorted.Formally, Then we use loop-invariants to prove:  Initialization: At the very beginning when           the input  are sorted so 1 holds      the list  is empty so 2, 3, 4 hold        Maintenance: Consider the iteration           1 is preserved since there is no change in       2 is preserved because                  If ,                           then               3 is preserved because and                                 Otherwise,                           then               3 is preserved because and                                           The previous appended element must be smaller thanthe current selected minimal element or 1 is false      By 3, the next selected minimal element will be larger than current one      So 4 is also preserved        Termination          By 2,  consists of the elements in       By 4,  are sorted      Correctness of Merge Sort  Given a list  with  elements,the  can be sortedby applying the above the MergeSort with .  Base step: When , it’s trivial.  Induction Hypothesis:Suppose this assumption holds when list has  elements  Induction Step: When           the list  is divide to ( elements)and ( elements)      so       and       By our hypothesis,  and  can be sorted      By the proved correctness of merge above,the merged  and  is also sorted,so the proof is done      Complexity  ^    +------------------------------------------------------+   Merge  |    |                           N                          |   Complexity  |    +------------------------------------------------------+  |                 |                              |  |                 v                              v  |    +------------------------+    +------------------------+  |    |           N/2          |    |           N/2          |   2 * O(N/2)  |    +------------------------+    +------------------------+  |         |              |              |              |            v              v              v              v  K    +---------+    +---------+    +---------+    +---------+       |   N/4   |    |   N/4   |    |   N/4   |    |   N/4   |   4 * O(N/4)  |    +---------+    +---------+    +---------+    +---------+  |      |     |        |     |        |     |        |     |  |      v     v        v     v        v     v        v     v  |  |                        .  .  .  .  .  .                       2^i * O(N/(2^i))  |  |    +---+  +---+  +---+                                +---+  |    | 1 |  | 1 |  | 1 |  .  .  .  .  .  .  .  .  .  .  | 1 |   N * O(1)  v    +---+  +---+  +---+                                +---+  N: the number of list elements.  K: K layers from N to 1.     N/2^k = 1 =&gt; N = 2^K =&gt; K = log_2(N)The above figure is the recursion tree of merge sort.The list containing  elements is recursively divided to sortuntil there is only one elements.Suppose that there is  times of division, therefore,On the other hand, the time complexitydepends on the performance of merge .The used merge here is the basic version.It iteratively picks the minimal elements from both subliststhen copied to another list .After all the elements in one sublist are all selected,we move the rest elements in the other sublist to list .Finally, we assigned , .Thus,  can be defined aswhere  is a constant reflecting the basic operationslike comparisons or assignments for merging routine.By the recursion treeFrom the above figure, the total time for the merge sort isThus, the time complexity is .By telescopingFormally, since the merge sort repeatedly breaks down the -elements listinto two -elements sublists,the amount of time that merge sort, ,can be written as follows:Thus, the time complexity is .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::min, std::swap#include &lt;cassert&gt;#include &lt;cstring&gt;    // for memcpy#include &quot;sorting.h&quot;/* * Merge sort: O(n * log(n)) */// Basic merge: O(n)// The following is the most straightforward way to merge two sorted array.// However, it allocates extra memory for sorted results in every recursion.void merge(int list[],           unsigned int left,           unsigned int division,           unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  unsigned int i = left;  unsigned int j = division + 1;  const unsigned int size = right - left + 1;  int array[size];  // When left &lt;= i &lt;= div and div + 1 &lt;= j &lt;= right:  // Compare list[i] and list[j], if list[i] &lt; list[j], then copy list[i] into  // the new array and let i = i + 1. Otherwise, copy list[j] into the new array  // and let j = j + 1. If i &gt; div, it means list[left...div] is all compared  // and already copied, so we just need to put the rest list[j...right] into  // the array. In the same way, if j &gt; right, then put the rest list[i...div]  // into the array.  unsigned int k = 0;  for (k = 0 ; k &lt; size; ++k) {    array[k] = (j &gt; right || (i &lt;= division &amp;&amp; list[i] &lt; list[j])) ? list[i++] : list[j++];  }  // while (i &lt;= division &amp;&amp; j &lt;= right) {  //   array[k++] = (list[i] &lt; list[j]) ? list[i++] : list[j++];  //   // if (list[i] &lt; list[j]) {  //   //   array[k] = list[i];  //   //   ++i;  //   // } else {  //   //   array[k] = list[j];  //   //   ++j;  //   // }  //   // ++k;  // }  //  // // In this case, j &gt; right, so we put the rest list[i...div] into the array.  // while (i &lt;= division) {  //   array[k++] = list[i++];  //   // array[k] = list[i];  //   // ++i;  //   // ++k;  // }  //  // // in this case, i &gt; div, so we put the rest list[j...right] into the array.  // while (j &lt;= right) {  //   array[k++] = list[j++];  //   // array[k] = list[j];  //   // ++j;  //   // ++k;  // }  assert(k == size);  assert(i == division + 1);  assert(j == right + 1);  // Overwrite list[left...right] by the new sorted array.  for (k = 0 ; k &lt; size ; ++k) {    list[left + k] = array[k];  }  assert(left + k == right + 1);}// Append ∞ as the last sentinel element to the both ordered arrays for merging.void mergeWithSentinel(int list[], unsigned int left, unsigned int division, unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  //      |&lt;---  A&#39;  ---&gt;|&lt;---  B&#39;  ---&gt;|  // Allocate list A = A&#39; ∪ [INFINITY] and list B = B&#39; ∪ [INFINITY]  const static int INFINITY = ((unsigned int)(-1) &gt;&gt; 1);  const unsigned int sizeA = division - left + 2; // (division - left + 1) + 1  const unsigned int sizeB = right - division + 1; // (right - (division + 1) + 1) + 1  int *A = new int[sizeA]; // 1 is for [ INFINITY ]  int *B = new int[sizeB];  // Copy elements from list[left...division] to A&#39;[0...(sizeA - 2)].  memcpy((void*)A, (void*)(list + left), sizeof(int) * (sizeA - 1));  // Copy elements from list[(division + 1)...right] to B&#39;[0...(sizeB - 2)].  memcpy((void*)B, (void*)(list + division + 1), sizeof(int) * (sizeB - 1));  // Set the last elements of A and B to INFINITY.  A[sizeA - 1] = B[sizeB - 1] = INFINITY;  // Move the sorted elements of A and B to list[left...right].  unsigned int i, j;  for (i = j = 0 ; left &lt;= right ; ++left) {    list[left] = A[i] &lt; B[j] ? A[i++] : B[j++];  }  free(A);  free(B);}// The following method demonstrates a in-place version of merge method.// However, it downgrades mergesort overall performance to quadratic O(n^2)!// Naive in-place merge: O(n^2)void naiveInplaceMerge(int list[],                       unsigned int left,                       unsigned int division,                       unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  unsigned int anchor = left;  for (unsigned int i = division + 1 ; i &lt;= right ; ++i) {    for (unsigned int j = i ; j &gt; anchor ; --j) { // Replace anchor with left is fine.      // The following condition is definitely true and will be triggered.      // list[division + k + 1] &gt;= list[division + k] where k &gt;= 1      // is assertive because list[division + 1 .... right] is a sorted from      // minimal item to maximal one.      if (list[j] &gt;= list[j-1]) {        anchor = j;        break;      }      std::swap(list[j], list[j-1]);    }  }}void topDownMergeSort(int list[], unsigned int left, unsigned int right){  if (left &gt;= right) {    return;  }  const unsigned int middle = (left + right) / 2;  topDownMergeSort(list, left, middle);  topDownMergeSort(list, middle + 1, right);  merge(list, left, middle, right);  // mergeWithSentinel(list, left, middle, right);  // naiveInplaceMerge(list, left, middle, right); // Slower!}void bottomUpMergeSort(int list[], unsigned int length){  // &lt;----------  l = 2^k + r  ----------&gt;  where k, r are integers, k &gt;= 0,  // &lt;-----  2^k  -----&gt;|&lt;-----  r  -----&gt;  and 0 &lt;= r &lt; 2^k.  // +---+---+---------+---+---------+---+  // | 0 | 1 | ....... | n | ....... | m |  // +---+---+---------+---+---------+---+  //  // l            k  r  // 1 : 2^0 + 0  0  0  // 2 : 2^1 + 0  1  0  // 3 : 2^1 + 1  1  1  // 4 : 2^2 + 0  2  0  // 5 : 2^2 + 1  2  1  // 6 : 2^2 + 2  2  2  // 7 : 2^2 + 3  2  3  // 8 : 2^3 + 0  3  0  // 9 : 2^3 + 1  3  1  // ...  // ...  //  // When r = 0:  The length of list is powers of 2, denoted 2^k, so all the  //              size of blocks for merging must be same. At the round (k+1),  //              the size is 2^k, where k &gt;= 0 is a integer.  // When r != 0: We can consider there are extra &#39;r&#39; elements added into the  //              above list whose length is powers of 2.  //              The extra &#39;r&#39; elements will be merged when the block size is  //              grown to 2^k, where k &gt;= 0 and 0 &lt; r &lt; 2^k.  //  // Each round, the list is divided into blocks and then merged  // from size 1, 2, 4, ... to lenght/2.  for (unsigned int size = 1 ; size &lt; length ; size *= 2) {    // If i &gt;= length - size, then the rest elements list[i .. length - 1]    // is smaller than or equal to one block size, so there is nothing to be    // merged. These rest elements will be merged when size = 2^k    // and 2^(k-1) &lt; length - 2^k &lt; 2^k,.    for (unsigned int i = 0 ; i &lt; length - size ; i += 2 * size) {      // Merge the adjacent two blocks.      merge(list, i, i + size - 1, std::min(i + 2 * size - 1, length - 1));      // mergeWithSentinel(list, i, i + size - 1, min(i + 2 * size - 1, length - 1));      // naiveInplaceMerge(list, i, i + size - 1, min(i + 2 * size - 1, length - 1)); // Slower!      // Uncomment below to check when the rest items will be merged.      // if ((size/2 &lt; length - size/2) &amp;&amp; (length - size &lt; size)) {      //   std::cout &lt;&lt; &quot;List length: &quot; &lt;&lt; length &lt;&lt; std::endl;      //   std::cout &lt;&lt; &quot;Merge the last &quot; &lt;&lt; length - size &lt;&lt;      //                &quot; items when size is &quot; &lt;&lt; size &lt;&lt; std::endl;      //   assert(min(i + 2 * size - 1, length - 1) == length - 1);      // }    }  }}void mergeSort(int list[], unsigned int length){  assert(length);  // topDownMergeSort(list, 0, length - 1);  bottomUpMergeSort(list, length);}AppendixCorrectness of naive in-place mergeProof by mathematical inductionLemma 1  Given a sorted list  with  elements,where ,and one value ,the list ( is appended to the end of list ),can be sorted by the naive in-place merge method with .  Base step: When , list  is trivially true  Induction Hypothesis: Suppose this assumption holds when   Induction Step: When           If , then the  is naturally sorted      Otherwise,  and the  and  are swapped.                  Now           By the hypothesis, the naive in-place merge works when , so we can a sorted           Thus, the list  now is sorted since  is sortedand all its elements are smaller than the current th element                     Lemma 2  Given a sorted list  with  elementswhere ,and  with  elementswhere ,the list can be sorted by the above naive in-place merge method with .  Base step: When , the condition is same as Lemma 1, so it’s true  Induction Hypothesis: Suppose this assumption holds when   Induction Step: When           When                   the element  will be merged with           then the list  is sorted by Lemma 1                    When                   the list is composed by sorted sublists and  with  elements          By the hypothesis, the naive in-place merge works when           Thus, the list  is sorted                    Reference  CS104  COS226  COMP250  DSA1112  CSC282" />
<link rel="canonical" href="http://localhost:4000/post/merge-sort" />
<meta property="og:url" content="http://localhost:4000/post/merge-sort" />
<meta property="og:site_name" content="Peak Up" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-05T00:00:00+08:00" />
<link rel="next" href="http://localhost:4000/post/lunar-new-year" title="Lunar New Year" />
<link rel="prev" href="http://localhost:4000/post/bubble-sort" title="Bubble Sort" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Merge Sort",
    "datePublished": "2017-01-05T00:00:00+08:00",
    "description": "Merge SortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaMerge sort is an efficient algorithm thatapplies the concepts of divide and conquer to sort the list.The key idea of divide and conquer is to recursively break down the problemsinto two or more sub-problems and they are same or related to the original problem,until these divided sub-problems are simple enough to solve directly.Then, the solutions of the original problem can be combined and derivedby the solutions of all the sub-problems.Divide and conquerThe calculation of Fibonacci number, ,is one example.To calculate , it needs to find  and .Similarly, to calculate , it needs to  and .The sub-problems for calculating  and  have same formas the one for .Recursively, we will need to get , , …, , and  and  are easy enough to solve directly. They are both .Thus, , , … and then can be computed.Dividing the sorting-problemLet’s apply this concept to the sorting problem.If we want to sort the list ,the sub-lists  must also be sorted,so we can narrow down our problem scope for handling the sub-lists.Next,  can be divided to and  also can be split into  and .Finally,  are not dividableso we stop breaking down the list.       [6, 3, 7, 1, 9, 2, 5]         /               \\   [6, 3, 7, 1]       [9, 2, 5]    /        \\          /     \\ [6, 3]    [7, 1]    [9, 2]  [5] /    \\    /    \\    /    \\[6]  [3]  [7]  [1]  [9]  [2]In the same way, the whole list can be divided into.Conquering the sub-problemsAfter there is only one element left,the subproblem is solved by nature since it’s already sorted.However, the problem becomes  how do we combine these sorted chunks into a sorted listWe need a method that can merge two sorted lists, and , where ,into a bigger sorted list .Combining all the results of sub-sorting-problemSuppose we have two sorted lists  and .We provide two ways to merge them into a sorted list.Picking the smallest elements one by oneThe simplest method is to pick the smallest elements iterativelyby searching both lists from the minimal to maximal.We only need to compare the left most elements of both listsand pick the smaller one since  and  are already sorted.The following example demonstrate the process of this idea:() &lt;- search indexA = [(3), 6, 10, 23]B = [(2), 7, 50, 55]L = []                            // &lt;- 2In the first round,  is picked since and going to be put into another list .                                  // You can think the left most element                                  // is shifted one by oneA = [(3), 6, 10, 23]              // [3, 6, 10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2]                           // &lt;- 3After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, (6), 10, 23]              // [6, 10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2, 3]                        // &lt;- 6After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, (10), 23]              // [10, 23]B = [2, (7), 50, 55]              // [7, 50, 55]L = [2, 3, 6]                     // &lt;- 7After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, (10), 23]              // [10, 23]B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7]                  // &lt;- 10After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, 10, (23)]              // [23]B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7, 10]After  is picked, we move the index of  from  to .Next,  is picked since  and going to be put into .A = [3, 6, 10, 23]                // []B = [2, 7, (50), 55]              // [50, 55]L = [2, 3, 6, 7, 10, 23]After  is picked, there is no need to compare againsince the  is the last element in .A = [3, 6, 10, 23]                // []B = [2, 7, 50, 55]                // []L = [2, 3, 6, 7, 10, 23, 50, 55]Next, we can append all the rest elementsfrom  to the end of  into the .Finally, we get a sort list .Swapping the elements one by oneAnother idea to merge the two sorted lists and ,is to couple them together into a list () &lt;- element who will be movedL = [3, 6, 10, 23, | (2), 7, 50, 55]// The &#39;|&#39; doesn&#39;t exist! It&#39;s only a notation for better explanation.and then move the minimal element of the later list()to the right position of the former list().The way for finding right the position is to compare the elements one by onefrom the end of the former list() to its head.() &lt;- element who will be movedL = [3, 6, 10, (2), 23, | 7, 50, 55]In our example, the  is swapped with  since .Then we keep comparing  with .() &lt;- element who will be movedL = [3, 6, (2), 10, 23, | 7, 50, 55]Similarly, the  are swapped since .() &lt;- element who will be movedL = [3, (2), 6,  10, 23, | 7, 50, 55]Next, the  are swapped since .() &lt;- element who will be movedL = [(2), 3, 6,  10, 23, | 7, 50, 55]Next, the  are swapped since .After this round, there is nothing to compare,so the  is moved to its right position.Now  and In the same way, we can do this process again with .It’s the minimal element of the later list  now.() &lt;- element who will be movedL = [2, 3, 6, 10, 23, | (7), 50, 55]L = [2, 3, 6, 10, (7), 23, | 50, 55]L = [2, 3, 6, (7), 10, 23, | 50, 55]L = [2, 3, 6, 7, 10, 23, | 50, 55]After this round,  and .Then do it again with with .() &lt;- element who will be movedL = [2, 3, 6,  7, 10, 23, | (50), 55]L = [2, 3, 6,  7, 10, 23, 50, | 55]However,  doesn’t move because .We just need to append  to the end of the former list .After this round,  and .() &lt;- element who will be movedL = [2, 3, 6,  7, 10, 23, 50, | (55)]L = [2, 3, 6,  7, 10, 23, 50, 55]It’s same to .It doesn’t need to be moved since ,so just append it to the .Finally,  and  is empty now.Now we have a sorted list !Which merge method is betterThe first method use extra space to store the sorted results,rather than the second in-place solution.On the other hand, the second method needs more swapping executionsand its a linear operation.For better performance, we take the first method as our approach here.Actually, there is a way to save the extra spaceand it works as fast as the first method above.However, it’s complicated.I will write another post for illustrating it.Please refer In-place merge sort in Elementary Algorithmsto read it.AlgorithmProofCorrectness of Merge  List L        &lt;------   sorted   ------&gt; &lt;------   sorted  -------&gt;        &lt;- merged -&gt; &lt;---  A  ---&gt; &lt;- merged -&gt; &lt;---  B  ---&gt;  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----   ... | l | ...... | i | ... | m | m+1 | .... | j | ... | r | ...  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----                      ^                          ^                head of sublist A          head of sublist B  List L&#39;   &lt;--   merged  --&gt; &lt;---   empty   ---&gt;  +---+-------+-----+---+-------+-------+  | 1 |  ...  | k-1 | k | ..... | r-l+1 |  +---+-------+-----+---+-------+-------+                      ^                head of empty area of list L&#39;  L[l...m]    : the sorted sublists for merging with L[m+1...r]  L[m+1...r]  : the sorted sublists for merging with L[l...m]  A, B        : the sublists containing elements that have NOT been merged yet  L&#39;[1...k-1] : the merged list from L[l...i-1] and L[m+1...j-1]  i: The index of the first element in L[l...m] that has NOT been merged yet  j: The index of the first element in L[m+1...r] that has NOT been merged yet  k: The index of next merged element copied from L[i] or L[j]Loop Invariant:At the beginning of the while-loop, the following conditions hold:  Sublists  and  are sorted   holds the elements from sublists  and   All elements in  is less or equal thansublists  and    are sorted.Formally, Then we use loop-invariants to prove:  Initialization: At the very beginning when           the input  are sorted so 1 holds      the list  is empty so 2, 3, 4 hold        Maintenance: Consider the iteration           1 is preserved since there is no change in       2 is preserved because                  If ,                           then               3 is preserved because and                                 Otherwise,                           then               3 is preserved because and                                           The previous appended element must be smaller thanthe current selected minimal element or 1 is false      By 3, the next selected minimal element will be larger than current one      So 4 is also preserved        Termination          By 2,  consists of the elements in       By 4,  are sorted      Correctness of Merge Sort  Given a list  with  elements,the  can be sortedby applying the above the MergeSort with .  Base step: When , it’s trivial.  Induction Hypothesis:Suppose this assumption holds when list has  elements  Induction Step: When           the list  is divide to ( elements)and ( elements)      so       and       By our hypothesis,  and  can be sorted      By the proved correctness of merge above,the merged  and  is also sorted,so the proof is done      Complexity  ^    +------------------------------------------------------+   Merge  |    |                           N                          |   Complexity  |    +------------------------------------------------------+  |                 |                              |  |                 v                              v  |    +------------------------+    +------------------------+  |    |           N/2          |    |           N/2          |   2 * O(N/2)  |    +------------------------+    +------------------------+  |         |              |              |              |            v              v              v              v  K    +---------+    +---------+    +---------+    +---------+       |   N/4   |    |   N/4   |    |   N/4   |    |   N/4   |   4 * O(N/4)  |    +---------+    +---------+    +---------+    +---------+  |      |     |        |     |        |     |        |     |  |      v     v        v     v        v     v        v     v  |  |                        .  .  .  .  .  .                       2^i * O(N/(2^i))  |  |    +---+  +---+  +---+                                +---+  |    | 1 |  | 1 |  | 1 |  .  .  .  .  .  .  .  .  .  .  | 1 |   N * O(1)  v    +---+  +---+  +---+                                +---+  N: the number of list elements.  K: K layers from N to 1.     N/2^k = 1 =&gt; N = 2^K =&gt; K = log_2(N)The above figure is the recursion tree of merge sort.The list containing  elements is recursively divided to sortuntil there is only one elements.Suppose that there is  times of division, therefore,On the other hand, the time complexitydepends on the performance of merge .The used merge here is the basic version.It iteratively picks the minimal elements from both subliststhen copied to another list .After all the elements in one sublist are all selected,we move the rest elements in the other sublist to list .Finally, we assigned , .Thus,  can be defined aswhere  is a constant reflecting the basic operationslike comparisons or assignments for merging routine.By the recursion treeFrom the above figure, the total time for the merge sort isThus, the time complexity is .By telescopingFormally, since the merge sort repeatedly breaks down the -elements listinto two -elements sublists,the amount of time that merge sort, ,can be written as follows:Thus, the time complexity is .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::min, std::swap#include &lt;cassert&gt;#include &lt;cstring&gt;    // for memcpy#include &quot;sorting.h&quot;/* * Merge sort: O(n * log(n)) */// Basic merge: O(n)// The following is the most straightforward way to merge two sorted array.// However, it allocates extra memory for sorted results in every recursion.void merge(int list[],           unsigned int left,           unsigned int division,           unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  unsigned int i = left;  unsigned int j = division + 1;  const unsigned int size = right - left + 1;  int array[size];  // When left &lt;= i &lt;= div and div + 1 &lt;= j &lt;= right:  // Compare list[i] and list[j], if list[i] &lt; list[j], then copy list[i] into  // the new array and let i = i + 1. Otherwise, copy list[j] into the new array  // and let j = j + 1. If i &gt; div, it means list[left...div] is all compared  // and already copied, so we just need to put the rest list[j...right] into  // the array. In the same way, if j &gt; right, then put the rest list[i...div]  // into the array.  unsigned int k = 0;  for (k = 0 ; k &lt; size; ++k) {    array[k] = (j &gt; right || (i &lt;= division &amp;&amp; list[i] &lt; list[j])) ? list[i++] : list[j++];  }  // while (i &lt;= division &amp;&amp; j &lt;= right) {  //   array[k++] = (list[i] &lt; list[j]) ? list[i++] : list[j++];  //   // if (list[i] &lt; list[j]) {  //   //   array[k] = list[i];  //   //   ++i;  //   // } else {  //   //   array[k] = list[j];  //   //   ++j;  //   // }  //   // ++k;  // }  //  // // In this case, j &gt; right, so we put the rest list[i...div] into the array.  // while (i &lt;= division) {  //   array[k++] = list[i++];  //   // array[k] = list[i];  //   // ++i;  //   // ++k;  // }  //  // // in this case, i &gt; div, so we put the rest list[j...right] into the array.  // while (j &lt;= right) {  //   array[k++] = list[j++];  //   // array[k] = list[j];  //   // ++j;  //   // ++k;  // }  assert(k == size);  assert(i == division + 1);  assert(j == right + 1);  // Overwrite list[left...right] by the new sorted array.  for (k = 0 ; k &lt; size ; ++k) {    list[left + k] = array[k];  }  assert(left + k == right + 1);}// Append ∞ as the last sentinel element to the both ordered arrays for merging.void mergeWithSentinel(int list[], unsigned int left, unsigned int division, unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  //      |&lt;---  A&#39;  ---&gt;|&lt;---  B&#39;  ---&gt;|  // Allocate list A = A&#39; ∪ [INFINITY] and list B = B&#39; ∪ [INFINITY]  const static int INFINITY = ((unsigned int)(-1) &gt;&gt; 1);  const unsigned int sizeA = division - left + 2; // (division - left + 1) + 1  const unsigned int sizeB = right - division + 1; // (right - (division + 1) + 1) + 1  int *A = new int[sizeA]; // 1 is for [ INFINITY ]  int *B = new int[sizeB];  // Copy elements from list[left...division] to A&#39;[0...(sizeA - 2)].  memcpy((void*)A, (void*)(list + left), sizeof(int) * (sizeA - 1));  // Copy elements from list[(division + 1)...right] to B&#39;[0...(sizeB - 2)].  memcpy((void*)B, (void*)(list + division + 1), sizeof(int) * (sizeB - 1));  // Set the last elements of A and B to INFINITY.  A[sizeA - 1] = B[sizeB - 1] = INFINITY;  // Move the sorted elements of A and B to list[left...right].  unsigned int i, j;  for (i = j = 0 ; left &lt;= right ; ++left) {    list[left] = A[i] &lt; B[j] ? A[i++] : B[j++];  }  free(A);  free(B);}// The following method demonstrates a in-place version of merge method.// However, it downgrades mergesort overall performance to quadratic O(n^2)!// Naive in-place merge: O(n^2)void naiveInplaceMerge(int list[],                       unsigned int left,                       unsigned int division,                       unsigned int right){  assert(left &lt;= right);  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|  // -----+---+------+---+---+------+---+-----  //  ... | l | .... | m | n | .... | r | ...  // -----+---+------+---+---+------+---+-----  //        ^          ^   ^          ^  //      left       div  div+1    right  unsigned int anchor = left;  for (unsigned int i = division + 1 ; i &lt;= right ; ++i) {    for (unsigned int j = i ; j &gt; anchor ; --j) { // Replace anchor with left is fine.      // The following condition is definitely true and will be triggered.      // list[division + k + 1] &gt;= list[division + k] where k &gt;= 1      // is assertive because list[division + 1 .... right] is a sorted from      // minimal item to maximal one.      if (list[j] &gt;= list[j-1]) {        anchor = j;        break;      }      std::swap(list[j], list[j-1]);    }  }}void topDownMergeSort(int list[], unsigned int left, unsigned int right){  if (left &gt;= right) {    return;  }  const unsigned int middle = (left + right) / 2;  topDownMergeSort(list, left, middle);  topDownMergeSort(list, middle + 1, right);  merge(list, left, middle, right);  // mergeWithSentinel(list, left, middle, right);  // naiveInplaceMerge(list, left, middle, right); // Slower!}void bottomUpMergeSort(int list[], unsigned int length){  // &lt;----------  l = 2^k + r  ----------&gt;  where k, r are integers, k &gt;= 0,  // &lt;-----  2^k  -----&gt;|&lt;-----  r  -----&gt;  and 0 &lt;= r &lt; 2^k.  // +---+---+---------+---+---------+---+  // | 0 | 1 | ....... | n | ....... | m |  // +---+---+---------+---+---------+---+  //  // l            k  r  // 1 : 2^0 + 0  0  0  // 2 : 2^1 + 0  1  0  // 3 : 2^1 + 1  1  1  // 4 : 2^2 + 0  2  0  // 5 : 2^2 + 1  2  1  // 6 : 2^2 + 2  2  2  // 7 : 2^2 + 3  2  3  // 8 : 2^3 + 0  3  0  // 9 : 2^3 + 1  3  1  // ...  // ...  //  // When r = 0:  The length of list is powers of 2, denoted 2^k, so all the  //              size of blocks for merging must be same. At the round (k+1),  //              the size is 2^k, where k &gt;= 0 is a integer.  // When r != 0: We can consider there are extra &#39;r&#39; elements added into the  //              above list whose length is powers of 2.  //              The extra &#39;r&#39; elements will be merged when the block size is  //              grown to 2^k, where k &gt;= 0 and 0 &lt; r &lt; 2^k.  //  // Each round, the list is divided into blocks and then merged  // from size 1, 2, 4, ... to lenght/2.  for (unsigned int size = 1 ; size &lt; length ; size *= 2) {    // If i &gt;= length - size, then the rest elements list[i .. length - 1]    // is smaller than or equal to one block size, so there is nothing to be    // merged. These rest elements will be merged when size = 2^k    // and 2^(k-1) &lt; length - 2^k &lt; 2^k,.    for (unsigned int i = 0 ; i &lt; length - size ; i += 2 * size) {      // Merge the adjacent two blocks.      merge(list, i, i + size - 1, std::min(i + 2 * size - 1, length - 1));      // mergeWithSentinel(list, i, i + size - 1, min(i + 2 * size - 1, length - 1));      // naiveInplaceMerge(list, i, i + size - 1, min(i + 2 * size - 1, length - 1)); // Slower!      // Uncomment below to check when the rest items will be merged.      // if ((size/2 &lt; length - size/2) &amp;&amp; (length - size &lt; size)) {      //   std::cout &lt;&lt; &quot;List length: &quot; &lt;&lt; length &lt;&lt; std::endl;      //   std::cout &lt;&lt; &quot;Merge the last &quot; &lt;&lt; length - size &lt;&lt;      //                &quot; items when size is &quot; &lt;&lt; size &lt;&lt; std::endl;      //   assert(min(i + 2 * size - 1, length - 1) == length - 1);      // }    }  }}void mergeSort(int list[], unsigned int length){  assert(length);  // topDownMergeSort(list, 0, length - 1);  bottomUpMergeSort(list, length);}AppendixCorrectness of naive in-place mergeProof by mathematical inductionLemma 1  Given a sorted list  with  elements,where ,and one value ,the list ( is appended to the end of list ),can be sorted by the naive in-place merge method with .  Base step: When , list  is trivially true  Induction Hypothesis: Suppose this assumption holds when   Induction Step: When           If , then the  is naturally sorted      Otherwise,  and the  and  are swapped.                  Now           By the hypothesis, the naive in-place merge works when , so we can a sorted           Thus, the list  now is sorted since  is sortedand all its elements are smaller than the current th element                     Lemma 2  Given a sorted list  with  elementswhere ,and  with  elementswhere ,the list can be sorted by the above naive in-place merge method with .  Base step: When , the condition is same as Lemma 1, so it’s true  Induction Hypothesis: Suppose this assumption holds when   Induction Step: When           When                   the element  will be merged with           then the list  is sorted by Lemma 1                    When                   the list is composed by sorted sublists and  with  elements          By the hypothesis, the naive in-place merge works when           Thus, the list  is sorted                    Reference  CS104  COS226  COMP250  DSA1112  CSC282",
    "logo": "http://localhost:4000mountain.png",
    "url": "http://localhost:4000/post/merge-sort"
  }
</script>
<!-- End Jekyll SEO tag -->

<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Peak Up" />

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
    crossorigin="anonymous">

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/style.css" />
<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/syntax.css" />


<!--Load Mathjax-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
        MathJax.Hub.Config({
            config: ["MMLorHTML.js"],
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: false
            },
            TeX: {
                TagSide: "right",
                TagIndent: ".8em",
                MultLineWidth: "85%",
                equationNumbers: {
                   autoNumber: "AMS",
                },
                unicode: {
                   fonts: "STIXGeneral,'Arial Unicode MS'"
                }
            },
            showProcessingMessages: false
        });
</script>



<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/favicons/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/favicons/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/favicons/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/favicons/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post-template" itemscope itemtype="http://schema.org/WebPage">

    
<div class="search-wrapper">
    <div class="search-form">
        <input type="text" id="search-input" class="search-field" placeholder="Search...">
        <i id="search-close" class="fa fa-times-circle"></i>
        <h4>Search results</h4>
        <ul id="results-container" class="search-results post-list">
        </ul>
        <!-- /.search-results -->
    </div>
    <!-- /.search-form -->
</div>
<!-- ./search-wrapper -->


<div id="fade"></div>
<a id="slide" class="animated fade">
    <i class="fa fa-bars" aria-hidden="true"></i>
</a>
<aside id="sidebar">
    <nav id="navigation">
        <h2>MENU</h2>
        <hr>
        <ul> 
            <li>
                <a href="http://localhost:4000/"><!-- <i class="fa fa-home"></i>&nbsp;-->Home</a>  </li>
            
            <li>
                <a href="http://localhost:4000/categories"><!-- <i class="fa fa-sitemap"></i>&nbsp;-->Categories</a>  </li>
            
            <li>
                <a href="http://localhost:4000/tags"><!-- <i class="fa fa-tags"></i>&nbsp;-->Tags</a>  </li>
            
            <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
        </ul>
    </nav>
</aside>


<header id="masthead" class="blog-background overlay align-center align-middle animated from-bottom" style="background-image: url(http://localhost:4000/images/background/yosemite/yosemite1.png)"
    itemscope itemtype="http://schema.org/Organization">



    <button class="menu-button animated fade dosearch">
        <i class="fa fa-search"></i>
    </button>



    <div class="inner">
        <div class="container">
            <a class="brand" href="http://localhost:4000/" itemprop="url">
                <img itemprop="logo" src="http://localhost:4000/images/mountain.png" alt="Peak Up Logo" />
                <h1 class="blog-title light" itemprop="name">
                    Peak Up
                </h1>
            </a>
        </div>
    </div>



    <div class="decor-wrapper">
        <svg id="header-decor" class="decor bottom" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 100 L50 50 L0 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 100 L50 50 L100 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 100 L50 50 L0 66.6" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 100 L50 50 L100 66.6" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>

</header>


    <div id="main" class="content" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
        <div class="container">
            <div class="row">
                <article class="post col-md-8 col-md-offset-2 hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
                
                
                
                

                    <header class="post-header entry-header">

                    

                    
                        <h1 class="post-title text-center hyper lighter bordered-bottom entry-title" itemprop="headline">
                        
                            
                        
                        
                        

                        
                            Merge Sort
                        </h1>
                    

                        <div class="cursive" style="color: #000; font-style:italic;"></div>

                            <div class="post-info text-center small">
                            
                                <span class="entry-date date published updated">
                            
                            
                                    <time datetime="2017-01-05T00:00:00+08:00" class="post-time" itemprop="datePublished">05 Jan 2017</time>
                                </span>
                            

                                in <span class="post-tags">

                            
                                    <a href="http://localhost:4000/categories/index.html#Algorithm" data-toggle="tooltip" title="Other posts from the Algorithm category" rel="tag">Algorithm</a>
                                
                            
                                </span>
                            
                            &nbsp;
                                <span class="post-tags"><i class="fa fa-clock-o"></i>&nbsp;

                            

                            
                                    <span class="time">20.416666666666668</span> minutes read
                            
                                
                            

                                </span>
                            
                            </div>

                    </header>

                    <div class="post-body bordered-bottom" itemprop="description">
                    

                        <h1 id="merge-sort">Merge Sort</h1>

<p>This post series is synchronized with my book <a href="https://www.gitbook.com/book/chunminchang/codeplay/details" title="CodePlay">CodePlay</a>
and this post could be read <a href="https://chunminchang.gitbooks.io/codeplay/content/sorting/merge_sort.html" title="Merge Sort">here</a>.</p>

<h2 id="idea">Idea</h2>
<p><em>Merge sort</em> is an efficient algorithm that
applies the concepts of <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" title="Divide and conquer algorithm"><em>divide and conquer</em></a> to sort the list.</p>

<p>The key idea of <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" title="Divide and conquer algorithm"><em>divide and conquer</em></a> is to recursively break down the problems
into two or more sub-problems and they are same or related to the original problem,
until these divided sub-problems are simple enough to solve directly.
Then, the solutions of the original problem can be combined and derived
by the solutions of all the sub-problems.</p>

<h3 id="divide-and-conquer">Divide and conquer</h3>
<p>The calculation of <a href="https://en.wikipedia.org/wiki/Fibonacci_number" title="Fibonacci number"><em>Fibonacci number</em></a>, <script type="math/tex">F(n) = F(n-1) + F(n-2)</script>,
is one example.
To calculate <script type="math/tex">F(n)</script>, it needs to find <script type="math/tex">F(n-1)</script> and <script type="math/tex">F(n-2)</script>.
Similarly, to calculate <script type="math/tex">F(n-1)</script>, it needs to <script type="math/tex">F(n-2)</script> and <script type="math/tex">F(n-3)</script>.
The sub-problems for calculating <script type="math/tex">F(n-1)</script> and <script type="math/tex">F(n-2)</script> have same form
as the one for <script type="math/tex">F(n)</script>.</p>

<p>Recursively, we will need to get <script type="math/tex">F(n-1)</script>, <script type="math/tex">F(n-2)</script>, …, <script type="math/tex">F(2)</script>, <script type="math/tex">F(1)</script>
and <script type="math/tex">F(1)</script> and <script type="math/tex">F(2)</script> are easy enough to solve directly. They are both <script type="math/tex">1</script>.
Thus, <script type="math/tex">F(3) = F(2) + F(1) = 2</script>, <script type="math/tex">F(4) = F(3) + F(2) = 3</script>, … and then <script type="math/tex">F(n)</script>
can be computed.</p>

<h3 id="dividing-the-sorting-problem">Dividing the sorting-problem</h3>
<p>Let’s apply this concept to the sorting problem.
If we want to sort the list <script type="math/tex">L = [6, 3, 7, 1, 9, 2, 5]</script>,
the sub-lists <script type="math/tex">[6, 3, 7, 1], [9, 2, 5]</script> must also be sorted,
so we can narrow down our problem scope for handling the sub-lists.
Next, <script type="math/tex">[6, 3, 7, 1]</script> can be divided to <script type="math/tex">[6, 3], [7, 1]</script>
and <script type="math/tex">[6, 3]</script> also can be split into <script type="math/tex">[6]</script> and <script type="math/tex">[3]</script>.
Finally, <script type="math/tex">[6], [3]</script> are not dividable
so we stop breaking down the list.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>       [6, 3, 7, 1, 9, 2, 5]
         /               \
   [6, 3, 7, 1]       [9, 2, 5]
    /        \          /     \
 [6, 3]    [7, 1]    [9, 2]  [5]
 /    \    /    \    /    \
[6]  [3]  [7]  [1]  [9]  [2]
</code></pre>
</div>

<p>In the same way, the whole list can be divided into
<script type="math/tex">[6], [3], [7], [1], [9], [2], [5]</script>.</p>

<h3 id="conquering-the-sub-problems">Conquering the sub-problems</h3>
<p>After there is only one element left,
the subproblem is solved by nature since it’s already sorted.</p>

<p>However, the problem becomes</p>
<blockquote>
  <p>how do we combine these sorted chunks into a sorted list</p>
</blockquote>

<p>We need a method that can merge two sorted lists,
<script type="math/tex">L_1[1...X]</script> and <script type="math/tex">L_2[1...Y]</script>, where <script type="math/tex">X, Y \geq 1</script>,
into a bigger sorted list <script type="math/tex">L[1...(X+Y)]</script>.</p>

<h3 id="combining-all-the-results-of-sub-sorting-problem">Combining all the results of sub-sorting-problem</h3>

<p>Suppose we have two sorted lists <script type="math/tex">A = [3, 6, 10, 23]</script> and <script type="math/tex">B = [2, 7, 50, 55]</script>.
We provide two ways to merge them into a sorted list.</p>

<h4 id="picking-the-smallest-elements-one-by-one">Picking the smallest elements one by one</h4>
<p>The simplest method is to pick the smallest elements iteratively
by searching both lists from the minimal to maximal.</p>

<p>We only need to compare the left most elements of both lists
and pick the smaller one since <script type="math/tex">A</script> and <script type="math/tex">B</script> are already sorted.</p>

<p>The following example demonstrate the process of this idea:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- search index

A = [(3), 6, 10, 23]
B = [(2), 7, 50, 55]
L = []                            // &lt;- 2
</code></pre>
</div>
<p>In the first round, <script type="math/tex">2</script> is picked since <script type="math/tex">% <![CDATA[
2 < 3 %]]></script>
and going to be put into another list <script type="math/tex">L</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>                                  // You can think the left most element
                                  // is shifted one by one
A = [(3), 6, 10, 23]              // [3, 6, 10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2]                           // &lt;- 3
</code></pre>
</div>

<p>After <script type="math/tex">2</script> is picked, we move the index of <script type="math/tex">B</script> from <script type="math/tex">2</script> to <script type="math/tex">7</script>.
Next, <script type="math/tex">3</script> is picked since <script type="math/tex">% <![CDATA[
3 < 7 %]]></script> and going to be put into <script type="math/tex">L</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A = [3, (6), 10, 23]              // [6, 10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2, 3]                        // &lt;- 6
</code></pre>
</div>

<p>After <script type="math/tex">3</script> is picked, we move the index of <script type="math/tex">A</script> from <script type="math/tex">3</script> to <script type="math/tex">6</script>.
Next, <script type="math/tex">6</script> is picked since <script type="math/tex">% <![CDATA[
6 < 7 %]]></script> and going to be put into <script type="math/tex">L</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A = [3, 6, (10), 23]              // [10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2, 3, 6]                     // &lt;- 7
</code></pre>
</div>

<p>After <script type="math/tex">6</script> is picked, we move the index of <script type="math/tex">A</script> from <script type="math/tex">6</script> to <script type="math/tex">10</script>.
Next, <script type="math/tex">7</script> is picked since <script type="math/tex">% <![CDATA[
7 < 10 %]]></script> and going to be put into <script type="math/tex">L</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A = [3, 6, (10), 23]              // [10, 23]
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7]                  // &lt;- 10
</code></pre>
</div>

<p>After <script type="math/tex">7</script> is picked, we move the index of <script type="math/tex">B</script> from <script type="math/tex">7</script> to <script type="math/tex">50</script>.
Next, <script type="math/tex">10</script> is picked since <script type="math/tex">% <![CDATA[
10 < 50 %]]></script> and going to be put into <script type="math/tex">L</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A = [3, 6, 10, (23)]              // [23]
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7, 10]
</code></pre>
</div>

<p>After <script type="math/tex">10</script> is picked, we move the index of <script type="math/tex">A</script> from <script type="math/tex">10</script> to <script type="math/tex">23</script>.
Next, <script type="math/tex">23</script> is picked since <script type="math/tex">% <![CDATA[
23 < 50 %]]></script> and going to be put into <script type="math/tex">L</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A = [3, 6, 10, 23]                // []
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7, 10, 23]
</code></pre>
</div>

<p>After <script type="math/tex">23</script> is picked, there is no need to compare again
since the <script type="math/tex">23</script> is the last element in <script type="math/tex">A</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A = [3, 6, 10, 23]                // []
B = [2, 7, 50, 55]                // []
L = [2, 3, 6, 7, 10, 23, 50, 55]
</code></pre>
</div>

<p>Next, we can append all the rest elements
from <script type="math/tex">50</script> to the end of <script type="math/tex">B</script> into the <script type="math/tex">L</script>.
Finally, we get a sort list <script type="math/tex">L</script>.</p>

<h4 id="swapping-the-elements-one-by-one">Swapping the elements one by one</h4>

<p>Another idea to merge the two sorted lists
<script type="math/tex">A = [3, 6, 10, 23]</script> and <script type="math/tex">B = [2, 7, 50, 55]</script>,
is to couple them together into a list <script type="math/tex">L = A \cup B</script></p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- element who will be moved
L = [3, 6, 10, 23, | (2), 7, 50, 55]

// The '|' doesn't exist! It's only a notation for better explanation.
</code></pre>
</div>

<p>and then move the minimal element of the later list(<script type="math/tex">B</script>)
to the right position of the former list(<script type="math/tex">A</script>).</p>

<p>The way for finding right the position is to compare the elements one by one
from the end of the former list(<script type="math/tex">A</script>) to its head.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- element who will be moved
L = [3, 6, 10, (2), 23, | 7, 50, 55]
</code></pre>
</div>

<p>In our example, the <script type="math/tex">2</script> is swapped with <script type="math/tex">23</script> since <script type="math/tex">% <![CDATA[
2 < 23 %]]></script>.
Then we keep comparing <script type="math/tex">2</script> with <script type="math/tex">10</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- element who will be moved
L = [3, 6, (2), 10, 23, | 7, 50, 55]
</code></pre>
</div>

<p>Similarly, the <script type="math/tex">2, 10</script> are swapped since <script type="math/tex">% <![CDATA[
2 < 10 %]]></script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- element who will be moved
L = [3, (2), 6,  10, 23, | 7, 50, 55]
</code></pre>
</div>

<p>Next, the <script type="math/tex">2, 6</script> are swapped since <script type="math/tex">% <![CDATA[
2 < 6 %]]></script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- element who will be moved
L = [(2), 3, 6,  10, 23, | 7, 50, 55]
</code></pre>
</div>

<p>Next, the <script type="math/tex">2, 3</script> are swapped since <script type="math/tex">% <![CDATA[
2 < 3 %]]></script>.
After this round, there is nothing to compare,
so the <script type="math/tex">2</script> is moved to its right position.
Now <script type="math/tex">A = [2, 3, 6, 10, 23]</script> and <script type="math/tex">B = [7, 50, 55]</script></p>

<p>In the same way, we can do this process again with <script type="math/tex">7</script>.
It’s the minimal element of the later list <script type="math/tex">B</script> now.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- element who will be moved
L = [2, 3, 6, 10, 23, | (7), 50, 55]
L = [2, 3, 6, 10, (7), 23, | 50, 55]
L = [2, 3, 6, (7), 10, 23, | 50, 55]

L = [2, 3, 6, 7, 10, 23, | 50, 55]
</code></pre>
</div>

<p>After this round, <script type="math/tex">A = [2, 3, 6, 7, 10, 23]</script> and <script type="math/tex">B = [50, 55]</script>.</p>

<p>Then do it again with with <script type="math/tex">50</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- element who will be moved
L = [2, 3, 6,  7, 10, 23, | (50), 55]

L = [2, 3, 6,  7, 10, 23, 50, | 55]
</code></pre>
</div>

<p>However, <script type="math/tex">50</script> doesn’t move because <script type="math/tex">% <![CDATA[
23 < 50 %]]></script>.
We just need to append <script type="math/tex">50</script> to the end of the former list <script type="math/tex">A</script>.
After this round, <script type="math/tex">A = [2, 3, 6, 7, 10, 23, 50]</script> and <script type="math/tex">B = [55]</script>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>() &lt;- element who will be moved
L = [2, 3, 6,  7, 10, 23, 50, | (55)]

L = [2, 3, 6,  7, 10, 23, 50, 55]
</code></pre>
</div>

<p>It’s same to <script type="math/tex">55</script>.
It doesn’t need to be moved since <script type="math/tex">% <![CDATA[
50 < 55 %]]></script>,
so just append it to the <script type="math/tex">A</script>.
Finally, <script type="math/tex">A = [2, 3, 6, 7, 10, 23, 50, 55]</script> and <script type="math/tex">B = []</script> is empty now.
Now we have a sorted list <script type="math/tex">L = A \cup B = A</script>!</p>

<h4 id="which-merge-method-is-better">Which merge method is better</h4>

<p>The first method use <strong>extra space</strong> to store the sorted results,
rather than the second in-place solution.
On the other hand, the second method needs <strong>more swapping executions</strong>
and its a linear operation.
For better performance, we take the first method as our approach here.</p>

<p>Actually, there is a way to save the extra space
and it works as fast as the first method above.
However, it’s complicated.
I will write another post for illustrating it.
Please refer <em>In-place merge sort</em> in <a href="https://github.com/liuxinyu95/AlgoXY/releases/download/v0.618033/elementary-algorithms.pdf" title="Elementary Algorithms">Elementary Algorithms</a>
to read it.</p>

<h2 id="algorithm">Algorithm</h2>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
& \text{MergeSort($L$):} \\
& \space \space \space \space \text{mergeSort($L, 1, \vert L \vert$)}
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
& \text{mergeSort($L, l, r$):} \\
& \space \space \space \space \text{if $l < r$:} \\
& \space \space \space \space \space \space \space \space m \leftarrow \lfloor \frac{l+r}{2} \rfloor \\
& \space \space \space \space \space \space \space \space \text{mergeSort($L, l, m$)} \\
& \space \space \space \space \space \space \space \space \text{mergeSort($L, m+1, r$)} \\
& \space \space \space \space \space \space \space \space \text{merge($L, l, m, r$)} \\
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
& \text{merge($L, l, m, r$):} \\
& \space \space \space \space L^\prime \leftarrow [] \\
& \space \space \space \space i \leftarrow l, j \leftarrow m+1, k \leftarrow l \\
& \space \space \space \space \text{while $i \leq m$ and $j \leq r$:} \\
& \space \space \space \space \space \space \space \space \text{if $L[i] < L[j]$}: \\
& \space \space \space \space \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[i] \\
& \space \space \space \space \space \space \space \space \space \space \space \space i \leftarrow i + 1 \\
& \space \space \space \space \space \space \space \space \text{else}: \\
& \space \space \space \space \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[j] \\
& \space \space \space \space \space \space \space \space \space \space \space \space j \leftarrow j + 1 \\
& \space \space \space \space \space \space \space \space k \leftarrow k + 1 \\
& \space \space \space \space \text{while $i \leq m$:} \\
& \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[i] \\
& \space \space \space \space \space \space \space \space i \leftarrow i + 1 \\
& \space \space \space \space \space \space \space \space k \leftarrow k + 1 \\
& \space \space \space \space \text{while $j \leq r$:} \\
& \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[j] \\
& \space \space \space \space \space \space \space \space j \leftarrow j + 1 \\
& \space \space \space \space \space \space \space \space k \leftarrow k + 1 \\
& \space \space \space \space \text{for $i \leftarrow l$ to $r$:} \\
& \space \space \space \space \space \space \space \space L[i] \leftarrow L^\prime[i] \\
\end{align} %]]></script>

<h3 id="proof">Proof</h3>

<h4 id="correctness-of-merge">Correctness of <em>Merge</em></h4>

<div class="highlighter-rouge"><pre class="highlight"><code>  List L

        &lt;------   sorted   ------&gt; &lt;------   sorted  -------&gt;
        &lt;- merged -&gt; &lt;---  A  ---&gt; &lt;- merged -&gt; &lt;---  B  ---&gt;
  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----
   ... | l | ...... | i | ... | m | m+1 | .... | j | ... | r | ...
  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----
                      ^                          ^
                head of sublist A          head of sublist B

  List L'

   &lt;--   merged  --&gt; &lt;---   empty   ---&gt;
  +---+-------+-----+---+-------+-------+
  | 1 |  ...  | k-1 | k | ..... | r-l+1 |
  +---+-------+-----+---+-------+-------+
                      ^
                head of empty area of list L'

  L[l...m]    : the sorted sublists for merging with L[m+1...r]
  L[m+1...r]  : the sorted sublists for merging with L[l...m]
  A, B        : the sublists containing elements that have NOT been merged yet
  L'[1...k-1] : the merged list from L[l...i-1] and L[m+1...j-1]

  i: The index of the first element in L[l...m] that has NOT been merged yet
  j: The index of the first element in L[m+1...r] that has NOT been merged yet
  k: The index of next merged element copied from L[i] or L[j]
</code></pre>
</div>

<p><strong>Loop Invariant</strong>:
At the beginning of the while-loop, the following conditions hold:</p>

<ol>
  <li>Sublists <script type="math/tex">L[i...m]</script> and <script type="math/tex">L[j...r]</script> are sorted</li>
  <li><script type="math/tex">L^\prime</script> holds the elements from sublists <script type="math/tex">L[l...i-1]</script> and <script type="math/tex">L[m+1...j-1]</script></li>
  <li>All elements in <script type="math/tex">L^\prime[1...k-1]</script> is less or equal than
sublists <script type="math/tex">L[i...m]</script> and <script type="math/tex">L[j...r]</script></li>
  <li><script type="math/tex">L^\prime</script> are sorted.
Formally, <script type="math/tex">\forall i \in [l + 1, r], L^\prime[i - 1] \leq L^\prime[i]</script></li>
</ol>

<p>Then we use loop-invariants to prove:</p>

<ul>
  <li>Initialization: At the very beginning when <script type="math/tex">k = 1, i = l, j = m+1</script>
    <ul>
      <li>the input <script type="math/tex">L[l...m], L[m+1...r]</script> are sorted so <em>1</em> holds</li>
      <li>the list <script type="math/tex">L^\prime</script> is empty so <em>2, 3, 4</em> hold</li>
    </ul>
  </li>
  <li>Maintenance: Consider the iteration <script type="math/tex">k = x</script>
    <ul>
      <li><em>1</em> is preserved since there is no change in <script type="math/tex">L</script></li>
      <li><em>2</em> is preserved because
        <ul>
          <li>If <script type="math/tex">% <![CDATA[
j > r \lor (i \leq m \land L[i] < L[j]) %]]></script>, <script type="math/tex">L^\prime[k] \leftarrow L[i]</script>
            <ul>
              <li>then <script type="math/tex">k \leftarrow k+1, i \leftarrow i+1</script></li>
              <li><em>3</em> is preserved because <script type="math/tex">% <![CDATA[
L[k-1] = L[i-1] < L[j] \leq L[j+1] \leq ... \leq L[r] %]]></script>
and <script type="math/tex">L[k-1] = L[i-1] \leq L[i] \leq ... \leq L[m]</script></li>
            </ul>
          </li>
          <li>Otherwise, <script type="math/tex">L^\prime[k] \leftarrow L[j]</script>
            <ul>
              <li>then <script type="math/tex">k \leftarrow k+1, j \leftarrow j+1</script></li>
              <li><em>3</em> is preserved because <script type="math/tex">% <![CDATA[
L[k-1] = L[j-1] < L[j] \leq L[j+1] \leq ... \leq L[r] %]]></script>
and <script type="math/tex">L[k-1] = L[j-1] \leq L[i] \leq L[i+1] \leq ... \leq L[m]</script></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>The previous appended element must be smaller than
the current selected minimal element or <em>1</em> is false</li>
      <li>By <em>3</em>, the next selected minimal element will be larger than current one</li>
      <li>So <em>4</em> is also preserved</li>
    </ul>
  </li>
  <li>Termination
    <ul>
      <li>By <strong>2</strong>, <script type="math/tex">L^\prime</script> consists of the elements in <script type="math/tex">L[l...r]</script></li>
      <li>By <strong>4</strong>, <script type="math/tex">L[l...r] = L^\prime[l...r]</script> are sorted</li>
    </ul>
  </li>
</ul>

<h4 id="correctness-of-merge-sort">Correctness of <em>Merge Sort</em></h4>

<blockquote>
  <p>Given a list <script type="math/tex">L</script> with <script type="math/tex">N</script> elements,
the <script type="math/tex">L</script> can be sorted
by applying the above the <em>MergeSort</em> with <script type="math/tex">l = 1, r = N</script>.</p>
</blockquote>

<ul>
  <li>Base step: When <script type="math/tex">N = 1</script>, it’s trivial.</li>
  <li>Induction Hypothesis:
Suppose this assumption holds when list has <script type="math/tex">N = 1, 2, ..., k</script> elements</li>
  <li>Induction Step: When <script type="math/tex">N = k + 1</script>
    <ul>
      <li>the list <script type="math/tex">L</script> is divide to <script type="math/tex">L[1...m]</script>(<script type="math/tex">m</script> elements)
and <script type="math/tex">L[m+1...N]</script>(<script type="math/tex">N - m</script> elements)</li>
      <li>so <script type="math/tex">m = \lfloor \frac{1+(k+1)}{2} \rfloor = \lfloor \frac{k}{2} \rfloor + 1 \leq k</script></li>
      <li>and <script type="math/tex">1 \leq m \implies 0 \leq m-1 \implies k \leq k-1+m \implies \\
  k+1 \leq k+m \implies (k+1)-m \leq k \implies N-m \leq k</script></li>
      <li>By our hypothesis, <script type="math/tex">L[1...m]</script> and <script type="math/tex">L[m+1...N]</script> can be sorted</li>
      <li>By the proved correctness of <em>merge</em> above,
the merged <script type="math/tex">L[1...m]</script> and <script type="math/tex">L[m+1...N]</script> is also sorted,
so the proof is done</li>
    </ul>
  </li>
</ul>

<h2 id="complexity">Complexity</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>  ^    +------------------------------------------------------+   Merge
  |    |                           N                          |   Complexity
  |    +------------------------------------------------------+
  |                 |                              |
  |                 v                              v
  |    +------------------------+    +------------------------+
  |    |           N/2          |    |           N/2          |   2 * O(N/2)
  |    +------------------------+    +------------------------+
  |         |              |              |              |
            v              v              v              v
  K    +---------+    +---------+    +---------+    +---------+
       |   N/4   |    |   N/4   |    |   N/4   |    |   N/4   |   4 * O(N/4)
  |    +---------+    +---------+    +---------+    +---------+
  |      |     |        |     |        |     |        |     |
  |      v     v        v     v        v     v        v     v
  |
  |                        .  .  .  .  .  .                       2^i * O(N/(2^i))
  |
  |    +---+  +---+  +---+                                +---+
  |    | 1 |  | 1 |  | 1 |  .  .  .  .  .  .  .  .  .  .  | 1 |   N * O(1)
  v    +---+  +---+  +---+                                +---+

  N: the number of list elements.
  K: K layers from N to 1.
     N/2^k = 1 =&gt; N = 2^K =&gt; K = log_2(N)
</code></pre>
</div>

<p>The above figure is the <strong>recursion tree</strong> of <em>merge sort</em>.
The list containing <script type="math/tex">N</script> elements is recursively divided to sort
until there is only one elements.
Suppose that there is <script type="math/tex">K</script> times of division, therefore,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\frac{ N }{ 2^K }   &= 1 \\
\implies          N &= 2^K \\
\implies          K &= \log_{ 2 }N
\end{align} %]]></script>

<p>On the other hand, the time complexity
depends on the performance of <em>merge</em> <script type="math/tex">T_{merge}(N)</script>.
The used <em>merge</em> here is the basic version.
It iteratively picks the minimal elements from both sublists
then copied to another list <script type="math/tex">L^\prime</script>.
After all the elements in one sublist are all selected,
we move the rest elements in the other sublist to list <script type="math/tex">L^\prime</script>.
Finally, we assigned <script type="math/tex">L[i] \leftarrow L^\prime[i]</script>, <script type="math/tex">\forall i \in [1, N]</script>.
Thus, <script type="math/tex">T_{merge}(N)</script> can be defined as</p>

<script type="math/tex; mode=display">T_{merge}(N) = c \cdot N</script>

<p>where <script type="math/tex">c</script> is a constant reflecting the basic operations
like comparisons or assignments for merging routine.</p>

<h3 id="by-the-recursion-tree">By the recursion tree</h3>

<p>From the above figure, the total time for the <em>merge sort</em> is
<script type="math/tex">% <![CDATA[
\begin{align}
\overbrace{
2 \cdot c \cdot \frac{N}{2} +
4 \cdot c \cdot \frac{N}{4} +
8 \cdot c \cdot \frac{N}{8} +
... +
N \cdot c \cdot 1
}^{K}
&= K \cdot c \cdot N \\
&= c \cdot N \cdot \log_{ 2 }N
\end{align} %]]></script></p>

<p>Thus, the time complexity is <script type="math/tex">\mathcal{O}(N \log N)</script>.</p>

<h3 id="by-telescoping">By telescoping</h3>

<p>Formally, since the <em>merge sort</em> repeatedly breaks down the <script type="math/tex">N</script>-elements list
into two <script type="math/tex">\frac{N}{2}</script>-elements sublists,
the amount of time that <em>merge sort</em>, <script type="math/tex">T_{sort}(N)</script>,
can be written as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
T_{sort}(N)
&= T_{sort}(\frac{N}{2}) + T_{sort}(\frac{N}{2}) + T_{merge}(N) \\
&= 2 \cdot T_{sort}(\frac{N}{2}) + T_{merge}(N) \\
&= 2 \cdot T_{sort}(\frac{N}{2}) + c \cdot N
\end{align} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
T_{sort}(N)
&= 2 \cdot T_{sort}(\frac{N}{2}) + c \cdot N \\
&= 2 \cdot (2 \cdot T_{sort}(\frac{N}{4}) + c \cdot \frac{N}{2}) + c \cdot N \\
&= 2^2 \cdot T_{sort}(\frac{N}{4}) + 2 \cdot c \cdot N \\
&= 2^2 \cdot (2 \cdot T_{sort}(\frac{N}{8}) + c \cdot \frac{N}{4}) + 2 \cdot c \cdot N \\
&= 2^3 \cdot T_{sort}(\frac{N}{4}) + 3 \cdot c \cdot N \\
&= ... \\
&= 2^K \cdot T_{sort}(\frac{N}{2^K}) + K \cdot c \cdot N \\
&= N \cdot T_{sort}(1) + K \cdot c \cdot N \\
&= N \cdot 1 + K \cdot c \cdot N \\
&= N + c \cdot N \cdot \log_{ 2 }N
\end{align} %]]></script>

<p>Thus, the time complexity is <script type="math/tex">\mathcal{O}(N \log N)</script>.</p>

<h2 id="implementation">Implementation</h2>

<p>See the files on <a href="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb" title="Sorting">gist here</a>.</p>

<noscript><pre>#include &lt;algorithm&gt;  // for std::min, std::swap
#include &lt;cassert&gt;
#include &lt;cstring&gt;    // for memcpy
#include &quot;sorting.h&quot;

/*
 * Merge sort: O(n * log(n))
 */
// Basic merge: O(n)
// The following is the most straightforward way to merge two sorted array.
// However, it allocates extra memory for sorted results in every recursion.
void merge(int list[],
           unsigned int left,
           unsigned int division,
           unsigned int right)
{
  assert(left &lt;= right);
  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  unsigned int i = left;
  unsigned int j = division + 1;
  const unsigned int size = right - left + 1;
  int array[size];

  // When left &lt;= i &lt;= div and div + 1 &lt;= j &lt;= right:
  // Compare list[i] and list[j], if list[i] &lt; list[j], then copy list[i] into
  // the new array and let i = i + 1. Otherwise, copy list[j] into the new array
  // and let j = j + 1. If i &gt; div, it means list[left...div] is all compared
  // and already copied, so we just need to put the rest list[j...right] into
  // the array. In the same way, if j &gt; right, then put the rest list[i...div]
  // into the array.
  unsigned int k = 0;
  for (k = 0 ; k &lt; size; ++k) {
    array[k] = (j &gt; right || (i &lt;= division &amp;&amp; list[i] &lt; list[j])) ? list[i++] : list[j++];
  }

  // while (i &lt;= division &amp;&amp; j &lt;= right) {
  //   array[k++] = (list[i] &lt; list[j]) ? list[i++] : list[j++];
  //   // if (list[i] &lt; list[j]) {
  //   //   array[k] = list[i];
  //   //   ++i;
  //   // } else {
  //   //   array[k] = list[j];
  //   //   ++j;
  //   // }
  //   // ++k;
  // }
  //
  // // In this case, j &gt; right, so we put the rest list[i...div] into the array.
  // while (i &lt;= division) {
  //   array[k++] = list[i++];
  //   // array[k] = list[i];
  //   // ++i;
  //   // ++k;
  // }
  //
  // // in this case, i &gt; div, so we put the rest list[j...right] into the array.
  // while (j &lt;= right) {
  //   array[k++] = list[j++];
  //   // array[k] = list[j];
  //   // ++j;
  //   // ++k;
  // }

  assert(k == size);
  assert(i == division + 1);
  assert(j == right + 1);

  // Overwrite list[left...right] by the new sorted array.
  for (k = 0 ; k &lt; size ; ++k) {
    list[left + k] = array[k];
  }
  assert(left + k == right + 1);
}

// Append ∞ as the last sentinel element to the both ordered arrays for merging.
void mergeWithSentinel(int list[], unsigned int left, unsigned int division, unsigned int right)
{
  assert(left &lt;= right);
  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  //      |&lt;---  A&#39;  ---&gt;|&lt;---  B&#39;  ---&gt;|

  // Allocate list A = A&#39; ∪ [INFINITY] and list B = B&#39; ∪ [INFINITY]
  const static int INFINITY = ((unsigned int)(-1) &gt;&gt; 1);
  const unsigned int sizeA = division - left + 2; // (division - left + 1) + 1
  const unsigned int sizeB = right - division + 1; // (right - (division + 1) + 1) + 1
  int *A = new int[sizeA]; // 1 is for [ INFINITY ]
  int *B = new int[sizeB];
  // Copy elements from list[left...division] to A&#39;[0...(sizeA - 2)].
  memcpy((void*)A, (void*)(list + left), sizeof(int) * (sizeA - 1));
  // Copy elements from list[(division + 1)...right] to B&#39;[0...(sizeB - 2)].
  memcpy((void*)B, (void*)(list + division + 1), sizeof(int) * (sizeB - 1));
  // Set the last elements of A and B to INFINITY.
  A[sizeA - 1] = B[sizeB - 1] = INFINITY;
  // Move the sorted elements of A and B to list[left...right].
  unsigned int i, j;
  for (i = j = 0 ; left &lt;= right ; ++left) {
    list[left] = A[i] &lt; B[j] ? A[i++] : B[j++];
  }
  free(A);
  free(B);
}

// The following method demonstrates a in-place version of merge method.
// However, it downgrades mergesort overall performance to quadratic O(n^2)!
// Naive in-place merge: O(n^2)
void naiveInplaceMerge(int list[],
                       unsigned int left,
                       unsigned int division,
                       unsigned int right)
{
  assert(left &lt;= right);
  //      |&lt;-- sorted --&gt;|&lt;-- sorted --&gt;|
  // -----+---+------+---+---+------+---+-----
  //  ... | l | .... | m | n | .... | r | ...
  // -----+---+------+---+---+------+---+-----
  //        ^          ^   ^          ^
  //      left       div  div+1    right
  unsigned int anchor = left;
  for (unsigned int i = division + 1 ; i &lt;= right ; ++i) {
    for (unsigned int j = i ; j &gt; anchor ; --j) { // Replace anchor with left is fine.
      // The following condition is definitely true and will be triggered.
      // list[division + k + 1] &gt;= list[division + k] where k &gt;= 1
      // is assertive because list[division + 1 .... right] is a sorted from
      // minimal item to maximal one.
      if (list[j] &gt;= list[j-1]) {
        anchor = j;
        break;
      }
      std::swap(list[j], list[j-1]);
    }
  }
}

void topDownMergeSort(int list[], unsigned int left, unsigned int right)
{
  if (left &gt;= right) {
    return;
  }

  const unsigned int middle = (left + right) / 2;
  topDownMergeSort(list, left, middle);
  topDownMergeSort(list, middle + 1, right);
  merge(list, left, middle, right);
  // mergeWithSentinel(list, left, middle, right);
  // naiveInplaceMerge(list, left, middle, right); // Slower!
}

void bottomUpMergeSort(int list[], unsigned int length)
{
  // &lt;----------  l = 2^k + r  ----------&gt;  where k, r are integers, k &gt;= 0,
  // &lt;-----  2^k  -----&gt;|&lt;-----  r  -----&gt;  and 0 &lt;= r &lt; 2^k.
  // +---+---+---------+---+---------+---+
  // | 0 | 1 | ....... | n | ....... | m |
  // +---+---+---------+---+---------+---+
  //
  // l            k  r
  // 1 : 2^0 + 0  0  0
  // 2 : 2^1 + 0  1  0
  // 3 : 2^1 + 1  1  1
  // 4 : 2^2 + 0  2  0
  // 5 : 2^2 + 1  2  1
  // 6 : 2^2 + 2  2  2
  // 7 : 2^2 + 3  2  3
  // 8 : 2^3 + 0  3  0
  // 9 : 2^3 + 1  3  1
  // ...
  // ...
  //
  // When r = 0:  The length of list is powers of 2, denoted 2^k, so all the
  //              size of blocks for merging must be same. At the round (k+1),
  //              the size is 2^k, where k &gt;= 0 is a integer.
  // When r != 0: We can consider there are extra &#39;r&#39; elements added into the
  //              above list whose length is powers of 2.
  //              The extra &#39;r&#39; elements will be merged when the block size is
  //              grown to 2^k, where k &gt;= 0 and 0 &lt; r &lt; 2^k.
  //
  // Each round, the list is divided into blocks and then merged
  // from size 1, 2, 4, ... to lenght/2.
  for (unsigned int size = 1 ; size &lt; length ; size *= 2) {
    // If i &gt;= length - size, then the rest elements list[i .. length - 1]
    // is smaller than or equal to one block size, so there is nothing to be
    // merged. These rest elements will be merged when size = 2^k
    // and 2^(k-1) &lt; length - 2^k &lt; 2^k,.
    for (unsigned int i = 0 ; i &lt; length - size ; i += 2 * size) {
      // Merge the adjacent two blocks.
      merge(list, i, i + size - 1, std::min(i + 2 * size - 1, length - 1));
      // mergeWithSentinel(list, i, i + size - 1, min(i + 2 * size - 1, length - 1));
      // naiveInplaceMerge(list, i, i + size - 1, min(i + 2 * size - 1, length - 1)); // Slower!

      // Uncomment below to check when the rest items will be merged.
      // if ((size/2 &lt; length - size/2) &amp;&amp; (length - size &lt; size)) {
      //   std::cout &lt;&lt; &quot;List length: &quot; &lt;&lt; length &lt;&lt; std::endl;
      //   std::cout &lt;&lt; &quot;Merge the last &quot; &lt;&lt; length - size &lt;&lt;
      //                &quot; items when size is &quot; &lt;&lt; size &lt;&lt; std::endl;
      //   assert(min(i + 2 * size - 1, length - 1) == length - 1);
      // }
    }
  }
}

void mergeSort(int list[], unsigned int length)
{
  assert(length);

  // topDownMergeSort(list, 0, length - 1);
  bottomUpMergeSort(list, length);
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=merge_sort.cpp"> </script>

<h2 id="appendix">Appendix</h2>

<h3 id="correctness-of-naive-in-place-merge">Correctness of <em>naive in-place merge</em></h3>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
& \text{naiveInplaceMerge($L, l, m, r$):} \\
& \space \space \space \space \text{for $i \leftarrow m+1$ to $r$:} \\
& \space \space \space \space \space \space \space \space \text{for $j \leftarrow i$ down to $l+1$:} \\
& \space \space \space \space \space \space \space \space \space \space \space \space \text{if $L[j-1] \leq L[j]$:} \\
& \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \text{break} \\
& \space \space \space \space \space \space \space \space \space \space \space \space \text{swap $L[j-1]$ and $L[j]$} \\
\end{align} %]]></script>

<h4 id="proof-by-mathematical-induction">Proof by mathematical induction</h4>

<h5 id="lemma-1">Lemma 1</h5>

<blockquote>
  <p>Given a sorted list <script type="math/tex">A = [a_1, a_2, ..., a_N]</script> with <script type="math/tex">N</script> elements,
where <script type="math/tex">a_1 \leq a_2 \leq ... \leq a_N</script>,
and one value <script type="math/tex">x</script>,
the list <script type="math/tex">L = A \cup [x] = [a_1, a_2, ..., a_N, x]</script>
(<script type="math/tex">x</script> is appended to the end of list <script type="math/tex">A</script>),
can be sorted by the <em>naive in-place merge</em> method with <script type="math/tex">l = 1, m = N, r = N + 1</script>.</p>
</blockquote>

<ul>
  <li>Base step: When <script type="math/tex">N = 0</script>, list <script type="math/tex">L = [x]</script> is trivially true</li>
  <li>Induction Hypothesis: Suppose this assumption holds when <script type="math/tex">N = k</script></li>
  <li>Induction Step: When <script type="math/tex">N = k + 1</script>
    <ul>
      <li>If <script type="math/tex">x \geq L[k]</script>, then the <script type="math/tex">L = a_1 \leq a_2 \leq ... \leq a_k \leq x</script> is naturally sorted</li>
      <li>Otherwise, <script type="math/tex">% <![CDATA[
x < L[k] %]]></script> and the <script type="math/tex">x</script> and <script type="math/tex">L[k]</script> are swapped.
        <ul>
          <li>Now <script type="math/tex">L[1...k] = [a_1, a_2, ... , a_{k-1}, x]</script></li>
          <li>By the hypothesis, the <em>naive in-place merge</em> works when <script type="math/tex">N = k</script>, so we can a sorted <script type="math/tex">L[1...k]</script></li>
          <li>Thus, the list <script type="math/tex">L</script> now is sorted since <script type="math/tex">L[1...k]</script> is sorted
and all its elements are smaller than the current <script type="math/tex">(k+1)</script>th element <script type="math/tex">L[k]</script></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="lemma-2">Lemma 2</h5>

<blockquote>
  <p>Given a sorted list <script type="math/tex">A = [a_1, a_2, ..., a_N]</script> with <script type="math/tex">N</script> elements
where <script type="math/tex">a_1 \leq a_2 \leq ... \leq a_N</script>,
and <script type="math/tex">B = [b_1, b_2, ..., b_M]</script> with <script type="math/tex">M</script> elements
where <script type="math/tex">b_1 \leq b_2 \leq ... \leq b_M</script>,
the list <script type="math/tex">L = A \cup B = [a_1, a_2, ..., a_N, b_1, b_2, ..., b_M]</script>
can be sorted by the above <em>naive in-place merge</em> method with <script type="math/tex">l = 1, m = N, r = M+N</script>.</p>
</blockquote>

<ul>
  <li>Base step: When <script type="math/tex">M = 1</script>, the condition is same as <em>Lemma 1</em>, so it’s true</li>
  <li>Induction Hypothesis: Suppose this assumption holds when <script type="math/tex">M = k</script></li>
  <li>Induction Step: When <script type="math/tex">M = k + 1</script>
    <ul>
      <li>When <script type="math/tex">i = N + 1</script>
        <ul>
          <li>the element <script type="math/tex">L[N+1]</script> will be merged with <script type="math/tex">L[1...N] = A</script></li>
          <li>then the list <script type="math/tex">L[1...N+1]</script> is sorted by <em>Lemma 1</em></li>
        </ul>
      </li>
      <li>When <script type="math/tex">i = N + 2</script>
        <ul>
          <li>the list is composed by sorted sublists <script type="math/tex">A^\prime = L[1...N+1]</script>
and <script type="math/tex">B^\prime = L[N+2...N+k+1]</script> with <script type="math/tex">k</script> elements</li>
          <li>By the hypothesis, the <em>naive in-place merge</em> works when <script type="math/tex">\vert B^\prime \vert = k</script></li>
          <li>Thus, the list <script type="math/tex">L = A^\prime \cup B^\prime = A \cup B</script> is sorted</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="reference">Reference</h2>
<ul>
  <li><a href="http://www-bcf.usc.edu/~dkempe/CS104/11-07.pdf" title="2013 CS104: Recursive Sorting Algorithms and their Analysis">CS104</a></li>
  <li><a href="http://www.cs.princeton.edu/courses/archive/spr07/cos226/lectures/04MergeQuick.pdf" title="Mergesort and Quicksort">COS226</a></li>
  <li><a href="http://www.cs.mcgill.ca/~dprecup/courses/IntroCS/Lectures/comp250-lecture16.pdf" title="Lecture 16: MergeSort proof of correctness, and running time">COMP250</a></li>
  <li><a href="http://www.inf.unibz.it/~nutt/DSA1112/DSALabs/sols2.pdf" title="Data Structures and Algorithms">DSA1112</a></li>
  <li><a href="https://www.cs.rochester.edu/~gildea/csc282/slides/C02-start.pdf" title="Getting Started">CSC282</a></li>
</ul>



                        <br>

                    
                    
                        <div class="entry-tags text-center">
                            <i class="fa fa-tags"></i>&nbsp;
                                Tagged with 
                            
                                <a href="http://localhost:4000/tags/index.html#Sorting" data-toggle="tooltip" title="Posts tagged with Sorting" rel="tag">Sorting</a>

                                
                            
                        </div>
                    
                    </div>

                    <footer class="post-footer entry-meta">
                    
                        <div class="post-share text-center">
    <p class="light small">
        Share this post
    </p>
    <ul class="social-mini">
        <li>
            <a href="https://twitter.com/intent/tweet?text=Merge+Sort%20http://localhost:4000/post/merge-sort%20via%20&#64;"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" data-toggle="tooltip"
                title="Share on Twitter" itemprop="Twitter">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/post/merge-sort" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"
                data-toggle="tooltip" title="Share on Facebook" itemprop="Facebook">
                <i class="fa fa-facebook"></i>
            </a>
        </li>
        <li>
            <a href="https://plus.google.com/share?url=http://localhost:4000/post/merge-sort" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;"
                data-toggle="tooltip" title="Share on Google plus" itemprop="GooglePlus">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
    </ul>
</div>
                    

                        <div class="post-author text-center">
	<img src="http://localhost:4000/images/yosemite.png" alt="Chun-Min Chang's photo" itemprop="image" class="post-avatar img-circle img-responsive" />
	<h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="http://schema.org/Person">
		By <span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About Chun-Min Chang" itemprop="url">Chun-Min Chang</a></span>
	</h4>
	<p>I am a self-directed learner and a maker who enjoys building products from original ideas.</p>
</div> 
                        
                    
                        <div id="disqus_thread"></div><!-- /#disqus_thread -->
                    
                    </footer>

                </article>
            </div>
        </div>
    </div>

    
<footer id="footer" class="blog-background overlay text-center align-middle animated from-top" style="background-image: url(http://localhost:4000/images/background/yosemite/yosemite1.png)">


    <div class="inner">
        <div class="container">
            <ul class="social-icons">
                    
                <li>
                    <a href="https://www.linkedin.com/in/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on LinkedIn" target="_blank">
                        <i class="fa fa-linkedin"></i>
                    </a>
                </li>
                   
                <li>
                    <a href="http://github.com/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on Github" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </li>
                
            </ul>
            <div>
                <a href="http://localhost:4000/about/">Chun-Min Chang</a> &copy; 2017 &bull;
                All rights reserved.
            </div>
            <ul class="menu-items">
                
                <li>
                    
                    <a href="http://localhost:4000/"><i class="fa fa-home"></i>&nbsp;Home</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/categories"><i class="fa fa-sitemap"></i>&nbsp;Categories</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/tags"><i class="fa fa-tags"></i>&nbsp;Tags</a>&nbsp;&bull;
                    
                </li>
                
                <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
            </ul>
        </div>
    </div>

    
    <div class="decor-wrapper">
        <svg id="footer-decor" class="decor top" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 0 L50 50 L0 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 0 L50 50 L100 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 0 L50 50 L0 33.3" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 0 L50 50 L100 33.3" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>
    

</footer>


    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ="
  crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.12.4.min.js"><\/script>')</script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
  crossorigin="anonymous"></script>

<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jekyll-search.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.fitvids.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.waypoints.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/main.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/script.js"></script>
<script type='text/javascript'>$(document).ready(function(){$(".time").text(function(a,b){return Math.round(parseFloat(b))})});</script>

<script type="text/javascript">

/*      Slides       */

$("a#slide").click(function(){
    $("#sidebar,body,a#slide,#fade").addClass("slide")
});

$("#fade,#header,#posts-container").click(function(){
    $("#sidebar,body,a#slide,#fade").removeClass("slide")
});

$("a#click-filter").click(function(){
    $("#slide-filter").slideToggle("medium");
    $("#slide-pages").slideOut("medium");
});

$("a#click-pages").click(function(){
    $("#slide-pages").slideToggle("medium");
    $("#slide-filter").slideOut("medium");
});

/*      End-Slides      */

</script>


<!-- Jekyll Simple Search option -->
<script>

   SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: 'http://localhost:4000/assets/json/search.json',
        searchResultTemplate: '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
        noResultsText: '<p>Nothing found.</p>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $("#search-close"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


 


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'chunminchang-blog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        
</body>
</html>
