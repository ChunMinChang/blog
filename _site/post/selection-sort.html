<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">


<meta name="keywords" content="Sorting">


<!-- Begin Jekyll SEO tag v1.3.3 -->
<title>Selection Sort - Peak Up</title>
<meta property="og:title" content="Selection Sort" />
<meta name="description" content="Selection sortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaThe concept is quite straight.If we could get the minimal value from list one by one,then we could re-arrange the list from minimal to maximal values.Imagine we have two lists  and ,the  is a list contains several items with comparable values andthe  is a sorted list of .At first,  is empty.Take  as an example:  At the first round, we get  as minimal value,so we move it into . Now,                                                    At the second round, we get  as minimal value, so                                                    Next,  is picked and moved from  to , so                                                    Then, the current minimal value  is moved from  to , so                                                    Finally,  is moved into , so                                                  See! the idea is quite simple.In the same way, to sort the list from maximal to minimal values,the only different is to pick the maximal value from list each roundinstead of minimal value.How to get minimal(or maximal) valueThe way to get minimal(or maximal) items in is to linearly search the whole list:or, where  is the th element in the list and  is the length of .Dividing one list into unsorted list and sorted listIn implementation, we usually divide the source list,which needs to be sorted, into two parts. One is sorted, the other is unsorted.This is better for memory usage thancreating another list to put the sorted results.That is, if we have a source list ,it will be divided into  and .They are initialized to  and  respectively,so .  In the first round,  is picked and movedfrom  to , so                                In the second round,  is picked and movedfrom  to , so                                Next,  is picked, so                                Then, another  is picked, so                                Finally,  is picked, so                              AlgorithmThe above method will divide  into two parts.   is sorted   is unsorted,  where  is the length of The following are step by step explanation:  When            and       we need to find the minimal element in list       We use a value  to track the index of the minimal element      where  is initialized to        will be updated to , where , if       Repeatedly above instruction from  to (searching whole ), would be the minimal value in       swap  and       then  now can be considered as       so         When            and       we need to find the minimal element in list       Same as above,  is used to keep tracking the index of the minimalelement in       where  is initialized to       After searching the whole , would be the minimal value in       We can put  into the  by swapping the  and       Thus,  and         When            and        is initialized to       After searching the whole , would be the minimal value in       Swapping  and  would put  into       Then,  and         When (final round)           and        is initialized to       Pick a smaller one between  and       and put it into the  like above(by swapping with )      Then  and       The left one(now is ) is definitely the maximal itemin , so we don’t need to do anything      ProofProof by contradiction  Assume this method can not give us an ordered list  so it exists one , where , in the result list   Before the result is computed, the unsorted list could be or   It means that  is picked before because  in the result list   It means  and it is contradictory to the assumption  Thus, the assumption is wrong. This method will give us an ordered list.ComplexityWe need to search whole  to find a minimal(or maximal) item.Suppose  at first.(the length of  is ).At the first round, we need to search  itemsto find the minimal(or maximal) item and move it into .After then, .At the second round, whole  items in  would be countedto find the minimal(or maximal) one.After the picked one is moved into ,the size of  is reduced to .The procedure keep working until the list  is empty().Thus, we need to searchtimes to move all the items into .Thus, the complexity is ,where the  is the length of the list .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::swap#include &lt;cassert&gt;#include &quot;sorting.h&quot;/* * Selection sort: O(n^2) */void selectionSort(int list[], unsigned int length){  assert(length);  // &lt;--  sorted  --&gt;|&lt;--  unsorted  --&gt;  // +---+---+-------+---+---+---------+  // | 0 | 1 | ..... | h | i |  .....  |  // +---+---+-------+---+---+---------+  //                   ^  //                head is the begin index of unsorted list.  for (unsigned int head = 0 ; head &lt; length - 1 ; ++head) {    // Assume the current head value is the minimal item.    int minIndex = head;    for (unsigned int i = head + 1 ; i &lt; length ; ++i) {      if (list[i] &lt; list[minIndex]) {        minIndex = i;      }    }    if (head != minIndex) {      std::swap(list[head], list[minIndex]);    }    // After swap with the minimal value of unsorted list, the head now    // is the tail of the sorted list.    //    // &lt;--    sorted    --&gt;|&lt;-- unsorted --&gt;    // +---+---+-------+---+---------------+    // | 0 | 1 | ..... | h | ............  |    // +---+---+-------+---+---------------+    //                   ^    //  head now is the last index of the sorted list.  }}" />
<meta property="og:description" content="Selection sortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaThe concept is quite straight.If we could get the minimal value from list one by one,then we could re-arrange the list from minimal to maximal values.Imagine we have two lists  and ,the  is a list contains several items with comparable values andthe  is a sorted list of .At first,  is empty.Take  as an example:  At the first round, we get  as minimal value,so we move it into . Now,                                                    At the second round, we get  as minimal value, so                                                    Next,  is picked and moved from  to , so                                                    Then, the current minimal value  is moved from  to , so                                                    Finally,  is moved into , so                                                  See! the idea is quite simple.In the same way, to sort the list from maximal to minimal values,the only different is to pick the maximal value from list each roundinstead of minimal value.How to get minimal(or maximal) valueThe way to get minimal(or maximal) items in is to linearly search the whole list:or, where  is the th element in the list and  is the length of .Dividing one list into unsorted list and sorted listIn implementation, we usually divide the source list,which needs to be sorted, into two parts. One is sorted, the other is unsorted.This is better for memory usage thancreating another list to put the sorted results.That is, if we have a source list ,it will be divided into  and .They are initialized to  and  respectively,so .  In the first round,  is picked and movedfrom  to , so                                In the second round,  is picked and movedfrom  to , so                                Next,  is picked, so                                Then, another  is picked, so                                Finally,  is picked, so                              AlgorithmThe above method will divide  into two parts.   is sorted   is unsorted,  where  is the length of The following are step by step explanation:  When            and       we need to find the minimal element in list       We use a value  to track the index of the minimal element      where  is initialized to        will be updated to , where , if       Repeatedly above instruction from  to (searching whole ), would be the minimal value in       swap  and       then  now can be considered as       so         When            and       we need to find the minimal element in list       Same as above,  is used to keep tracking the index of the minimalelement in       where  is initialized to       After searching the whole , would be the minimal value in       We can put  into the  by swapping the  and       Thus,  and         When            and        is initialized to       After searching the whole , would be the minimal value in       Swapping  and  would put  into       Then,  and         When (final round)           and        is initialized to       Pick a smaller one between  and       and put it into the  like above(by swapping with )      Then  and       The left one(now is ) is definitely the maximal itemin , so we don’t need to do anything      ProofProof by contradiction  Assume this method can not give us an ordered list  so it exists one , where , in the result list   Before the result is computed, the unsorted list could be or   It means that  is picked before because  in the result list   It means  and it is contradictory to the assumption  Thus, the assumption is wrong. This method will give us an ordered list.ComplexityWe need to search whole  to find a minimal(or maximal) item.Suppose  at first.(the length of  is ).At the first round, we need to search  itemsto find the minimal(or maximal) item and move it into .After then, .At the second round, whole  items in  would be countedto find the minimal(or maximal) one.After the picked one is moved into ,the size of  is reduced to .The procedure keep working until the list  is empty().Thus, we need to searchtimes to move all the items into .Thus, the complexity is ,where the  is the length of the list .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::swap#include &lt;cassert&gt;#include &quot;sorting.h&quot;/* * Selection sort: O(n^2) */void selectionSort(int list[], unsigned int length){  assert(length);  // &lt;--  sorted  --&gt;|&lt;--  unsorted  --&gt;  // +---+---+-------+---+---+---------+  // | 0 | 1 | ..... | h | i |  .....  |  // +---+---+-------+---+---+---------+  //                   ^  //                head is the begin index of unsorted list.  for (unsigned int head = 0 ; head &lt; length - 1 ; ++head) {    // Assume the current head value is the minimal item.    int minIndex = head;    for (unsigned int i = head + 1 ; i &lt; length ; ++i) {      if (list[i] &lt; list[minIndex]) {        minIndex = i;      }    }    if (head != minIndex) {      std::swap(list[head], list[minIndex]);    }    // After swap with the minimal value of unsorted list, the head now    // is the tail of the sorted list.    //    // &lt;--    sorted    --&gt;|&lt;-- unsorted --&gt;    // +---+---+-------+---+---------------+    // | 0 | 1 | ..... | h | ............  |    // +---+---+-------+---+---------------+    //                   ^    //  head now is the last index of the sorted list.  }}" />
<link rel="canonical" href="http://localhost:4000/post/selection-sort" />
<meta property="og:url" content="http://localhost:4000/post/selection-sort" />
<meta property="og:site_name" content="Peak Up" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-12-29T00:00:00+08:00" />
<link rel="next" href="http://localhost:4000/post/insertion-sort" title="Insertion Sort" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Selection Sort",
    "datePublished": "2016-12-29T00:00:00+08:00",
    "description": "Selection sortThis post series is synchronized with my book CodePlayand this post could be read here.IdeaThe concept is quite straight.If we could get the minimal value from list one by one,then we could re-arrange the list from minimal to maximal values.Imagine we have two lists  and ,the  is a list contains several items with comparable values andthe  is a sorted list of .At first,  is empty.Take  as an example:  At the first round, we get  as minimal value,so we move it into . Now,                                                    At the second round, we get  as minimal value, so                                                    Next,  is picked and moved from  to , so                                                    Then, the current minimal value  is moved from  to , so                                                    Finally,  is moved into , so                                                  See! the idea is quite simple.In the same way, to sort the list from maximal to minimal values,the only different is to pick the maximal value from list each roundinstead of minimal value.How to get minimal(or maximal) valueThe way to get minimal(or maximal) items in is to linearly search the whole list:or, where  is the th element in the list and  is the length of .Dividing one list into unsorted list and sorted listIn implementation, we usually divide the source list,which needs to be sorted, into two parts. One is sorted, the other is unsorted.This is better for memory usage thancreating another list to put the sorted results.That is, if we have a source list ,it will be divided into  and .They are initialized to  and  respectively,so .  In the first round,  is picked and movedfrom  to , so                                In the second round,  is picked and movedfrom  to , so                                Next,  is picked, so                                Then, another  is picked, so                                Finally,  is picked, so                              AlgorithmThe above method will divide  into two parts.   is sorted   is unsorted,  where  is the length of The following are step by step explanation:  When            and       we need to find the minimal element in list       We use a value  to track the index of the minimal element      where  is initialized to        will be updated to , where , if       Repeatedly above instruction from  to (searching whole ), would be the minimal value in       swap  and       then  now can be considered as       so         When            and       we need to find the minimal element in list       Same as above,  is used to keep tracking the index of the minimalelement in       where  is initialized to       After searching the whole , would be the minimal value in       We can put  into the  by swapping the  and       Thus,  and         When            and        is initialized to       After searching the whole , would be the minimal value in       Swapping  and  would put  into       Then,  and         When (final round)           and        is initialized to       Pick a smaller one between  and       and put it into the  like above(by swapping with )      Then  and       The left one(now is ) is definitely the maximal itemin , so we don’t need to do anything      ProofProof by contradiction  Assume this method can not give us an ordered list  so it exists one , where , in the result list   Before the result is computed, the unsorted list could be or   It means that  is picked before because  in the result list   It means  and it is contradictory to the assumption  Thus, the assumption is wrong. This method will give us an ordered list.ComplexityWe need to search whole  to find a minimal(or maximal) item.Suppose  at first.(the length of  is ).At the first round, we need to search  itemsto find the minimal(or maximal) item and move it into .After then, .At the second round, whole  items in  would be countedto find the minimal(or maximal) one.After the picked one is moved into ,the size of  is reduced to .The procedure keep working until the list  is empty().Thus, we need to searchtimes to move all the items into .Thus, the complexity is ,where the  is the length of the list .ImplementationSee the files on gist here.#include &lt;algorithm&gt;  // for std::swap#include &lt;cassert&gt;#include &quot;sorting.h&quot;/* * Selection sort: O(n^2) */void selectionSort(int list[], unsigned int length){  assert(length);  // &lt;--  sorted  --&gt;|&lt;--  unsorted  --&gt;  // +---+---+-------+---+---+---------+  // | 0 | 1 | ..... | h | i |  .....  |  // +---+---+-------+---+---+---------+  //                   ^  //                head is the begin index of unsorted list.  for (unsigned int head = 0 ; head &lt; length - 1 ; ++head) {    // Assume the current head value is the minimal item.    int minIndex = head;    for (unsigned int i = head + 1 ; i &lt; length ; ++i) {      if (list[i] &lt; list[minIndex]) {        minIndex = i;      }    }    if (head != minIndex) {      std::swap(list[head], list[minIndex]);    }    // After swap with the minimal value of unsorted list, the head now    // is the tail of the sorted list.    //    // &lt;--    sorted    --&gt;|&lt;-- unsorted --&gt;    // +---+---+-------+---+---------------+    // | 0 | 1 | ..... | h | ............  |    // +---+---+-------+---+---------------+    //                   ^    //  head now is the last index of the sorted list.  }}",
    "logo": "http://localhost:4000mountain.png",
    "url": "http://localhost:4000/post/selection-sort"
  }
</script>
<!-- End Jekyll SEO tag -->

<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Peak Up" />

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
    crossorigin="anonymous">

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/style.css" />
<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/syntax.css" />


<!--Load Mathjax-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
        MathJax.Hub.Config({
            config: ["MMLorHTML.js"],
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: false
            },
            TeX: {
                TagSide: "right",
                TagIndent: ".8em",
                MultLineWidth: "85%",
                equationNumbers: {
                   autoNumber: "AMS",
                },
                unicode: {
                   fonts: "STIXGeneral,'Arial Unicode MS'"
                }
            },
            showProcessingMessages: false
        });
</script>



<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/favicons/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/favicons/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/favicons/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/favicons/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post-template" itemscope itemtype="http://schema.org/WebPage">

    
<div class="search-wrapper">
    <div class="search-form">
        <input type="text" id="search-input" class="search-field" placeholder="Search...">
        <i id="search-close" class="fa fa-times-circle"></i>
        <h4>Search results</h4>
        <ul id="results-container" class="search-results post-list">
        </ul>
        <!-- /.search-results -->
    </div>
    <!-- /.search-form -->
</div>
<!-- ./search-wrapper -->


<div id="fade"></div>
<a id="slide" class="animated fade">
    <i class="fa fa-bars" aria-hidden="true"></i>
</a>
<aside id="sidebar">
    <nav id="navigation">
        <h2>MENU</h2>
        <hr>
        <ul> 
            <li>
                <a href="http://localhost:4000/"><!-- <i class="fa fa-home"></i>&nbsp;-->Home</a>  </li>
            
            <li>
                <a href="http://localhost:4000/categories"><!-- <i class="fa fa-sitemap"></i>&nbsp;-->Categories</a>  </li>
            
            <li>
                <a href="http://localhost:4000/tags"><!-- <i class="fa fa-tags"></i>&nbsp;-->Tags</a>  </li>
            
            <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
        </ul>
    </nav>
</aside>


<header id="masthead" class="blog-background overlay align-center align-middle animated from-bottom" style="background-image: url(http://localhost:4000/images/background/yosemite/yosemite-tiny.jpg)"
    itemscope itemtype="http://schema.org/Organization">



    <button class="menu-button animated fade dosearch">
        <i class="fa fa-search"></i>
    </button>



    <div class="inner">
        <div class="container">
            <a class="brand" href="http://localhost:4000/" itemprop="url">
                <img itemprop="logo" src="http://localhost:4000/images/mountain.png" alt="Peak Up Logo" />
                <h1 class="blog-title light" itemprop="name">
                    Peak Up
                </h1>
            </a>
        </div>
    </div>



    <div class="decor-wrapper">
        <svg id="header-decor" class="decor bottom" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <!-- <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 100 L50 50 L0 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 100 L50 50 L100 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 100 L50 50 L0 66.6" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 100 L50 50 L100 66.6" fill="rgba(255,255,255, .5)"></path> -->
            <path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>

</header>


    <div id="main" class="content" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
        <div class="container">
            <div class="row">
                <article class="post col-md-8 col-md-offset-2 hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
                
                
                
                

                    <header class="post-header entry-header">

                    

                    
                        <h1 class="post-title text-center hyper lighter bordered-bottom entry-title" itemprop="headline">
                        
                            
                        
                        
                        

                        
                            Selection Sort
                        </h1>
                    

                        <div class="cursive" style="color: #000; font-style:italic;"></div>

                            <div class="post-info text-center small">
                            
                                <span class="entry-date date published updated">
                            
                            
                                    <time datetime="2016-12-29T00:00:00+08:00" class="post-time" itemprop="datePublished">29 Dec 2016</time>
                                </span>
                            

                                in <span class="post-tags">

                            
                                    <a href="http://localhost:4000/categories/index.html#Algorithm" data-toggle="tooltip" title="Other posts from the Algorithm category" rel="tag">Algorithm</a>
                                
                            
                                </span>
                            
                            &nbsp;
                                <span class="post-tags"><i class="fa fa-clock-o"></i>&nbsp;

                            

                            
                                    <span class="time">4.894444444444445</span> minutes read
                            
                                
                            

                                </span>
                            
                            </div>

                    </header>

                    <div class="post-body bordered-bottom" itemprop="description">
                    

                        <h1 id="selection-sort">Selection sort</h1>

<p>This post series is synchronized with my book <a href="https://www.gitbook.com/book/chunminchang/codeplay/details" title="CodePlay">CodePlay</a>
and this post could be read <a href="https://chunminchang.gitbooks.io/codeplay/content/sorting/selection_sort.html" title="Selection Sort">here</a>.</p>

<h2 id="idea">Idea</h2>
<p>The concept is quite straight.
If we could get the minimal value from list <strong>one by one</strong>,
then we could re-arrange the list from minimal to maximal values.</p>

<p>Imagine we have two lists <script type="math/tex">L</script> and <script type="math/tex">L_{sorted}</script>,
the <script type="math/tex">L</script> is a list contains several items with comparable values and
the <script type="math/tex">L_{sorted}</script> is a sorted list of <script type="math/tex">L</script>.
At first, <script type="math/tex">L_{sorted} = [ ]</script> is empty.</p>

<p>Take <script type="math/tex">L = [ 5, 3, 1, 2, 3 ]</script> as an example:</p>

<ul>
  <li>At the first round, we get <script type="math/tex">1</script> as minimal value,
so we move it into <script type="math/tex">L_{sorted}</script>. Now,
    <ul>
      <li>
        <script type="math/tex; mode=display">L_{sorted} = [ 1 ]</script>
      </li>
      <li>
        <script type="math/tex; mode=display">L = [ 5, 3, 2, 3 ]</script>
      </li>
    </ul>
  </li>
  <li>At the second round, we get <script type="math/tex">2</script> as minimal value, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L_{sorted} = [ 1, 2 ]</script>
      </li>
      <li>
        <script type="math/tex; mode=display">L = [ 5, 3, 3 ]</script>
      </li>
    </ul>
  </li>
  <li>Next, <script type="math/tex">3</script> is picked and moved from <script type="math/tex">L</script> to <script type="math/tex">L_{sorted}</script>, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L_{sorted} = [ 1, 2, 3 ]</script>
      </li>
      <li>
        <script type="math/tex; mode=display">L = [ 5, 3 ]</script>
      </li>
    </ul>
  </li>
  <li>Then, the current minimal value <script type="math/tex">3</script> is moved from <script type="math/tex">L</script> to <script type="math/tex">L_{sorted}</script>, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L_{sorted} = [ 1, 2, 3, 3 ]</script>
      </li>
      <li>
        <script type="math/tex; mode=display">L = [ 5 ]</script>
      </li>
    </ul>
  </li>
  <li>Finally, <script type="math/tex">5</script> is moved into <script type="math/tex">L_{sorted}</script>, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L_{sorted} = [ 1, 2, 3, 3, 5 ]</script>
      </li>
      <li>
        <script type="math/tex; mode=display">L = [ ]</script>
      </li>
    </ul>
  </li>
</ul>

<p>See! the idea is quite simple.
In the same way, to sort the list from maximal to minimal values,
the only different is to pick the maximal value from list each round
instead of minimal value.</p>

<h3 id="how-to-get-minimalor-maximal-value">How to get minimal(or maximal) value</h3>
<p>The way to get minimal(or maximal) items in <script type="math/tex">L</script>
is to linearly search the whole list:
<script type="math/tex">% <![CDATA[
\begin{align}
& \text{Min($L$):} \\
& \space \space \space \space min = L[1] \\
& \space \space \space \space \text{for $i \leftarrow 1$ to $N$:} \\
& \space \space \space \space \space \space \space \space \text{if $L[i] < min$:} \\
& \space \space \space \space \space \space \space \space \space \space \space \space min = L[i] \\
\end{align} %]]></script>
or
<script type="math/tex">% <![CDATA[
\begin{align}
& \text{Max($L$):} \\
& \space \space \space \space max = L[1] \\
& \space \space \space \space \text{for $i \leftarrow 1$ to $N$:} \\
& \space \space \space \space \space \space \space \space \text{if $L[i] > max$:} \\
& \space \space \space \space \space \space \space \space \space \space \space \space max = L[i] \\
\end{align} %]]></script>
, where <script type="math/tex">L[i]</script> is the <script type="math/tex">i</script>th element in the list <script type="math/tex">L</script>
and <script type="math/tex">N</script> is the length of <script type="math/tex">L</script>.</p>

<h3 id="dividing-one-list-into-unsorted-list-and-sorted-list">Dividing one list into unsorted list and sorted list</h3>
<p>In implementation, we usually divide the source list,
which needs to be sorted, into two parts. One is sorted, the other is unsorted.
This is better for memory usage than
creating another list to put the sorted results.</p>

<p>That is, if we have a source list <script type="math/tex">L = [ 5, 3, 1, 2, 3 ]</script>,
it will be divided into <script type="math/tex">L_{sorted}</script> and <script type="math/tex">L_{unsorted}</script>.
They are initialized to <script type="math/tex">[]</script> and <script type="math/tex">L</script> respectively,
so <script type="math/tex">L = L_{sorted} \cup L_{unsorted} = [ ] \cup [ 5, 3, 1, 2, 3 ]</script>.</p>

<ul>
  <li>In the first round, <script type="math/tex">1</script> is picked and moved
from <script type="math/tex">L_{unsorted}</script> to <script type="math/tex">L_{sorted}</script>, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L = L_{sorted} \cup L_{unsorted} = [ 1 ] \cup [ 5, 3, 2, 3 ] = [1 \vert 5, 3, 2, 3]</script>
      </li>
    </ul>
  </li>
  <li>In the second round, <script type="math/tex">2</script> is picked and moved
from <script type="math/tex">L_{unsorted}</script> to <script type="math/tex">L_{sorted}</script>, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L = L_{sorted} \cup L_{unsorted} = [ 1, 2 ] \cup [ 5, 3, 3 ] = [1, 2 \vert 5, 3, 3]</script>
      </li>
    </ul>
  </li>
  <li>Next, <script type="math/tex">3</script> is picked, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L = L_{sorted} \cup L_{unsorted} = [ 1, 2, 3 ] \cup [ 5, 3 ] = [1, 2, 3 \vert 5, 3]</script>
      </li>
    </ul>
  </li>
  <li>Then, another <script type="math/tex">3</script> is picked, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L = L_{sorted} \cup L_{unsorted} = [ 1, 2, 3, 3 ] \cup [ 5 ] = [1, 2, 3, 3 \vert 5]</script>
      </li>
    </ul>
  </li>
  <li>Finally, <script type="math/tex">5</script> is picked, so
    <ul>
      <li>
        <script type="math/tex; mode=display">L = L_{sorted} \cup L_{unsorted} = [ 1, 2, 3, 3, 5 ] \cup [ ] = [1, 2, 3, 3, 5]</script>
      </li>
    </ul>
  </li>
</ul>

<h2 id="algorithm">Algorithm</h2>
<p><script type="math/tex">% <![CDATA[
\begin{align}
& \text{SelectionSort($L$):} \\
& \space \space \space \space \text{for $i \leftarrow 1$ to $\vert L \vert - 1$:} \\
& \space \space \space \space \space \space \space \space m \leftarrow i \\
& \space \space \space \space \space \space \space \space \text{for $j \leftarrow i + 1$ to $\vert L \vert$:} \\
& \space \space \space \space \space \space \space \space \space \space \space \space \text{if $L[j] < L[m]$:} \\
& \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space m \leftarrow j \\
& \space \space \space \space \space \space \space \space \text{swap $L[i]$ and $L[m]$} \\
\end{align} %]]></script></p>

<p>The above method will divide <script type="math/tex">L</script> into two parts.</p>

<ul>
  <li><script type="math/tex">L[1...i-1] = L_{sorted}</script> is sorted</li>
  <li><script type="math/tex">L[i...N] = L_{unsorted}</script> is unsorted,</li>
  <li>where <script type="math/tex">N = \vert L \vert</script> is the length of <script type="math/tex">L</script></li>
</ul>

<p>The following are step by step explanation:</p>

<ul>
  <li>When <script type="math/tex">i = 1</script>
    <ul>
      <li><script type="math/tex">L_{sorted} = []</script> and <script type="math/tex">L_{unsorted} = L[1...N]</script></li>
      <li>we need to find the minimal element in list <script type="math/tex">L[1...N]</script></li>
      <li>We use a value <script type="math/tex">m</script> to track the <strong>index</strong> of the minimal element</li>
      <li>where <script type="math/tex">m</script> is initialized to <script type="math/tex">1</script></li>
      <li><script type="math/tex">m</script> will be updated to <script type="math/tex">j</script>, where <script type="math/tex">2 \leq j \leq N</script>, if <script type="math/tex">% <![CDATA[
L[j] < L[m] %]]></script></li>
      <li>Repeatedly above instruction from <script type="math/tex">j = 2</script> to <script type="math/tex">N</script>(searching whole <script type="math/tex">L_{unsorted}</script>),
<script type="math/tex">L[m]</script> would be the minimal value in <script type="math/tex">L[1...N]</script></li>
      <li>swap <script type="math/tex">L[m]</script> and <script type="math/tex">L[i = 1]</script></li>
      <li>then <script type="math/tex">L[1]</script> now can be considered as <script type="math/tex">L_{sorted}</script></li>
      <li>so <script type="math/tex">L_{unsorted} = L[2...N]</script></li>
    </ul>
  </li>
  <li>When <script type="math/tex">i = 2</script>
    <ul>
      <li><script type="math/tex">L_{sorted} = L[1]</script> and <script type="math/tex">L_{unsorted} = L[2...N]</script></li>
      <li>we need to find the minimal element in list <script type="math/tex">L[2...N]</script></li>
      <li>Same as above, <script type="math/tex">m</script> is used to keep tracking the index of the minimal
element in <script type="math/tex">L_{unsorted}</script></li>
      <li>where <script type="math/tex">m</script> is initialized to <script type="math/tex">2</script></li>
      <li>After searching the whole <script type="math/tex">L_{unsorted}</script>,
<script type="math/tex">L[m]</script> would be the minimal value in <script type="math/tex">L[2...N]</script></li>
      <li>We can put <script type="math/tex">L[m]</script> into the <script type="math/tex">L_{sorted}</script> by swapping the <script type="math/tex">L[m]</script> and <script type="math/tex">L[i = 2]</script></li>
      <li>Thus, <script type="math/tex">L_{sorted} = L[1...2]</script> and <script type="math/tex">L_{unsorted} = L[3...N]</script></li>
    </ul>
  </li>
  <li>When <script type="math/tex">i = k</script>
    <ul>
      <li><script type="math/tex">L_{sorted} = [1...k-1]</script> and <script type="math/tex">L_{unsorted} = L[k...N]</script></li>
      <li><script type="math/tex">m</script> is initialized to <script type="math/tex">k</script></li>
      <li>After searching the whole <script type="math/tex">L_{unsorted}</script>,
<script type="math/tex">L[m]</script> would be the minimal value in <script type="math/tex">L[k...N]</script></li>
      <li>Swapping <script type="math/tex">L[m]</script> and <script type="math/tex">L[i = k]</script> would put <script type="math/tex">L[m]</script> into <script type="math/tex">L_{sorted}</script></li>
      <li>Then, <script type="math/tex">L_{sorted} = L[1...k]</script> and <script type="math/tex">L_{unsorted} = L[k+1...N]</script></li>
    </ul>
  </li>
  <li>When <script type="math/tex">i = N - 1</script>(final round)
    <ul>
      <li><script type="math/tex">L_{sorted} = [1...N-2]</script> and <script type="math/tex">L_{unsorted} = L[N-1...N]</script></li>
      <li><script type="math/tex">m</script> is initialized to <script type="math/tex">N-1</script></li>
      <li>Pick a smaller one between <script type="math/tex">L[N-1]</script> and <script type="math/tex">L[N]</script></li>
      <li>and put it into the <script type="math/tex">L_{sorted}</script> like above(by swapping with <script type="math/tex">L[m]</script>)</li>
      <li>Then <script type="math/tex">L_{sorted} = [1...N-1]</script> and <script type="math/tex">L_{unsorted} = L[N]</script></li>
      <li>The left one(now is <script type="math/tex">L[N]</script>) is definitely the <strong>maximal</strong> item
in <script type="math/tex">L[1...N]</script>, so we don’t need to do anything</li>
    </ul>
  </li>
</ul>

<h3 id="proof">Proof</h3>

<h4 id="proof-by-contradiction">Proof by contradiction</h4>

<ul>
  <li>Assume this method can <strong>not</strong> give us an ordered list</li>
  <li>so it exists one <script type="math/tex">L[p] > L[q]</script>, where <script type="math/tex">% <![CDATA[
p < q %]]></script>, in the result list <script type="math/tex">L</script></li>
  <li>Before the result is computed, the unsorted list could be
<script type="math/tex">L[..p..q..]</script> or <script type="math/tex">L[..q..p..]</script></li>
  <li>It means that <script type="math/tex">L[p]</script> is picked <strong>before</strong> <script type="math/tex">L[q]</script>
because <script type="math/tex">% <![CDATA[
p < q %]]></script> in the result list <script type="math/tex">L</script></li>
  <li>It means <script type="math/tex">% <![CDATA[
L[p] < L[q] %]]></script> and it is contradictory to the assumption</li>
  <li>Thus, the assumption is wrong. This method will give us an ordered list.</li>
</ul>

<h2 id="complexity">Complexity</h2>
<p>We need to search whole <script type="math/tex">L_{unsorted}</script> to find a minimal(or maximal) item.
Suppose <script type="math/tex">\vert L_{unsorted} \vert = N</script> at first.
(the length of <script type="math/tex">L_{unsorted}</script> is <script type="math/tex">N</script>).</p>

<p>At the first round, we need to search <script type="math/tex">N</script> items
to find the minimal(or maximal) item and move it into <script type="math/tex">L_{sorted}</script>.
After then, <script type="math/tex">\vert L_{unsorted} \vert = N - 1</script>.</p>

<p>At the second round, whole <script type="math/tex">N - 1</script> items in <script type="math/tex">L_{unsorted}</script> would be counted
to find the minimal(or maximal) one.
After the picked one is moved into <script type="math/tex">L_{sorted}</script>,
the size of <script type="math/tex">L_{unsorted}</script> is reduced to <script type="math/tex">\vert L_{unsorted} \vert = N - 2</script>.</p>

<p>The procedure keep working until the list <script type="math/tex">L_{unsorted}</script> is empty
(<script type="math/tex">\vert L_{unsorted} \vert = 0</script>).
Thus, we need to search
<script type="math/tex">% <![CDATA[
\begin{align}
N + (N - 1) + (N - 2) + .... + 1
&= \frac{ N \cdot (N + 1) }{ 2 } \\
&= \frac{ 1 }{ 2 } \cdot N^2 + \frac{ 1 }{ 2 } N
\end{align} %]]></script>
times to move all the items into <script type="math/tex">L_{sorted}</script>.
Thus, the complexity is <script type="math/tex">\mathcal{O}(N^2)</script>,
where the <script type="math/tex">N</script> is the length of the list <script type="math/tex">L</script>.</p>

<h2 id="implementation">Implementation</h2>
<p>See the files on <a href="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb" title="Sorting">gist here</a>.</p>

<noscript><pre>#include &lt;algorithm&gt;  // for std::swap
#include &lt;cassert&gt;
#include &quot;sorting.h&quot;

/*
 * Selection sort: O(n^2)
 */
void selectionSort(int list[], unsigned int length)
{
  assert(length);

  // &lt;--  sorted  --&gt;|&lt;--  unsorted  --&gt;
  // +---+---+-------+---+---+---------+
  // | 0 | 1 | ..... | h | i |  .....  |
  // +---+---+-------+---+---+---------+
  //                   ^
  //                head is the begin index of unsorted list.
  for (unsigned int head = 0 ; head &lt; length - 1 ; ++head) {
    // Assume the current head value is the minimal item.
    int minIndex = head;
    for (unsigned int i = head + 1 ; i &lt; length ; ++i) {
      if (list[i] &lt; list[minIndex]) {
        minIndex = i;
      }
    }

    if (head != minIndex) {
      std::swap(list[head], list[minIndex]);
    }
    // After swap with the minimal value of unsorted list, the head now
    // is the tail of the sorted list.
    //
    // &lt;--    sorted    --&gt;|&lt;-- unsorted --&gt;
    // +---+---+-------+---+---------------+
    // | 0 | 1 | ..... | h | ............  |
    // +---+---+-------+---+---------------+
    //                   ^
    //  head now is the last index of the sorted list.
  }
}
</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=selection_sort.cpp"> </script>



                        <br>

                    
                    
                        <div class="entry-tags text-center">
                            <i class="fa fa-tags"></i>&nbsp;
                                Tagged with 
                            
                                <a href="http://localhost:4000/tags/index.html#Sorting" data-toggle="tooltip" title="Posts tagged with Sorting" rel="tag">Sorting</a>

                                
                            
                        </div>
                    
                    </div>

                    <footer class="post-footer entry-meta">
                    
                        <div class="post-share text-center">
    <p class="light small">
        Share this post
    </p>
    <ul class="social-mini">
        <li>
            <a href="https://twitter.com/intent/tweet?text=Selection+Sort%20http://localhost:4000/post/selection-sort%20via%20&#64;"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" data-toggle="tooltip"
                title="Share on Twitter" itemprop="Twitter">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/post/selection-sort" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"
                data-toggle="tooltip" title="Share on Facebook" itemprop="Facebook">
                <i class="fa fa-facebook"></i>
            </a>
        </li>
        <li>
            <a href="https://plus.google.com/share?url=http://localhost:4000/post/selection-sort" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;"
                data-toggle="tooltip" title="Share on Google plus" itemprop="GooglePlus">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
    </ul>
</div>
                    

                        <div class="post-author text-center">
	<img src="http://localhost:4000/images/yosemite.png" alt="Chun-Min Chang's photo" itemprop="image" class="post-avatar img-circle img-responsive" />
	<h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="http://schema.org/Person">
		By <span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About Chun-Min Chang" itemprop="url">Chun-Min Chang</a></span>
	</h4>
	<p>I am a self-directed learner and a maker who enjoys building products from original ideas.</p>
</div> 
                        
                    
                        <div id="disqus_thread"></div><!-- /#disqus_thread -->
                    
                    </footer>

                </article>
            </div>
        </div>
    </div>

    
<footer id="footer" class="blog-background overlay text-center align-middle animated from-top" style="background-image: url(http://localhost:4000/images/background/yosemite/yosemite-tiny.jpg)">


    <div class="inner">
        <div class="container">
            <ul class="social-icons">
                    
                <li>
                    <a href="https://www.linkedin.com/in/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on LinkedIn" target="_blank">
                        <i class="fa fa-linkedin"></i>
                    </a>
                </li>
                   
                <li>
                    <a href="http://github.com/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on Github" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </li>
                
            </ul>
            <div>
                <a href="http://localhost:4000/about/">Chun-Min Chang</a> &copy; 2019 &bull;
                All rights reserved.
            </div>
            <ul class="menu-items">
                
                <li>
                    
                    <a href="http://localhost:4000/"><i class="fa fa-home"></i>&nbsp;Home</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/categories"><i class="fa fa-sitemap"></i>&nbsp;Categories</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/tags"><i class="fa fa-tags"></i>&nbsp;Tags</a>&nbsp;&bull;
                    
                </li>
                
                <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
            </ul>
        </div>
    </div>

    
    <div class="decor-wrapper">
        <svg id="footer-decor" class="decor top" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <!-- <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 0 L50 50 L0 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 0 L50 50 L100 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 0 L50 50 L0 33.3" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 0 L50 50 L100 33.3" fill="rgba(255,255,255, .5)"></path> -->
            <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>
    

</footer>


    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ="
  crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.12.4.min.js"><\/script>')</script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
  crossorigin="anonymous"></script>

<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jekyll-search.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.fitvids.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.waypoints.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/main.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/script.js"></script>
<script type='text/javascript'>$(document).ready(function(){$(".time").text(function(a,b){return Math.round(parseFloat(b))})});</script>

<script type="text/javascript">

/*      Slides       */

$("a#slide").click(function(){
    $("#sidebar,body,a#slide,#fade").addClass("slide")
});

$("#fade,#header,#posts-container").click(function(){
    $("#sidebar,body,a#slide,#fade").removeClass("slide")
});

$("a#click-filter").click(function(){
    $("#slide-filter").slideToggle("medium");
    $("#slide-pages").slideOut("medium");
});

$("a#click-pages").click(function(){
    $("#slide-pages").slideToggle("medium");
    $("#slide-filter").slideOut("medium");
});

/*      End-Slides      */

</script>


<!-- Jekyll Simple Search option -->
<script>

   SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: 'http://localhost:4000/assets/json/search.json',
        searchResultTemplate: '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
        noResultsText: '<p>Nothing found.</p>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $("#search-close"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


 


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'chunminchang-blog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        
</body>
</html>
