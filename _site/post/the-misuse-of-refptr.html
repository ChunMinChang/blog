<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">


<meta name="keywords" content="C/C++, Smart Pointer, Firefox">


<!-- Begin Jekyll SEO tag v1.3.3 -->
<title>The Misuse of RefPtr - Peak Up</title>
<meta property="og:title" content="The Misuse of RefPtr" />
<meta name="description" content="In previous post,I introduced the RefPtr&lt;T&gt; that can keep tracking the references to theobject T and the references are counted by object T itself.Today, I will note my misuse of it several weeks ago.This is also why I want to write the posts about RefPtr&lt;T&gt;.What behavior I wantThe following behavior is what I want when I was implementing one patchfor Firefox:List&lt;RefPtr&lt;Solder&gt;&gt; l; // A list containing all of the solders.{  RefPtr&lt;Solder&gt; s(new Solder(99)); // Put the `s` into the list.}// The `s` is destroyed, so it should be removed from the list now.and we will put the Solder instance into the l whenit’s created and remove it when it’s destroyed.Solder(){  Add this into `l`}~Solder(){  Remove this from `l`}Why it doesn’t workThis is a wrong pattern to meet our expectation.The solders in the list will only be destroyed and removed from the listwhen the whole program is ended.The solders are only removed from the list in its deconstructor.However, whenever the RefPtr&lt;Solder&gt; s(new Solder())is deconstructed (by ~RefPtr) in the main function,the ~Solder() won’t be calledsince there must be one another RefPtr&lt;Solder&gt; some in the listreferencing the solder.Thus, the ~Solder() is only be calledwhen the element in the list is decontructed.Sample code// $ g++ test.cpp --std=c++11#include &quot;RefPtr.h&quot;#include &lt;algorithm&gt;  // std::remove#include &lt;cassert&gt;    // assert#include &lt;iostream&gt;   // std::cout, std::endl#include &lt;vector&gt;     // std::vector///////////////////////////////////////////////////////////////////////////////// Solder Interfaceclass Solder: public ReferenceCount{public:  Solder(int n);  ~Solder();  int CountOff(); // Report the number.private:  int number;};///////////////////////////////////////////////////////////////////////////////// Squad Interfaceclass Squad{public:  static void Add(Solder* s);  static void Remove(Solder* s);  static void CountOff(); // Call all of the solders.  static unsigned int Size();private:  static std::vector&lt;RefPtr&lt;Solder&gt;&gt; members;};///////////////////////////////////////////////////////////////////////////////// Solder ImplementationSolder::Solder(int n)  : number(n){  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is created.&quot; &lt;&lt; std::endl;  Squad::Add(this);}Solder::~Solder(){  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is destroyed.&quot; &lt;&lt; std::endl;  Squad::Remove(this);}intSolder::CountOff(){  return number;}///////////////////////////////////////////////////////////////////////////////// Squad Implementationstd::vector&lt;RefPtr&lt;Solder&gt;&gt; Squad::members;/* static */ voidSquad::Add(Solder* s){  std::cout &lt;&lt; &quot;Add Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; to members.&quot; &lt;&lt; std::endl;  members.push_back(s);}/* static */ voidSquad::Remove(Solder* s){  std::cout &lt;&lt; &quot;Remove Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; from members.&quot; &lt;&lt; std::endl;  members.erase(std::remove(members.begin(), members.end(), s), members.end());}/* static */ voidSquad::CountOff(){  for (auto&amp; m: members) {    std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; m-&gt;CountOff() &lt;&lt; &quot; is here!&quot; &lt;&lt; std::endl;  }}/* static */ unsigned intSquad::Size(){  return members.size();}///////////////////////////////////////////////////////////////////////////////// *** Wrong example to use RefPtr ***//   We will put the Solder instances into the squad when they are created,//   and remove the instances from the squad when they are destroyed.//   We expect the following behavior.////   List&lt;RefPtr&lt;Solder&gt;&gt; l;//   {//     RefPtr&lt;Solder&gt; s(new Solder(99)); // Put s into the list//   }//   // s is destroyed and removed from the list, so list is empty now.int main(){  std::cout &lt;&lt; &quot;Creating a solder and put it into squad.&quot; &lt;&lt; std::endl;  {    RefPtr&lt;Solder&gt; s(new Solder(1));    Squad::CountOff();    // There should be one solder in the squad now.    assert(Squad::Size() == 1 &amp;&amp; s-&gt;GetCount() == 2);  }  std::cout &lt;&lt; &quot;Solder should be removed from squad and destroyed.&quot; &lt;&lt; std::endl;  // In our mind, we expect there is no solder in the squad now.  assert(Squad::Size() == 0); // Comment this to check the below one.  // But it&#39;s wrong. The correct status of the memebers is:  // assert(Squad::Size() == 1);  // In our expectation, we expect the solder 1 will be destroyed and removed  // from the sqaud when the program is running out of &#39;}&#39; above.  // At that time, the ~RefPtr() will be called and check whether we need to  // release the solder 1. However, since we still have a reference to solder 1  // in the members list of the squal, the reference count to solder 1 is not 0.  // Therefore, it won&#39;t be removed!  // Actually,  // ------------------------------------  // List&lt;RefPtr&lt;Solder&gt;&gt; list  // Solder()  // {  //   Add &#39;this&#39; into the list  // }  // ~Solder()  // {  //   Remove &#39;this&#39; from the list  // }  // ------------------------------------  // is a wrong pattern to meet our expectation.  // The solders in the list will only be destroyed and removed from the list  // when the whole program is ended. The solders are only removed from  // the list in its deconstructor. However, whenever the  // RefPtr&lt;Solder&gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,  // the ~Solder() won&#39;t be called since there must be one another  // RefPtr&lt;Solder&gt; in the list referencing the solder.  // Thus, the ~Solder() is only be called when the element in the list is  // decontructed.  return 0;}" />
<meta property="og:description" content="In previous post,I introduced the RefPtr&lt;T&gt; that can keep tracking the references to theobject T and the references are counted by object T itself.Today, I will note my misuse of it several weeks ago.This is also why I want to write the posts about RefPtr&lt;T&gt;.What behavior I wantThe following behavior is what I want when I was implementing one patchfor Firefox:List&lt;RefPtr&lt;Solder&gt;&gt; l; // A list containing all of the solders.{  RefPtr&lt;Solder&gt; s(new Solder(99)); // Put the `s` into the list.}// The `s` is destroyed, so it should be removed from the list now.and we will put the Solder instance into the l whenit’s created and remove it when it’s destroyed.Solder(){  Add this into `l`}~Solder(){  Remove this from `l`}Why it doesn’t workThis is a wrong pattern to meet our expectation.The solders in the list will only be destroyed and removed from the listwhen the whole program is ended.The solders are only removed from the list in its deconstructor.However, whenever the RefPtr&lt;Solder&gt; s(new Solder())is deconstructed (by ~RefPtr) in the main function,the ~Solder() won’t be calledsince there must be one another RefPtr&lt;Solder&gt; some in the listreferencing the solder.Thus, the ~Solder() is only be calledwhen the element in the list is decontructed.Sample code// $ g++ test.cpp --std=c++11#include &quot;RefPtr.h&quot;#include &lt;algorithm&gt;  // std::remove#include &lt;cassert&gt;    // assert#include &lt;iostream&gt;   // std::cout, std::endl#include &lt;vector&gt;     // std::vector///////////////////////////////////////////////////////////////////////////////// Solder Interfaceclass Solder: public ReferenceCount{public:  Solder(int n);  ~Solder();  int CountOff(); // Report the number.private:  int number;};///////////////////////////////////////////////////////////////////////////////// Squad Interfaceclass Squad{public:  static void Add(Solder* s);  static void Remove(Solder* s);  static void CountOff(); // Call all of the solders.  static unsigned int Size();private:  static std::vector&lt;RefPtr&lt;Solder&gt;&gt; members;};///////////////////////////////////////////////////////////////////////////////// Solder ImplementationSolder::Solder(int n)  : number(n){  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is created.&quot; &lt;&lt; std::endl;  Squad::Add(this);}Solder::~Solder(){  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is destroyed.&quot; &lt;&lt; std::endl;  Squad::Remove(this);}intSolder::CountOff(){  return number;}///////////////////////////////////////////////////////////////////////////////// Squad Implementationstd::vector&lt;RefPtr&lt;Solder&gt;&gt; Squad::members;/* static */ voidSquad::Add(Solder* s){  std::cout &lt;&lt; &quot;Add Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; to members.&quot; &lt;&lt; std::endl;  members.push_back(s);}/* static */ voidSquad::Remove(Solder* s){  std::cout &lt;&lt; &quot;Remove Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; from members.&quot; &lt;&lt; std::endl;  members.erase(std::remove(members.begin(), members.end(), s), members.end());}/* static */ voidSquad::CountOff(){  for (auto&amp; m: members) {    std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; m-&gt;CountOff() &lt;&lt; &quot; is here!&quot; &lt;&lt; std::endl;  }}/* static */ unsigned intSquad::Size(){  return members.size();}///////////////////////////////////////////////////////////////////////////////// *** Wrong example to use RefPtr ***//   We will put the Solder instances into the squad when they are created,//   and remove the instances from the squad when they are destroyed.//   We expect the following behavior.////   List&lt;RefPtr&lt;Solder&gt;&gt; l;//   {//     RefPtr&lt;Solder&gt; s(new Solder(99)); // Put s into the list//   }//   // s is destroyed and removed from the list, so list is empty now.int main(){  std::cout &lt;&lt; &quot;Creating a solder and put it into squad.&quot; &lt;&lt; std::endl;  {    RefPtr&lt;Solder&gt; s(new Solder(1));    Squad::CountOff();    // There should be one solder in the squad now.    assert(Squad::Size() == 1 &amp;&amp; s-&gt;GetCount() == 2);  }  std::cout &lt;&lt; &quot;Solder should be removed from squad and destroyed.&quot; &lt;&lt; std::endl;  // In our mind, we expect there is no solder in the squad now.  assert(Squad::Size() == 0); // Comment this to check the below one.  // But it&#39;s wrong. The correct status of the memebers is:  // assert(Squad::Size() == 1);  // In our expectation, we expect the solder 1 will be destroyed and removed  // from the sqaud when the program is running out of &#39;}&#39; above.  // At that time, the ~RefPtr() will be called and check whether we need to  // release the solder 1. However, since we still have a reference to solder 1  // in the members list of the squal, the reference count to solder 1 is not 0.  // Therefore, it won&#39;t be removed!  // Actually,  // ------------------------------------  // List&lt;RefPtr&lt;Solder&gt;&gt; list  // Solder()  // {  //   Add &#39;this&#39; into the list  // }  // ~Solder()  // {  //   Remove &#39;this&#39; from the list  // }  // ------------------------------------  // is a wrong pattern to meet our expectation.  // The solders in the list will only be destroyed and removed from the list  // when the whole program is ended. The solders are only removed from  // the list in its deconstructor. However, whenever the  // RefPtr&lt;Solder&gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,  // the ~Solder() won&#39;t be called since there must be one another  // RefPtr&lt;Solder&gt; in the list referencing the solder.  // Thus, the ~Solder() is only be called when the element in the list is  // decontructed.  return 0;}" />
<link rel="canonical" href="http://localhost:4000/post/the-misuse-of-refptr" />
<meta property="og:url" content="http://localhost:4000/post/the-misuse-of-refptr" />
<meta property="og:site_name" content="Peak Up" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-08T00:00:00+08:00" />
<link rel="next" href="http://localhost:4000/post/closed-form-for-the-fibonacci-sequence" title="Closed Form for the Fibonacci Sequence" />
<link rel="prev" href="http://localhost:4000/post/refptr-v-s-shared-ptr" title="RefPtr v.s. shared_ptr" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "The Misuse of RefPtr",
    "datePublished": "2017-08-08T00:00:00+08:00",
    "description": "In previous post,I introduced the RefPtr&lt;T&gt; that can keep tracking the references to theobject T and the references are counted by object T itself.Today, I will note my misuse of it several weeks ago.This is also why I want to write the posts about RefPtr&lt;T&gt;.What behavior I wantThe following behavior is what I want when I was implementing one patchfor Firefox:List&lt;RefPtr&lt;Solder&gt;&gt; l; // A list containing all of the solders.{  RefPtr&lt;Solder&gt; s(new Solder(99)); // Put the `s` into the list.}// The `s` is destroyed, so it should be removed from the list now.and we will put the Solder instance into the l whenit’s created and remove it when it’s destroyed.Solder(){  Add this into `l`}~Solder(){  Remove this from `l`}Why it doesn’t workThis is a wrong pattern to meet our expectation.The solders in the list will only be destroyed and removed from the listwhen the whole program is ended.The solders are only removed from the list in its deconstructor.However, whenever the RefPtr&lt;Solder&gt; s(new Solder())is deconstructed (by ~RefPtr) in the main function,the ~Solder() won’t be calledsince there must be one another RefPtr&lt;Solder&gt; some in the listreferencing the solder.Thus, the ~Solder() is only be calledwhen the element in the list is decontructed.Sample code// $ g++ test.cpp --std=c++11#include &quot;RefPtr.h&quot;#include &lt;algorithm&gt;  // std::remove#include &lt;cassert&gt;    // assert#include &lt;iostream&gt;   // std::cout, std::endl#include &lt;vector&gt;     // std::vector///////////////////////////////////////////////////////////////////////////////// Solder Interfaceclass Solder: public ReferenceCount{public:  Solder(int n);  ~Solder();  int CountOff(); // Report the number.private:  int number;};///////////////////////////////////////////////////////////////////////////////// Squad Interfaceclass Squad{public:  static void Add(Solder* s);  static void Remove(Solder* s);  static void CountOff(); // Call all of the solders.  static unsigned int Size();private:  static std::vector&lt;RefPtr&lt;Solder&gt;&gt; members;};///////////////////////////////////////////////////////////////////////////////// Solder ImplementationSolder::Solder(int n)  : number(n){  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is created.&quot; &lt;&lt; std::endl;  Squad::Add(this);}Solder::~Solder(){  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is destroyed.&quot; &lt;&lt; std::endl;  Squad::Remove(this);}intSolder::CountOff(){  return number;}///////////////////////////////////////////////////////////////////////////////// Squad Implementationstd::vector&lt;RefPtr&lt;Solder&gt;&gt; Squad::members;/* static */ voidSquad::Add(Solder* s){  std::cout &lt;&lt; &quot;Add Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; to members.&quot; &lt;&lt; std::endl;  members.push_back(s);}/* static */ voidSquad::Remove(Solder* s){  std::cout &lt;&lt; &quot;Remove Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; from members.&quot; &lt;&lt; std::endl;  members.erase(std::remove(members.begin(), members.end(), s), members.end());}/* static */ voidSquad::CountOff(){  for (auto&amp; m: members) {    std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; m-&gt;CountOff() &lt;&lt; &quot; is here!&quot; &lt;&lt; std::endl;  }}/* static */ unsigned intSquad::Size(){  return members.size();}///////////////////////////////////////////////////////////////////////////////// *** Wrong example to use RefPtr ***//   We will put the Solder instances into the squad when they are created,//   and remove the instances from the squad when they are destroyed.//   We expect the following behavior.////   List&lt;RefPtr&lt;Solder&gt;&gt; l;//   {//     RefPtr&lt;Solder&gt; s(new Solder(99)); // Put s into the list//   }//   // s is destroyed and removed from the list, so list is empty now.int main(){  std::cout &lt;&lt; &quot;Creating a solder and put it into squad.&quot; &lt;&lt; std::endl;  {    RefPtr&lt;Solder&gt; s(new Solder(1));    Squad::CountOff();    // There should be one solder in the squad now.    assert(Squad::Size() == 1 &amp;&amp; s-&gt;GetCount() == 2);  }  std::cout &lt;&lt; &quot;Solder should be removed from squad and destroyed.&quot; &lt;&lt; std::endl;  // In our mind, we expect there is no solder in the squad now.  assert(Squad::Size() == 0); // Comment this to check the below one.  // But it&#39;s wrong. The correct status of the memebers is:  // assert(Squad::Size() == 1);  // In our expectation, we expect the solder 1 will be destroyed and removed  // from the sqaud when the program is running out of &#39;}&#39; above.  // At that time, the ~RefPtr() will be called and check whether we need to  // release the solder 1. However, since we still have a reference to solder 1  // in the members list of the squal, the reference count to solder 1 is not 0.  // Therefore, it won&#39;t be removed!  // Actually,  // ------------------------------------  // List&lt;RefPtr&lt;Solder&gt;&gt; list  // Solder()  // {  //   Add &#39;this&#39; into the list  // }  // ~Solder()  // {  //   Remove &#39;this&#39; from the list  // }  // ------------------------------------  // is a wrong pattern to meet our expectation.  // The solders in the list will only be destroyed and removed from the list  // when the whole program is ended. The solders are only removed from  // the list in its deconstructor. However, whenever the  // RefPtr&lt;Solder&gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,  // the ~Solder() won&#39;t be called since there must be one another  // RefPtr&lt;Solder&gt; in the list referencing the solder.  // Thus, the ~Solder() is only be called when the element in the list is  // decontructed.  return 0;}",
    "logo": "http://localhost:4000mountain.png",
    "url": "http://localhost:4000/post/the-misuse-of-refptr"
  }
</script>
<!-- End Jekyll SEO tag -->

<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Peak Up" />

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
    crossorigin="anonymous">

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/style.css" />
<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/syntax.css" />




<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/images/favicons/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/favicons/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/favicons/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/favicons/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/favicons/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post-template" itemscope itemtype="http://schema.org/WebPage">

    
<div class="search-wrapper">
    <div class="search-form">
        <input type="text" id="search-input" class="search-field" placeholder="Search...">
        <i id="search-close" class="fa fa-times-circle"></i>
        <h4>Search results</h4>
        <ul id="results-container" class="search-results post-list">
        </ul>
        <!-- /.search-results -->
    </div>
    <!-- /.search-form -->
</div>
<!-- ./search-wrapper -->


<div id="fade"></div>
<a id="slide" class="animated fade">
    <i class="fa fa-bars" aria-hidden="true"></i>
</a>
<aside id="sidebar">
    <nav id="navigation">
        <h2>MENU</h2>
        <hr>
        <ul> 
            <li>
                <a href="http://localhost:4000/"><!-- <i class="fa fa-home"></i>&nbsp;-->Home</a>  </li>
            
            <li>
                <a href="http://localhost:4000/categories"><!-- <i class="fa fa-sitemap"></i>&nbsp;-->Categories</a>  </li>
            
            <li>
                <a href="http://localhost:4000/tags"><!-- <i class="fa fa-tags"></i>&nbsp;-->Tags</a>  </li>
            
            <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
        </ul>
    </nav>
</aside>


<header id="masthead" class="blog-background overlay align-center align-middle animated from-bottom" style="background-image: url(http://localhost:4000/images/background/yosemite/yosemite1.png)"
    itemscope itemtype="http://schema.org/Organization">



    <button class="menu-button animated fade dosearch">
        <i class="fa fa-search"></i>
    </button>



    <div class="inner">
        <div class="container">
            <a class="brand" href="http://localhost:4000/" itemprop="url">
                <img itemprop="logo" src="http://localhost:4000/images/mountain.png" alt="Peak Up Logo" />
                <h1 class="blog-title light" itemprop="name">
                    Peak Up
                </h1>
            </a>
        </div>
    </div>



    <div class="decor-wrapper">
        <svg id="header-decor" class="decor bottom" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 100 L50 50 L0 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 100 L50 50 L100 33.3" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 100 L50 50 L0 66.6" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 100 L50 50 L100 66.6" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>

</header>


    <div id="main" class="content" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
        <div class="container">
            <div class="row">
                <article class="post col-md-8 col-md-offset-2 hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
                
                
                
                

                    <header class="post-header entry-header">

                    

                    
                        <h1 class="post-title text-center hyper lighter bordered-bottom entry-title" itemprop="headline">
                        
                            
                        
                        
                        

                        
                            The Misuse of RefPtr
                        </h1>
                    

                        <div class="cursive" style="color: #000; font-style:italic;"></div>

                            <div class="post-info text-center small">
                            
                                <span class="entry-date date published updated">
                            
                            
                                    <time datetime="2017-08-08T00:00:00+08:00" class="post-time" itemprop="datePublished">08 Aug 2017</time>
                                </span>
                            

                                in <span class="post-tags">

                            
                                    <a href="http://localhost:4000/categories/index.html#Common" data-toggle="tooltip" title="Other posts from the Common category" rel="tag">Common</a>
                                
                            
                                </span>
                            
                            &nbsp;
                                <span class="post-tags"><i class="fa fa-clock-o"></i>&nbsp;

                            

                            
                                    <span class="time">4.55</span> minutes read
                            
                                
                            

                                </span>
                            
                            </div>

                    </header>

                    <div class="post-body bordered-bottom" itemprop="description">
                    

                        <p>In <!--[last post](/post/refptr-v-s-shared-ptr)-->
<a href="https://chunminchang.github.io/blog/post/refptr-v-s-shared-ptr">previous post</a>,
I introduced the <code class="highlighter-rouge">RefPtr&lt;T&gt;</code> that can keep tracking the references to the
object <code class="highlighter-rouge">T</code> and the references are counted by object <code class="highlighter-rouge">T</code> itself.</p>

<p>Today, I will note my misuse of it several weeks ago.
This is also why I want to write the posts about <code class="highlighter-rouge">RefPtr&lt;T&gt;</code>.</p>

<h2 id="what-behavior-i-want">What behavior I want</h2>
<p>The following behavior is what I want when I was implementing one patch
for Firefox:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Solder</span><span class="o">&gt;&gt;</span> <span class="n">l</span><span class="p">;</span> <span class="c1">// A list containing all of the solders.
</span><span class="p">{</span>
  <span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Solder</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="k">new</span> <span class="n">Solder</span><span class="p">(</span><span class="mi">99</span><span class="p">));</span> <span class="c1">// Put the `s` into the list.
</span><span class="p">}</span>
<span class="c1">// The `s` is destroyed, so it should be removed from the list now.
</span></code></pre>
</div>

<p>and we will put the <code class="highlighter-rouge">Solder</code> instance into the <code class="highlighter-rouge">l</code> when
it’s created and remove it when it’s destroyed.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Solder</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Add</span> <span class="k">this</span> <span class="n">into</span> <span class="err">`</span><span class="n">l</span><span class="err">`</span>
<span class="p">}</span>
<span class="o">~</span><span class="n">Solder</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Remove</span> <span class="k">this</span> <span class="n">from</span> <span class="err">`</span><span class="n">l</span><span class="err">`</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="why-it-doesnt-work">Why it doesn’t work</h2>
<p>This is a wrong pattern to meet our expectation.
The solders in the list will <strong>only</strong> be destroyed and removed from the list
when the whole program is ended.
The solders are only removed from the list in its deconstructor.
However, whenever the <code class="highlighter-rouge">RefPtr&lt;Solder&gt; s(new Solder())</code>
is deconstructed (by <code class="highlighter-rouge">~RefPtr</code>) in the main function,
the <code class="highlighter-rouge">~Solder()</code> won’t be called
since there must be one another <code class="highlighter-rouge">RefPtr&lt;Solder&gt; some</code> in the list
referencing the solder.
Thus, the <code class="highlighter-rouge">~Solder()</code> is only be called
when the element in the list is decontructed.</p>

<h2 id="sample-code">Sample code</h2>
<noscript><pre>// $ g++ test.cpp --std=c++11
#include &quot;RefPtr.h&quot;
#include &lt;algorithm&gt;  // std::remove
#include &lt;cassert&gt;    // assert
#include &lt;iostream&gt;   // std::cout, std::endl
#include &lt;vector&gt;     // std::vector

///////////////////////////////////////////////////////////////////////////////
// Solder Interface
class Solder: public ReferenceCount
{
public:
  Solder(int n);
  ~Solder();
  int CountOff(); // Report the number.

private:
  int number;
};

///////////////////////////////////////////////////////////////////////////////
// Squad Interface
class Squad
{
public:
  static void Add(Solder* s);
  static void Remove(Solder* s);
  static void CountOff(); // Call all of the solders.
  static unsigned int Size();
private:
  static std::vector&lt;RefPtr&lt;Solder&gt;&gt; members;
};

///////////////////////////////////////////////////////////////////////////////
// Solder Implementation
Solder::Solder(int n)
  : number(n)
{
  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is created.&quot; &lt;&lt; std::endl;
  Squad::Add(this);
}

Solder::~Solder()
{
  std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; number &lt;&lt; &quot; is destroyed.&quot; &lt;&lt; std::endl;
  Squad::Remove(this);
}

int
Solder::CountOff()
{
  return number;
}

///////////////////////////////////////////////////////////////////////////////
// Squad Implementation
std::vector&lt;RefPtr&lt;Solder&gt;&gt; Squad::members;

/* static */ void
Squad::Add(Solder* s)
{
  std::cout &lt;&lt; &quot;Add Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; to members.&quot; &lt;&lt; std::endl;
  members.push_back(s);
}

/* static */ void
Squad::Remove(Solder* s)
{
  std::cout &lt;&lt; &quot;Remove Solder &quot; &lt;&lt; s-&gt;CountOff() &lt;&lt; &quot; from members.&quot; &lt;&lt; std::endl;
  members.erase(std::remove(members.begin(), members.end(), s), members.end());
}

/* static */ void
Squad::CountOff()
{
  for (auto&amp; m: members) {
    std::cout &lt;&lt; &quot;Solder &quot; &lt;&lt; m-&gt;CountOff() &lt;&lt; &quot; is here!&quot; &lt;&lt; std::endl;
  }
}

/* static */ unsigned int
Squad::Size()
{
  return members.size();
}

///////////////////////////////////////////////////////////////////////////////
// *** Wrong example to use RefPtr ***
//   We will put the Solder instances into the squad when they are created,
//   and remove the instances from the squad when they are destroyed.
//   We expect the following behavior.
//
//   List&lt;RefPtr&lt;Solder&gt;&gt; l;
//   {
//     RefPtr&lt;Solder&gt; s(new Solder(99)); // Put s into the list
//   }
//   // s is destroyed and removed from the list, so list is empty now.
int main()
{
  std::cout &lt;&lt; &quot;Creating a solder and put it into squad.&quot; &lt;&lt; std::endl;

  {
    RefPtr&lt;Solder&gt; s(new Solder(1));
    Squad::CountOff();
    // There should be one solder in the squad now.
    assert(Squad::Size() == 1 &amp;&amp; s-&gt;GetCount() == 2);
  }

  std::cout &lt;&lt; &quot;Solder should be removed from squad and destroyed.&quot; &lt;&lt; std::endl;
  // In our mind, we expect there is no solder in the squad now.
  assert(Squad::Size() == 0); // Comment this to check the below one.
  // But it&#39;s wrong. The correct status of the memebers is:
  // assert(Squad::Size() == 1);

  // In our expectation, we expect the solder 1 will be destroyed and removed
  // from the sqaud when the program is running out of &#39;}&#39; above.
  // At that time, the ~RefPtr() will be called and check whether we need to
  // release the solder 1. However, since we still have a reference to solder 1
  // in the members list of the squal, the reference count to solder 1 is not 0.
  // Therefore, it won&#39;t be removed!

  // Actually,
  // ------------------------------------
  // List&lt;RefPtr&lt;Solder&gt;&gt; list
  // Solder()
  // {
  //   Add &#39;this&#39; into the list
  // }
  // ~Solder()
  // {
  //   Remove &#39;this&#39; from the list
  // }
  // ------------------------------------
  // is a wrong pattern to meet our expectation.
  // The solders in the list will only be destroyed and removed from the list
  // when the whole program is ended. The solders are only removed from
  // the list in its deconstructor. However, whenever the
  // RefPtr&lt;Solder&gt; s(new Solder(x)) is deconstructed (by ~RefPtr) in the main,
  // the ~Solder() won&#39;t be called since there must be one another
  // RefPtr&lt;Solder&gt; in the list referencing the solder.
  // Thus, the ~Solder() is only be called when the element in the list is
  // decontructed.

  return 0;
}</pre></noscript>
<script src="https://gist.github.com/ChunMinChang/e783052c7da8b4bd5678dbc26de84ab1.js?file=misuse.cpp"> </script>



                        <br>

                    
                    
                        <div class="entry-tags text-center">
                            <i class="fa fa-tags"></i>&nbsp;
                                Tagged with 
                            
                                <a href="http://localhost:4000/tags/index.html#C/C++" data-toggle="tooltip" title="Posts tagged with C/C++" rel="tag">C/C++</a>

                                
                                &nbsp;&bull;&nbsp;
                                
                            
                                <a href="http://localhost:4000/tags/index.html#Smart Pointer" data-toggle="tooltip" title="Posts tagged with Smart Pointer" rel="tag">Smart Pointer</a>

                                
                                &nbsp;&bull;&nbsp;
                                
                            
                                <a href="http://localhost:4000/tags/index.html#Firefox" data-toggle="tooltip" title="Posts tagged with Firefox" rel="tag">Firefox</a>

                                
                            
                        </div>
                    
                    </div>

                    <footer class="post-footer entry-meta">
                    
                        <div class="post-share text-center">
    <p class="light small">
        Share this post
    </p>
    <ul class="social-mini">
        <li>
            <a href="https://twitter.com/intent/tweet?text=The+Misuse+of+RefPtr%20http://localhost:4000/post/the-misuse-of-refptr%20via%20&#64;"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" data-toggle="tooltip"
                title="Share on Twitter" itemprop="Twitter">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/post/the-misuse-of-refptr" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"
                data-toggle="tooltip" title="Share on Facebook" itemprop="Facebook">
                <i class="fa fa-facebook"></i>
            </a>
        </li>
        <li>
            <a href="https://plus.google.com/share?url=http://localhost:4000/post/the-misuse-of-refptr" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;"
                data-toggle="tooltip" title="Share on Google plus" itemprop="GooglePlus">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
    </ul>
</div>
                    

                        <div class="post-author text-center">
	<img src="http://localhost:4000/images/yosemite.png" alt="Chun-Min Chang's photo" itemprop="image" class="post-avatar img-circle img-responsive" />
	<h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="http://schema.org/Person">
		By <span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About Chun-Min Chang" itemprop="url">Chun-Min Chang</a></span>
	</h4>
	<p>I am a self-directed learner and a maker who enjoys building products from original ideas.</p>
</div> 
                        
                    
                        <div id="disqus_thread"></div><!-- /#disqus_thread -->
                    
                    </footer>

                </article>
            </div>
        </div>
    </div>

    
<footer id="footer" class="blog-background overlay text-center align-middle animated from-top" style="background-image: url(http://localhost:4000/images/background/yosemite/yosemite1.png)">


    <div class="inner">
        <div class="container">
            <ul class="social-icons">
                    
                <li>
                    <a href="https://www.linkedin.com/in/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on LinkedIn" target="_blank">
                        <i class="fa fa-linkedin"></i>
                    </a>
                </li>
                   
                <li>
                    <a href="http://github.com/chunminchang" data-toggle="tooltip" title="Chun-Min Chang on Github" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </li>
                
            </ul>
            <div>
                <a href="http://localhost:4000/about/">Chun-Min Chang</a> &copy; 2017 &bull;
                All rights reserved.
            </div>
            <ul class="menu-items">
                
                <li>
                    
                    <a href="http://localhost:4000/"><i class="fa fa-home"></i>&nbsp;Home</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/categories"><i class="fa fa-sitemap"></i>&nbsp;Categories</a>&nbsp;&bull;
                    
                </li>
                
                <li>
                    
                    <a href="http://localhost:4000/tags"><i class="fa fa-tags"></i>&nbsp;Tags</a>&nbsp;&bull;
                    
                </li>
                
                <li><a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss"></i> Feed</a></li>
            </ul>
        </div>
    </div>

    
    <div class="decor-wrapper">
        <svg id="footer-decor" class="decor top" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path>
            <path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path>
            <path class="medium left" d="M0 0 L50 50 L0 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="medium right" d="M100 0 L50 50 L100 66.6" fill="rgba(255,255,255, .3)"></path>
            <path class="small left" d="M0 0 L50 50 L0 33.3" fill="rgba(255,255,255, .5)"></path>
            <path class="small right" d="M100 0 L50 50 L100 33.3" fill="rgba(255,255,255, .5)"></path>
            <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path>
            <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path>
        </svg>
    </div>
    

</footer>


    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ="
  crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.12.4.min.js"><\/script>')</script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
  crossorigin="anonymous"></script>

<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jekyll-search.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.fitvids.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.waypoints.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/plugins/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/main.js"></script>
<script type="text/javascript" src="http://localhost:4000/assets/js/script.js"></script>
<script type='text/javascript'>$(document).ready(function(){$(".time").text(function(a,b){return Math.round(parseFloat(b))})});</script>

<script type="text/javascript">

/*      Slides       */

$("a#slide").click(function(){
    $("#sidebar,body,a#slide,#fade").addClass("slide")
});

$("#fade,#header,#posts-container").click(function(){
    $("#sidebar,body,a#slide,#fade").removeClass("slide")
});

$("a#click-filter").click(function(){
    $("#slide-filter").slideToggle("medium");
    $("#slide-pages").slideOut("medium");
});

$("a#click-pages").click(function(){
    $("#slide-pages").slideToggle("medium");
    $("#slide-filter").slideOut("medium");
});

/*      End-Slides      */

</script>


<!-- Jekyll Simple Search option -->
<script>

   SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: 'http://localhost:4000/assets/json/search.json',
        searchResultTemplate: '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
        noResultsText: '<p>Nothing found.</p>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $("#search-close"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


 


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'chunminchang-blog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        
</body>
</html>
